blob
data 13302
BRL-CAD To Do List
==================

Included below is a list of things that are scheduled or desirable to
be done at some point.  Most recently added items are on top, older
topics are on the bottom.  This is not an official list, it's more a
scratch pad for the developers to use for tracking development ideas
and informal plans.

The items listed for release should not ever hinder, stop, or
otherwise delay a release from being made.  The items listed are
merely to give an estimate of what was expected to be done.  See the
project task tracker for more to do items and future planning efforts.
http://sf.net/pm/?group_id=105292


THESE SHOULD HAPPEN BEFORE THE NEXT RELEASE
-------------------------------------------

* release!


THESE SHOULD HAPPEN WITHIN TWO RELEASE ITERATIONS
-------------------------------------------------

* fix incrTcl pathing issues when only using system tcl/tk
  (get incrTcl subconfigure to work like was done for Tcl)

* fix framebuffer refresh bug.  problem was caused when the if_ogl
  framebuffer was changed (back) to request a direct rendering
  context.  presumably that is triggering other code that is failing
  to redraw.

* implement/test the "Blinn blob" method in g_metaball.c

* verify/finish clone mirror support

* address the TODO items in src/mged/clone.c

* (re)verify rtarea results, fix naming convention

* ADRT: remove MySQL code, fix ISST callbacks, re-enable RISE, cleanup

* extend metaball control info beyond simple points


THESE ARE LOWER PRIORITY OR FOR FUTURE RELEASES
-----------------------------------------------

* develop a low-level tool for investigating, reporting statistics on,
  and repairing geometry database files.  the tool should nominally
  perform big/little endian conversions, report number and types of
  objects, allow deletion/undeletion/hiding/unhiding, provide some
  general means to manipulate the packed and unpacked .g file data for
  performing low-level modifications.

* make z-clipping off by default

* fix the "(type)(size_t)val" hacks (using ints like ptrs, etc)

* fix rt parallel crash
  (true ; while [ $? -eq 0 ] ; do rt -o /dev/null moss.g all.g ; done)

* fix parallel crash report generation (multiple BU_MAPPED_FILE's
  getting acquired)

* make closing both the command window and graphics window shut down
  mged (i.e., fix unintentional behavior)

* convert the documentation to docbook

* autogenerate docbook documentation in the build system

* remove hit_normal and hit_point from struct hit.  add RT_HIT_POINT
  macro.  refactor all callers as needed.

* add option to nirt for reporting the exit point (instead of LOS)

* add option to nirt for reporting the gaps between geometry

* implement graphical crash reporter tool (bombardier)

* test mged text flood hang (e.g. large rtarea report) on slow machine

* windows smp support

* modify the new tree traversal code to be generic

* expose nmg_fix_normals through a set of mesh repair routines

* add high dynamic range image support to the framebuffers

* add alpha channel support to the framebuffers

* remote framebuffer timeout support (perhaps as ::key=val;key=val)

* make byteoffset and run-time byteorder detections necessary in order
  for Mac OS X universal binaries to actually work.

* review and integrate David Loman's bot-processing and object label
  scripts, add libdm interface for textual overlay support

* review librt polynomial root solver

* eliminate vararg.h and non-ansi cray-specific support code

* implement a lighting model for rt that visualizes how expensive each
  individual pixel is to compute with an intensity (heat graph)

* integrate 'the rest' of adrt, consider decoupling the dependencies

* integrate July 2007 openNURBS updates

* bezier extrusions need to be optimized, really should not be
  performing dynamic memory allocation in the root solver

* better/consistent argument processing supporting both long and short
  option names, perhaps using argtable

* decouple libdm from librt -- just one file in libdm uses librt,
  including a whole nasty primitive switch statement.  need to push
  that back over into librt.

* Implement an optical shader for the new "pixelated" military
  camouflage style

* preserve an arb8 as an arb8 (instead of writing as arb6 or arb5) and
  similarly for the other arb# sizes

* validate primitives during export so that it is guaranteed that
  illegal primitives will not be written to file

* implement a region annointment command where the user can turn an
  assembly into a region and change all lower or higher regions into
  combinations

* some means to obtain progress status during raytrace renderings

* enhance dxf-g to create more than just one combination per layer,
  creating multiple objects for the individual objects in the dxf file
  (instead of one conglomerate BoT)

* change root solver to have coefficients in the right order (!)

* use environ for run-time path lookups

* add an overlap depth reporting tolerance parameter to the
  ray-tracers (similar to -R).

* script that checks a dist source tarball for missing files

* Use NSIS instead of InstallShield/MSI for Windows binary releases

* Generate plain .zip files for Windows binary releases

* fix the variety of ami.tcl and ampi.tcl tclscript warnings/errors

* run indent.sh on directories (one at a time, validating results)

* set c-indentation-style to k&r to override default gnu style setting
  in Emacs. (see c-set-style)

* add support for arbitrary matrix transformations to torus primitive

* add configuration checks and build system support to disable C++
  outright if necessary, e.g. an --enable-c++ option

* configure support to enable/disable framebuffers, display
  managers, geometry converters, and image converters.  consider
  apache's module management as an example.

* review "eclectic" from GSI as a tessellation approach

* review and merge in the rest of the GSI modifications

* make target and/or script to update ChangeLog and version
  information, possibly including checking for consistency, to
  facilitate release process.

* add the automated rtarea spreadsheet-producing script to repository

* add some means to disable/minimize libfft on systems that don't have
  enough memory to compile the larger filters

* display the current mode in mged graphics window

* full/exact precision computation support

* c++ geometry engine/api using librt/libbn/libbu

* inside/outside point and voxel testing capability in librt

* automatic geometry voxelizer (perhaps using arbs or vol primitive)

* turn geometry converters and image converters into libraries

* add support for querying geometry properties to library including
  computing surface area and weight/mass.

* add verification and validation tests confirming behavior of the
  ray-tracer and computations of area, mass, volume, etc.

* testing suite for all binaries: for cmd2 in $(for cmd in `find . -name Makefile.am | xargs cat | perl -pi -e 's/\\\\\n//g'| grep -E "PROGRAMS ?=" | sed 's/.*=//g'` ; do echo $cmd ; done | sort | uniq ) ; do echo command: $cmd2 ; done

* add geometry example of building 238

* Mac OS X SGI dial knobs support

* merge old and 'new' tops behavior into one, preserving compatibility
  where it makes sense.

* ability to "unpush" objects, translating them to a new position and
  applying the correct matrix (using either bounding box or center of
  mass, for example)

* ensure successful build on mingw

* test for USE_FORKED_THREADS in configure

* optimize CSG structures automatically, automatic simplification.

* option to mged make command or new command that enters solid edit
  mode, "med", "smake", "makes", "msed", etc.  same for cp command.

* recursive configure and variable overrides for autogen.sh

* optimize configure testing so that when options are enabled, the
  corresponding library and functionality tests are not performed.

* have libbu report memory allocation statistics so the exact amount
  of memory requirements for a geometry database can be computed on
  the fly via a pre-prep phase.

* center of presented area

* short introductory documentation on using mged, covering a majority
  of the various commands.

* support to the raytracers for multiple image file formats,
  recognizing an option and/or the file suffix of the -o filename.

* libfb + font rendering (perhaps through libbn's plot interface) for
  a posix terminal.

* Optional compile-time support for using GMP or CLN for arbitrary
  precision arithmetic.

* gpgpu for enhanced performance boolweave sorting

* getexecname, "/proc/self/cmdline", program_invocation_short_name.
  separate out into new file.

* geometry viewing commands/visualizations of exploded levels

* add command line help options to 'benchmark' tool

* mirror around an arbitrary plane (maybe point+vector) in mged

* librt-based path tracer

* system identifier application with sysctl-style information
  database, with some back-end functionality placed into libbu.

* write scripts that parse the sf.net tracker data and generate
  automatic reports for release.

* add callback data parameters to libpkg hook functions

* add performance options for the intel compiler on Altix

* investigate performance impact of using sched_setaffinity and/or
  pthread_attr_setaffinity_np for linux threading affinity in librt.

* rtedge-style tracer that outputs tool paths (splines/segments, etc)
  for CNC/CAM style toolpath cutting descriptions (g-code files).

* rt annotation support

* support for fillets and chamfers as object/combination operations

* make the DSP primitive use less memory when data is coming from
  a binunif. allocating 160 times binunif size is a bit extravagant
  (which comes from sizeof(struct dsp_bb)).

* add dynamic geometry support. i.e. the ability to modify the parsed
  in-memory geometry tree on the fly via api calls (e.g. to add holes)

* investigate why g-iges followed by iges-g on a single box results in
  permuted vertex lists

* fix reference to a "Create Solid" submenu on pdf page 18 (page 6) of
  volume II

* obliterate verbose compilation warnings

* add support for subgeometry support to the geometry syndicator

* add xml, nff, bzw, pov, blend geometry import and export support

* add support for filesystem-based geometry collections

* add support for levels of detail

* modify the raytracers to use common fb and file output code

* add missing manual pages (jra generated list on 04.2007):
	a-d archer asc2g asc2pix binfo bot-bldxf bot-raw bottest brep_cube brep_simple brickwall btclsh burst bw-a bw-d bwish c-d chan_add clutter contours d-a damdf dauto dauto2 d-bw dconv ddisp d-f dfft d-i dmod double-asc dpeak dsel dsp_add dstat d-u dwin euclid_format euclid_unformat fbgammamod f-d fence fhor f-i files-tape g-adrt g-euclid1 g-jack globe g-off i-a i-d i-f ihist imod ipuscan ipustat istat jack-g kurt lowp molecule msrandom mst nmgmodel nmg-sgp off-g pipe pipetest pix2g pix3filter pixcount pixelswap pixembed pixfields pixfieldsep pixflip-fb pix-ipu pixpaste pix-ppm pix-spm pix-yuv plstat png-ipu pyramid rawbot remapid rlesortmap rletovcr room rtcell rtfrac rtrad rtsil rt_simple rtsrv rtwizard script-tab sgi-pix sketch solshoot sphflake spltest spm-fb ssampview syn tea tea_nmg testfree texturescale torii ttcp tube txyz-pl u-a u-bw u-d u-f umod ustat vcrtorle vegitation wall wdb_example xbmtorle xyz-pl yuv-pix

ODDITIES
--------

* the scale structure in bn_cmd_noise_slice (bn_tcl.c) was never
  initialized. it looks like somebody has planned to extend the
  function but never carried out


THESE BREAK PROTOCOL OR ARE BACKWARDS-INCOMPATIBLE
--------------------------------------------------

* support for features either as primitives or operations or both
  e.g. chamfer, fillet, round, etc

* fix the database I/O writing to properly support the addition of new
  primitive types.  this includes modifying the major/minor code or
  combinations/regions and binary objects

* add database support for constraints, expressions, parametric
  values, construction history, and timestamping.

* see doc/deprecation.txt for items that have been marked as
  deprecated or are available for deprecation.

* make struct rt_functab's ft_label bigger and/or dynamic (e.g. vls)


DOCUMENTATION
-------------

* BRL-CAD Overview Diagram
	Completed, but not integrated

* BRL-CAD Industry Diagram
	Completed, but not integrated

* BRL-CAD Commands Quick Reference
	Partial

* MGED Quick Reference
	Completed, but not integrated

* MGED Interface Reference
	Keybindings, GUI elements, scripting

* Introduction to BRL-CAD Tutorial
	mged, rt, pix-png, rtcheck, rtarea, rtweight, g_qa, fbserv, nirt

* DoD V/L M&S Industry Diagram
	Similar to existing Industry Diagram

* Commercial CAD Comparison Diagram

* Solid Geometry Representation Comparisons

* BRL-CAD Primitives

* BRL-CAD Ray Tracing Shaders

* BRL-CAD Open Source Effort
	Why, History, How

* BRL-CAD Manifesto
	Vision & Scope

* Procedural Geometry in BRL-CAD

* Implementing a BRL-CAD Primitive

* Geometry Conversion with BRL-CAD


---
See the project task tracker for more to do items and future planning
efforts.  http://sf.net/pm/?group_id=105292

TODO items should be formatted to column 70 (M-q in emacs), no tabs.
blob
data 128530
dnl                    C O N F I G U R E . A C
dnl BRL-CAD
dnl
dnl Copyright (c) 2004-2008 United States Government as represented by
dnl the U.S. Army Research Laboratory.
dnl
dnl Redistribution and use in source and binary forms, with or without
dnl modification, are permitted provided that the following conditions
dnl are met:
dnl
dnl 1. Redistributions of source code must retain the above copyright
dnl notice, this list of conditions and the following disclaimer.
dnl
dnl 2. Redistributions in binary form must reproduce the above
dnl copyright notice, this list of conditions and the following
dnl disclaimer in the documentation and/or other materials provided
dnl with the distribution.
dnl
dnl 3. The name of the author may not be used to endorse or promote
dnl products derived from this software without specific prior written
dnl permission.
dnl
dnl THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
dnl OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
dnl WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
dnl ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
dnl DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
dnl DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
dnl GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
dnl INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
dnl WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
dnl NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
dnl SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
dnl
dnl NOTE: BRL-CAD as a collective work is distributed under the LGPL.
dnl       BRL-CAD's build system is under the BSD license.
dnl       See the COPYING file for more details.
dnl
dnl $Id$
dnl
dnl ******************************************************************
dnl ***                  BRL-CAD's configure.ac                    ***
dnl ******************************************************************
dnl
dnl Herein lies the venerable GNU Build System configure template for
dnl BRL-CAD.  As best is reasonably possible, proper ordering and
dnl separation of tests and settings should be maintained per the
dnl recommended standard layout.  The tests should be added to the
dnl rather clearly labeled sections below so that they are as
dnl follows:
dnl
dnl     0) information on the package
dnl     1) check command-line arguments
dnl     2) check programs
dnl     3) check libraries
dnl     4) check headers
dnl     5) check types/structures
dnl     6) check compiler characteristics
dnl     7) check functions
dnl     8) check system services
dnl     9) output a summary
dnl
dnl Any useful build settings should be added to the output summary
dnl at the end.  Although it may be possible to check for certain
dnl features near the top in the command-line arguments section, any
dnl related tests should be delayed and placed into the appropriate
dnl check section.
dnl
dnl You should use enable/disable arguments for build settings and
dnl optional compilation components that are part of this package.
dnl You specify with/without arguments for components that are not a
dnl part of this package.
dnl
dnl Features of the GNU Autotools that would require an increase in
dnl the minimum version requirement are highly discouraged.  Likewise
dnl discouraged is rolling back support for versions released prior
dnl to the AC_PREREQ version shown below unless extensive testing has
dnl been performed.
dnl
dnl Strive to tame the chaos that is so easily achieved.
dnl

dnl minimum version of autoconf required.  should coincide with
dnl setting in autogen.sh script.
AC_PREREQ(2.52)

dnl See HACKING for details on how to properly update the version
define([MAJOR_VERSION], [patsubst(esyscmd([cat include/conf/MAJOR]), [
])])
define([MINOR_VERSION], [patsubst(esyscmd([cat include/conf/MINOR]), [
])])
define([PATCH_VERSION], [patsubst(esyscmd([cat include/conf/PATCH]), [
])])
define([CAD_VERSION], [patsubst([MAJOR_VERSION.MINOR_VERSION.PATCH_VERSION], [
])])

AC_INIT(BRL-CAD, [CAD_VERSION], [http://brlcad.org], brlcad)
AC_REVISION($Revision$)

AC_CONFIG_AUX_DIR(misc)

# keep track of cmd-line options for later
BC_ARG0="$0"
AC_SUBST(BC_ARG0)
BC_ARGS="$*"
AC_SUBST(BC_ARGS)

dnl just in case
PACKAGE_NAME="BRL-CAD"
AC_SUBST(PACKAGE_NAME)

BRLCAD_VERSION=CAD_VERSION
AC_SUBST(BRLCAD_VERSION)

# force locale setting to C so things like date output as expected
LC_ALL=C

CONFIG_DAY=`date +%d`
CONFIG_MONTH=`date +%m`
CONFIG_YEAR=`date +%Y`
CONFIG_DATE="${CONFIG_YEAR}${CONFIG_MONTH}${CONFIG_DAY}"
CONFIG_TIME="`date '+%H %M %S'`"
CONFIG_TS="`date`"
AC_SUBST(CONFIG_DAY)
AC_SUBST(CONFIG_MONTH)
AC_SUBST(CONFIG_YEAR)
AC_SUBST(CONFIG_DATE)
AC_SUBST(CONFIG_TIME)
AC_SUBST(CONFIG_TS)


# print out the title with a pretty box computed to wrap around
title="Configuring BRL-CAD Release $BRLCAD_VERSION, Build $CONFIG_DATE"
length="`echo x${title}x | wc -c`"
separator=""
while test $length -gt 1 ; do
separator="${separator}*"
length="`expr $length - 1`"
done

BC_BOLD
AC_MSG_RESULT([***${separator}***])
AC_MSG_RESULT([*** ${title} ***])
AC_MSG_RESULT([***${separator}***])
BC_UNBOLD

# necessary for proper file creation on nfs volumes
umask 022


# override the default autoconf cflags if user has not modified them
if test "x$CFLAGS" = "x" ; then
	# an unset CFLAGS var is set to "-O2 -g" during AC_PROG_CC, so
	# set it to something benign instead like whitespace
	CFLAGS=" "
fi
if test "x$CXXFLAGS" = "x" ; then
	# an unset CXXFLAGS var is set to "-O2 -g" during AC_PROG_CXX, so
	# set it to something benign instead like whitespace
	CXXFLAGS=" "
fi

# override the default (empty) yflags (yacc) if user has not modified them
if test "x$YFLAGS" = "x" ; then
	YFLAGS="-d"
fi
AC_SUBST(YFLAGS)

# cannot override LD directly, so warn about that (configure sets it)
if test "x$LD" != "x" ; then
	AC_MSG_WARN([LD cannot be set directly yet it seems to be set ($LD)])
	sleep 1
fi

# classify this machine
AC_CANONICAL_HOST
AC_CANONICAL_TARGET

# am_init_automake performs a ac_prog_install check so need to handle
# problematic /usr/brl/bin/install on irix
if test "x$build_vendor" = "xsgi" ; then
   PATH="`echo $PATH | sed 's/\/brl\/bin/bin/g'`"
fi

# sanity check, make sure we have sources where we expect them
AC_CONFIG_SRCDIR([src/librt/bool.c])

# where are we coming from and where are we going to.
# prefix is set to NONE until AC_OUTPUT unless --prefix is used
AC_PREFIX_DEFAULT([/usr/brlcad])

# set up the BRLCAD_ROOT installation path
AC_MSG_CHECKING([where BRL-CAD is to be installed])
bc_prefix="$prefix"
eval "bc_prefix=\"$bc_prefix\""
eval "bc_prefix=\"$bc_prefix\""
if test "x$bc_prefix" = "xNONE" ; then
    bc_prefix="$ac_default_prefix"
    # should be /usr/brlcad, but just in case
    eval "bc_prefix=\"$bc_prefix\""
    eval "bc_prefix=\"$bc_prefix\""
fi
AC_DEFINE_UNQUOTED([BRLCAD_ROOT], "$bc_prefix", "Location BRL-CAD will install to")
AC_MSG_RESULT($bc_prefix)
if test ! "x$BRLCAD_ROOT" = "x" ; then
	AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	AC_MSG_WARN([BRLCAD_ROOT should only be used to override an install directory at runtime])
	AC_MSG_WARN([BRLCAD_ROOT is presently set to "${BRLCAD_ROOT}"])
	AC_MSG_NOTICE([It is highly recommended that BRLCAD_ROOT be unset and not used])
	if test "x$BRLCAD_ROOT" = "x$bc_prefix" ; then
		AC_MSG_WARN([BRLCAD_ROOT is not necessary and may cause unexpected behavior])
		AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
	else
		AC_MSG_ERROR([*** Environment variable BRLCAD_ROOT conflicts with --prefix ***])
	fi
	sleep 1
else
	# compensate for autoconf inconsistencies
	BRLCAD_ROOT="$bc_prefix"
fi
AC_SUBST(BRLCAD_ROOT)

# make sure the user doesn't try to set /usr as the prefix
if test "x$BRLCAD_ROOT" = "x/usr" ; then
    if test "x$BRLCAD_ROOT_OVERRIDE" = "x" ; then
	AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	AC_MSG_WARN([It is STRONGLY recommended that you DO NOT install BRL-CAD into /usr])
	AC_MSG_WARN([as BRL-CAD provides several libraries that may conflict with other])
	AC_MSG_WARN([libraries (e.g. librt, libbu, libbn) on certain system configurations.])
	AC_MSG_WARN([])
	AC_MSG_WARN([Since our libraries predate all those that we're known to conflict with])
	AC_MSG_WARN([and are at the very core of our geometry services and project heritage,])
	AC_MSG_WARN([we have no plans to change the names of our libraries at this time.])
	AC_MSG_WARN([])
	AC_MSG_WARN([If you choose to continue installing into /usr, you do so entirely at])
	AC_MSG_WARN([your own risk.  You have been warned.])
	AC_MSG_NOTICE([])
	AC_MSG_NOTICE([Consider using a different --prefix value.])
	while true ; do
	    AC_MSG_NOTICE([])
	    AC_MSG_NOTICE([Would you like to continue with /usr as the install prefix? [[yes/no]]])
	    read bc_answer
	    case "x$bc_answer" in
		x*[[yY]][[eE]][[sS]]*)
		    bc_answer=yes
		    break ;;
		x*[[nN]][[oO]]*)
		    bc_answer=no
		    break ;;
		x*)
		    AC_MSG_NOTICE([Please answer 'yes' or 'no'])
		    ;;
	    esac
	done
	if test "x$bc_answer" = "xno" ; then
	    AC_MSG_ERROR([*** Aborting due to --prefix=/usr ***])
	fi
    fi
fi

# set up the BRLCAD_DATA install directory
#   e.g. /usr/local/share/brlcad/7.4.0
AC_MSG_CHECKING([where BRL-CAD resources are to be installed])
bc_data_dir="${datadir}"
if test "x$bc_data_dir" = "xNONE/share" ; then
	bc_data_dir="${bc_prefix}/share/brlcad/${BRLCAD_VERSION}"
elif test "x$bc_data_dir" = "x\${prefix}/share" ; then
	bc_data_dir="${bc_prefix}/share/brlcad/${BRLCAD_VERSION}"
fi
eval "bc_data_dir=\"$bc_data_dir\""
eval "bc_data_dir=\"$bc_data_dir\""
if test "x$bc_data_dir" = "xNONE/share" ; then
	bc_data_dir="${bc_prefix}/share/brlcad/${BRLCAD_VERSION}"
fi
AC_DEFINE_UNQUOTED([BRLCAD_DATA], "$bc_data_dir", "Location BRL-CAD resources will install to")
AC_MSG_RESULT($bc_data_dir)
if test ! "x$BRLCAD_DATA" = "x" ; then
	AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	AC_MSG_WARN([BRLCAD_DATA should only be used to override an install directory at runtime])
	AC_MSG_WARN([BRLCAD_DATA is presently set to "${BRLCAD_DATA}"])
	AC_MSG_NOTICE([It is highly recommended that BRLCAD_DATA be unset and not used])
	if test "x$BRLCAD_DATA" = "x$bc_data_dir" ; then
		AC_MSG_WARN([BRLCAD_DATA is not necessary and may cause unexpected behavior])
		AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
	else
		AC_MSG_ERROR([*** Environment variable BRLCAD_DATA conflicts with --prefix or --datadir ***])
	fi
	sleep 1
else
	# compensate for autoconf inconsistencies
	BRLCAD_DATA="$bc_data_dir"
fi
AC_SUBST(BRLCAD_DATA)

# if this is not a checkout, disable dependency tracking for a faster
# build. it's not likely that the user is doing development from a
# source release. at least they really should not given the extra
# steps that are necessary for making a proper useful diff.
AC_MSG_CHECKING([whether dependency tracking should be enabled])
if test -d $srcdir/CVS -o -d $srcdir/.svn ; then
	if test "x$enable_maintainer_mode" = "x" ; then
		enable_maintainer_mode="yes"
	fi
	if test "x$enable_dependency_tracking" = "x" ; then
		enable_dependency_tracking="yes"
	fi
	AC_MSG_RESULT([yes])
else
	if test "x$enable_maintainer_mode" = "x" ; then
		enable_maintainer_mode="no"
	fi
	if test "x$enable_dependency_tracking" = "x" ; then
		enable_dependency_tracking="no"
	fi
	AC_MSG_RESULT([no])
fi

# init the venerable automake only _once_ or incur the wrath of
# several automake bugs (like "aclocal-" and install detection)
AM_INIT_AUTOMAKE([1.6 dist-zip dist-bzip2])

# disables the build system dependency tracking by default for the
# automake and autoconf template files.
AM_MAINTAINER_MODE

# write out all of our definitions to this header
AM_CONFIG_HEADER([include/brlcad_config.h])

# load the tcl SC_* macros
builtin(include,src/other/tcl/unix/tcl.m4)

# automatically enable and load our configure cache file if available
BC_CONFIG_CACHE([config.cache.${host_os}.${ac_hostname}])


dnl ***********************
dnl *** Check arguments ***
dnl ***********************

#
# DOCUMENT NEW ARGUMENTS AND ALIASES IN THE "INSTALL" FILE.
#

BC_CONFIGURE_STAGE([arguments], [1 of 9])

dnl *** enable options ***

# enable everything
BC_ARG_ENABLE([everything], [almost-everything], [Turn on compilation of almost everything], [auto])

# only build benchmark
BC_ARG_ENABLE([only_benchmark], [only-benchmark], [Only build the components necessary for the benchmark], [no])

# only build librtserver
BC_ARG_ENABLE([only_rts], [only-rtserver], [Only build the components necessary for the raytrace server], [no])

# run-time debugging
BC_ARG_ENABLE([build_runtime_debug], [runtime-debug], [Enable run-time debug checking], [yes])

# enable 64-bit builds
BC_ARG_ENABLE([build_64bit], [64bit-build], [Enable 64-bit compilation mode], [auto])

# force enable/disable building of libregex
BC_ARG_ENABLE([build_regex], [regex-build], [Build the included regular expression library], [auto])

# force enable/disable building of libpng
BC_ARG_ENABLE([build_png], [png-build], [Build the included Portable Network Graphics library], [auto])

# force enable/disable building of zlib
BC_ARG_ENABLE([build_zlib], [zlib-build], [Build the included zlib compression library], [auto])

# force enable/disable building of utah raster toolkit
BC_ARG_ENABLE([build_urt], [urt-build], [Build the included Utah Raster Toolkit], [auto])

# force enable/disable building of openNURBS
BC_ARG_ENABLE([build_opennurbs], [opennurbs-build], [Build the included openNURBS library], [auto])

# force enable/disable building of termlib
BC_ARG_ENABLE([build_termlib], [termlib-build], [Build the included termlib library], [auto])

# force enable/disable building of Tcl
BC_ARG_ENABLE([build_tcl], [tcl-build], [Build the included Tcl], [auto])

# force enable/disable building of Tk
BC_ARG_ENABLE([build_tk], [tk-build], [Build the included Tk], [auto])

# force enable/disable building Tk using AquaTk (Mac OS X specific)
BC_ARG_ENABLE([build_aquatk], [aquatk-build], [Use Aqua windowing system on Mac OS X], [no])

# force enable/disable building of incrTcl
BC_ARG_ENABLE([build_itcl], [itcl-build], [Build the included incrTcl], [auto])

# force enable/disable building of iwidgets
BC_ARG_ENABLE([build_iwidgets], [iwidgets-install], [Install the included iwidgets], [auto])

# force enable/disable building of blt
BC_ARG_ENABLE([build_blt], [blt-build], [Build the included BLT], [auto])

# tkimg
BC_ARG_ENABLE([build_tkimg], [tkimg-build], [Build the included tkImg], [auto])

# force enable/disable building of tnt
BC_ARG_ENABLE([build_tnt], [tnt-install], [Install the included Template Numerical Toolkit], [auto])

# jove
BC_ARG_ENABLE([build_jove], [jove-build], [Enable compilation of jove], [auto])

# endgame framework simulation module
BC_ARG_ENABLE([build_ef], [ef-build], [Enable compilation of Endgame Framework module], [no])

# unigraphics plugin
BC_ARG_ENABLE([build_ug], [unigraphics-build], [Enable compilation of Unigraphics importer], [no])

# example geometry
BC_ARG_ENABLE([install_geometry], [models-install], [Enable installation of example geometry models], [yes])

# optimized
BC_ARG_ENABLE([use_optimized], [optimized], [Enable optimized compilation], [no])

# debug
BC_ARG_ENABLE([use_debug], [debug], [Enable debug symbols], [auto])

# profiling
BC_ARG_ENABLE([use_profiling], [profiling], [Enable profiling], [no])

# parallel
BC_ARG_ENABLE([build_parallel], [parallel], [Compile for SMP architectures], [yes])

# Sun dtrace
BC_ARG_ENABLE([use_dtrace], [dtrace], [Enable dtrace support], [no])

# verbosity
BC_ARG_ENABLE([build_verbose], [verbose], [Enable verbose compilation], [auto])

# warnings
BC_ARG_ENABLE([build_warnings], [warnings], [Enable verbose compilation warnings], [no])

# build progress status
BC_ARG_ENABLE([build_progress], [progress], [Enable verbose compilation progress], [no])


dnl *** with options ***

# provides convenience argument handlers for specifying CFLAGS,
# LDFLAGS, CPPFLAGS, and LIBS using --with argument handlers.
BC_WITH_FLAG_ARGS

# use the jdk
BC_ARG_WITH([with_java], [jdk], [Specify use of or path to the Java Development Kit], [auto])

# use x11
BC_ARG_WITH([with_x11], [x11], [Specify use of or path to X11], [auto])

# use opengl
BC_ARG_WITH([with_opengl], [ogl], [Specify use of or path to OpenGL], [auto])

# use wgl
BC_ARG_WITH([with_wgl], [wgl], [Specify use of or path to WindowsGL], [auto])

# use pro/engineer
BC_ARG_WITH([with_proe], [proe], [Specify build of Pro/ENGINEER plugin or path to Pro/ENGINEER installation], [no])

###
# argument aliases
# they need to go below here in order for --help to consolidate the
# blank line that it inserts to exactly one line in the right place.
#
# DOCUMENT NEW ARGUMENTS AND ALIASES IN THE "INSTALL" FILE.
###

# aliases for enabling configuration of everything (help uses almost-everything)
BC_ARG_ALIAS([everything], [all])
BC_ARG_ALIAS([everything], [all-build])
BC_ARG_ALIAS([everything], [build-all])
BC_ARG_ALIAS([everything], [all-builds])
BC_ARG_ALIAS([everything], [everything])
BC_ARG_ALIAS([everything], [everything-build])
BC_ARG_ALIAS([everything], [build-everything])

# aliases for building only the benchmark (help uses only-benchmark)
BC_ARG_ALIAS([only_benchmark], [only-bench])
BC_ARG_ALIAS([only_benchmark], [only-benchmarks])
BC_ARG_ALIAS([only_benchmark], [bench-only])
BC_ARG_ALIAS([only_benchmark], [benchmark-only])
BC_ARG_ALIAS([only_benchmark], [benchmarks-only])

# aliases for building only the raytrace server (help uses only-rtserver)
BC_ARG_ALIAS([only_rts], [only-rts])
BC_ARG_ALIAS([only_rts], [only-librtserver])
BC_ARG_ALIAS([only_rts], [rts-only])
BC_ARG_ALIAS([only_rts], [rtserver-only])
BC_ARG_ALIAS([only_rts], [librtserver-only])

# run-time debugging (help uses runtime-debug)
BC_ARG_ALIAS([build_runtime_debug], [run-time-debug])
BC_ARG_ALIAS([build_runtime_debug], [runtime-debugging])
BC_ARG_ALIAS([build_runtime_debug], [run-time-debugging])

# 64-bit compilation (help uses 64bit-build)
BC_ARG_ALIAS([build_64bit], [64bit])
BC_ARG_ALIAS([build_64bit], [64])
BC_ARG_ALIAS([build_64bit], [64-build])
BC_ARG_ALIAS([build_64bit], [64-bit])
BC_ARG_ALIAS([build_64bit], [64-bit-build])

# force building libregex (help uses regex-build)
BC_ARG_ALIAS([build_regex], [regex])
BC_ARG_ALIAS([build_regex], [libregex])
BC_ARG_ALIAS([build_regex], [libregex-build])

# aliases to force building libpng (help uses png-build)
BC_ARG_ALIAS([build_png], [png])
BC_ARG_ALIAS([build_png], [libpng])
BC_ARG_ALIAS([build_png], [libpng-build])

# aliases to force building zlib (help uses zlib-build)
BC_ARG_ALIAS([build_zlib], [zlib])
BC_ARG_ALIAS([build_zlib], [libz])
BC_ARG_ALIAS([build_zlib], [libz-build])

# aliases to force building urt (help uses urt-build)
BC_ARG_ALIAS([build_urt], [urt])
BC_ARG_ALIAS([build_urt], [urtoolkit])
BC_ARG_ALIAS([build_urt], [urtoolkit-build])
BC_ARG_ALIAS([build_urt], [utahrle])
BC_ARG_ALIAS([build_urt], [utahrle-build])
BC_ARG_ALIAS([build_urt], [libutahrle])
BC_ARG_ALIAS([build_urt], [libutahrle-build])
BC_ARG_ALIAS([build_urt], [utah-raster-toolkit])
BC_ARG_ALIAS([build_urt], [utah-raster-toolkit-build])

# aliases to force building openNURBS (help uses opennurbs-build)
BC_ARG_ALIAS([build_opennurbs], [opennurbs])
BC_ARG_ALIAS([build_opennurbs], [libopennurbs])
BC_ARG_ALIAS([build_opennurbs], [libopennurbs-build])
BC_ARG_ALIAS([build_opennurbs], [open-nurbs])
BC_ARG_ALIAS([build_opennurbs], [open-nurbs-build])

# aliases to force building tcl (help uses tcl-build)
BC_ARG_ALIAS([build_tcl], [tcl])
BC_ARG_ALIAS([build_tcl], [libtcl])
BC_ARG_ALIAS([build_tcl], [libtcl-build])

# aliases to force building tk (help uses tk-build)
BC_ARG_ALIAS([build_tk], [tk])
BC_ARG_ALIAS([build_tk], [libtk])
BC_ARG_ALIAS([build_tk], [libtk-build])

# aliases to force building tkaqua (help uses aquatk-build)
BC_ARG_ALIAS([build_aquatk], [aquatk])
BC_ARG_ALIAS([build_aquatk], [aqua-tk])
BC_ARG_ALIAS([build_aquatk], [aqua-tk-build])
BC_ARG_ALIAS([build_aquatk], [tkaqua])
BC_ARG_ALIAS([build_aquatk], [tkaqua-build])
BC_ARG_ALIAS([build_aquatk], [tk-aqua-build])

# aliases to force building itcl (help uses itcl-build)
BC_ARG_ALIAS([build_itcl], [itcl])
BC_ARG_ALIAS([build_itcl], [itk])
BC_ARG_ALIAS([build_itcl], [itk-build])
BC_ARG_ALIAS([build_itcl], [libitcl])
BC_ARG_ALIAS([build_itcl], [libitcl-build])
BC_ARG_ALIAS([build_itcl], [libitk])
BC_ARG_ALIAS([build_itcl], [libitk-build])
BC_ARG_ALIAS([build_itcl], [incrtcl])
BC_ARG_ALIAS([build_itcl], [incrtcl-build])

# aliases to force building iwidgets (help uses iwidgets-install)
BC_ARG_ALIAS([build_iwidgets], [iwidgets])
BC_ARG_ALIAS([build_iwidgets], [iwidgets-build])

# aliases to force building blt (help uses blt-build)
BC_ARG_ALIAS([build_blt], [blt])
BC_ARG_ALIAS([build_blt], [libblt])
BC_ARG_ALIAS([build_blt], [libblt-build])

# aliases to force building tkimg (help uses tkimg-build)
BC_ARG_ALIAS([build_tkimg], [tkimg])
BC_ARG_ALIAS([build_tkimg], [libtkimg])
BC_ARG_ALIAS([build_tkimg], [libtkimg-build])

# aliases to force building termlib (help uses termlib-build)
BC_ARG_ALIAS([build_termlib], [termlib])
BC_ARG_ALIAS([build_termlib], [termcap])
BC_ARG_ALIAS([build_termlib], [termcap-build])
BC_ARG_ALIAS([build_termlib], [libtermlib])
BC_ARG_ALIAS([build_termlib], [libtermlib-build])
BC_ARG_ALIAS([build_termlib], [libtermcap])
BC_ARG_ALIAS([build_termlib], [libtermcap-build])

# aliases to force building tnt (help uses tnt-install)
BC_ARG_ALIAS([build_tnt], [tnt])
BC_ARG_ALIAS([build_tnt], [tnt-build])
BC_ARG_ALIAS([build_tnt], [template-numerical-toolkit])
BC_ARG_ALIAS([build_tnt], [template-numerical-toolkit-build])
BC_ARG_ALIAS([build_tnt], [template-numerical-toolkit-install])

# jove aliases (help uses jove-build)
BC_ARG_ALIAS([build_jove], [jove])

# endgame framework module aliases (help uses ef-build)
BC_ARG_ALIAS([build_ef], [ef])
BC_ARG_ALIAS([build_ef], [endgameframework])
BC_ARG_ALIAS([build_ef], [endgameframework-build])
BC_ARG_ALIAS([build_ef], [endgame-framework])
BC_ARG_ALIAS([build_ef], [endgame-framework-build])

# unigraphics (NX) importer aliases (help uses unigraphics-build)
BC_ARG_ALIAS([build_ug], [unigraphics])
BC_ARG_ALIAS([build_ug], [ug])
BC_ARG_ALIAS([build_ug], [ug-build])
BC_ARG_ALIAS([build_ug], [nx])
BC_ARG_ALIAS([build_ug], [nx-build])

# install geometry aliases (help uses models-install)
BC_ARG_ALIAS([install_geometry], [models])
BC_ARG_ALIAS([install_geometry], [models-build])
BC_ARG_ALIAS([install_geometry], [geometry])
BC_ARG_ALIAS([install_geometry], [geometry-build])
BC_ARG_ALIAS([install_geometry], [geometry-install])

# optimized aliases (help uses optimized)
BC_ARG_ALIAS([use_optimized], [opt])
BC_ARG_ALIAS([use_optimized], [optimize])
BC_ARG_ALIAS([use_optimized], [optimization])
BC_ARG_ALIAS([use_optimized], [optimizations])

# debug aliases (help uses debug)
BC_ARG_ALIAS([use_debug], [debugging])

# profiling aliases (help uses profiling)
BC_ARG_ALIAS([use_profiling], [profile])
BC_ARG_ALIAS([use_profiling], [profiled])

# parallel aliases (help uses parallel)
BC_ARG_ALIAS([build_parallel], [parallel-build])
BC_ARG_ALIAS([build_parallel], [smp])
BC_ARG_ALIAS([build_parallel], [smp-build])

# verbose output (help uses verbose)
BC_ARG_ALIAS([build_verbose], [verbosity])
BC_ARG_ALIAS([build_verbose], [output-verbose])
BC_ARG_ALIAS([build_verbose], [verbose-output])
BC_ARG_ALIAS([build_verbose], [build-verbose])
BC_ARG_ALIAS([build_verbose], [verbose-build])

# verbose warning aliases (help uses warnings)
BC_ARG_ALIAS([build_warnings], [warning])
BC_ARG_ALIAS([build_warnings], [verbose-warnings])
BC_ARG_ALIAS([build_warnings], [warnings-verbose])
BC_ARG_ALIAS([build_warnings], [build-warnings])
BC_ARG_ALIAS([build_warnings], [warnings-build])

# verbose compilation progress status (help uses progress)
BC_ARG_ALIAS([build_progress], [verbose-progress])
BC_ARG_ALIAS([build_progress], [progress-verbose])
BC_ARG_ALIAS([build_progress], [build-progress])
BC_ARG_ALIAS([build_progress], [progress-build])

# with java aliases (help uses jdk)
BC_ARG_WITH_ALIAS([with_java], [java])

# with proe aliases
BC_ARG_WITH_ALIAS([with_proe], [proe])

# with x11 aliases (help uses x11)
BC_ARG_WITH_ALIAS([with_x11], [x])

# with opengl aliases (help uses ogl)
BC_ARG_WITH_ALIAS([with_opengl], [opengl])

# with wgl aliases (help uses wgl)
BC_ARG_WITH_ALIAS([with_wgl], [windowsgl])


###
# set up path searching
###

dnl automatically scan /usr/local (e.g. BSD uses /usr/local for ports)
BC_SEARCH_DIRECTORY([/usr/local])


###
# argument sanity checks and meta-argument settings
# here go checks to warn or abort when conflicting options specified
###

# handle enabling/disabling all the packages and codes that ship with
# the package.  if something is changed from a default, leave it alone
# so that the user may specify everything and then disable specific
# ones.  specifically only test yes/no as default 'auto' is to leave
# the options alone.
set_everything=""
if test "x$bc_everything" = "xyes" ; then
	set_everything=yes
elif test "x$bc_everything" = "xno" ; then
	set_everything=no
fi
if test "x$set_everything" != "x" ; then
	if test "x$bc_build_runtime_debug_set" = "xno" ; then
		bc_build_runtime_debug="$set_everything"
	fi
	if test "x$bc_build_regex_set" = "xno" ; then
		bc_build_regex="$set_everything"
	fi
	if test "x$bc_build_png_set" = "xno" ; then
		bc_build_png="$set_everything"
	fi
	if test "x$bc_build_zlib_set" = "xno" ; then
		bc_build_zlib="$set_everything"
	fi
	if test "x$bc_build_urt_set" = "xno" ; then
		bc_build_urt="$set_everything"
	fi
	if test "x$bc_build_opennurbs_set" = "xno" ; then
		bc_build_opennurbs="$set_everything"
	fi
	if test "x$bc_build_termlib_set" = "xno" ; then
		bc_build_termlib="$set_everything"
	fi
	if test "x$bc_build_tcl_set" = "xno" ; then
		bc_build_tcl="$set_everything"
	fi
	if test "x$bc_build_tk_set" = "xno" ; then
		bc_build_tk="$set_everything"
	fi
	if test "x$bc_build_itcl_set" = "xno" ; then
		bc_build_itcl="$set_everything"
	fi
	if test "x$bc_build_iwidgets_set" = "xno" ; then
		bc_build_iwidgets="$set_everything"
	fi
	if test "x$bc_build_blt_set" = "xno" ; then
		bc_build_blt="$set_everything"
	fi
	if test "x$bc_build_tkimg_set" = "xno" ; then
		bc_build_tkimg="$set_everything"
	fi
	if test "x$bc_build_tnt_set" = "xno" ; then
		bc_build_tnt="$set_everything"
	fi
	if test "x$bc_build_jove_set" = "xno" ; then
		bc_build_jove="$set_everything"
	fi
	# Singe the Endgame Framework "simulation module" will only
	# compile if you have it installed, don't enable it even if
	# requesting everything.  fine to disable, though.
	if test "x$bc_build_ef_set" = "xno" ; then
		if test "x$set_everything" = "xno" ; then
			bc_build_ef=no
		fi
	fi
	# Since the Unigraphics importer is primarily tested on only one
	# platform and requires UGOPEN, don't enable it even if
	# requesting everything.  fine to disable, though.
	if test "x$bc_build_ug_set" = "xno" ; then
		if test "x$set_everything" = "xno" ; then
			bc_build_ug=no
		fi
	fi
fi


# make sure multiple "only" options were not given
if test "x$bc_only_benchmark" != "xno" ; then
	if test "x$bc_only_rts" != "xno" ; then
		AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
		AC_MSG_WARN([Requesting BOTH benchmark and librtserver "only"?])
		AC_MSG_WARN([Building both benchmark and librtserver])
		AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
		sleep 1
	fi
	if test "x$bc_everything" = "xyes" ; then
		AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
		AC_MSG_WARN([Requesting ONLY benchmark and EVERYTHING?])
		AC_MSG_WARN([Building everything])
		AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
		bc_only_benchmark=no
		sleep 1
	fi
fi

# the opengl interface is presently tied to the x11 interface
if test "x$bc_with_opengl" = "xyes" ; then
	if test "x$bc_with_x11" = "xno" ; then
		AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
		AC_MSG_WARN([OpenGL interface presently requires X11 support])
		AC_MSG_WARN([Presuming X11 availability for the OpenGL interface])
		AC_MSG_WARN([The X11 interface will not be built])
		AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
		sleep 1
	fi
fi

# turning on verbose means turning on progress and warning verbosity
if test "x$bc_build_verbose" = "xyes" ; then
	if test "x$bc_build_warnings_set" = "xno" ; then
		bc_build_warnings=yes
	fi
	if test "x$bc_build_progress_set" = "xno" ; then
		bc_build_progress=yes
	fi
fi

###
# argument summary printing
###

AC_MSG_CHECKING(whether to compile everything was requested)
AC_MSG_RESULT($bc_everything)

AC_MSG_CHECKING(whether to only build benchmark)
AC_MSG_RESULT($bc_only_benchmark)

AC_MSG_CHECKING(whether to only build the raytrace server)
AC_MSG_RESULT($bc_only_rts)

AC_MSG_CHECKING(whether to use run-time debug checks)
AC_MSG_RESULT($bc_build_runtime_debug)

AC_MSG_CHECKING(whether to compile in 64-bit mode)
AC_MSG_RESULT($bc_build_64bit)

AC_MSG_CHECKING(whether to build the regular expression library)
AC_MSG_RESULT($bc_build_regex)

AC_MSG_CHECKING(whether to build the PNG library)
AC_MSG_RESULT($bc_build_png)

AC_MSG_CHECKING(whether to build the zlib compression library)
AC_MSG_RESULT($bc_build_zlib)

AC_MSG_CHECKING(whether to build the Utah Raster Toolkit)
AC_MSG_RESULT($bc_build_urt)

AC_MSG_CHECKING(whether to build the openNURBS library)
AC_MSG_RESULT($bc_build_opennurbs)

AC_MSG_CHECKING(whether to build the Tcl library)
AC_MSG_RESULT($bc_build_tcl)

AC_MSG_CHECKING(whether to build the Tk library)
AC_MSG_RESULT($bc_build_tk)

AC_MSG_CHECKING(whether to use AquaTk)
AC_MSG_RESULT($bc_build_aquatk)

AC_MSG_CHECKING(whether to build the incrTcl library)
AC_MSG_RESULT($bc_build_itcl)

AC_MSG_CHECKING(whether to install the iwidgets library)
AC_MSG_RESULT($bc_build_iwidgets)

AC_MSG_CHECKING(whether to build the BLT library)
AC_MSG_RESULT($bc_build_blt)

AC_MSG_CHECKING(whether to build the tkImg library)
AC_MSG_RESULT($bc_build_tkimg)

AC_MSG_CHECKING(whether to build the termlib library)
AC_MSG_RESULT($bc_build_termlib)

AC_MSG_CHECKING(whether to build the Template Numerical Toolkit)
AC_MSG_RESULT($bc_build_tnt)

AC_MSG_CHECKING(whether to compile jove or not)
AC_MSG_RESULT($bc_build_jove)

AC_MSG_CHECKING(whether to compile the Endgame Framework module)
AC_MSG_RESULT($bc_build_ef)

AC_MSG_CHECKING(whether to compile the Unigraphics importer)
AC_MSG_RESULT($bc_build_ug)

AC_MSG_CHECKING(whether to install example geometry databases)
AC_MSG_RESULT($bc_install_geometry)

AC_MSG_CHECKING(whether to enable optimized compilation)
AC_MSG_RESULT($bc_use_optimized)

AC_MSG_CHECKING(whether to disable debug mode compilation)
AC_MSG_RESULT($bc_use_debug)

AC_MSG_CHECKING(whether to enable profile mode compilation)
AC_MSG_RESULT($bc_use_profiling)

AC_MSG_CHECKING(whether to enable support for SMP architectures)
AC_MSG_RESULT($bc_build_parallel)

AC_MSG_CHECKING(whether to enable verbose output)
AC_MSG_RESULT($bc_build_verbose)

AC_MSG_CHECKING(whether to enable verbose compilation warnings)
AC_MSG_RESULT($bc_build_warnings)

AC_MSG_CHECKING(whether to enable verbose compilation progress)
AC_MSG_RESULT($bc_build_progress)

AC_MSG_CHECKING(whether to compile with the Java Development Kit)
AC_MSG_RESULT($bc_with_java)

AC_MSG_CHECKING(whether to compile the X11 interfaces)
AC_MSG_RESULT($bc_with_x11)

AC_MSG_CHECKING(whether to compile the OpenGL interfaces)
AC_MSG_RESULT($bc_with_opengl)

AC_MSG_CHECKING(whether to compile the WindowsGL interfaces)
AC_MSG_RESULT($bc_with_wgl)

AC_MSG_CHECKING(whether to compile the Pro/ENGINEER plugin)
AC_MSG_RESULT($bc_with_proe)


dnl **************************
dnl *** Check for programs ***
dnl **************************

BC_CONFIGURE_STAGE([programs], [2 of 9])

AC_LANG(C)

dnl added in autoconf 2.54 to define _GNU_SOURCE
dnl AC_GNU_SOURCE

AC_AIX
AC_MINIX

AC_PROG_CC
AM_PROG_CC_C_O

AC_PROG_CXX

AC_PROG_CPP
AC_REQUIRE_CPP

AC_PROG_AWK
AC_PROG_INSTALL
AC_PROG_LN_S
AC_PROG_MAKE_SET
AM_PROG_MKDIR_P

# automake 'requires' AM_PROG_LEX, not AC_PROG_LEX
AM_PROG_LEX
AC_PROG_YACC

# libtool's configuration check has a bug that causes a /lib/cpp
# sanity check failure if a C++ compiler is not installed.  This makes
# the sanity test pass regardless of whether there is a c++ compiler.
if test "x$CXXCPP" = "x" ; then
	if test "x$CPP" = "x" ; then
		CXXCPP="cpp"
	else
		CXXCPP="$CPP"
	fi
fi

dnl disable unnecessary libtool test for fortran
define([AC_LIBTOOL_LANG_F77_CONFIG], [:])dnl

# libtool shouldn't be generated until after LD is set
# XXX went poof in libtool 1.9 -- AC_PROG_LIBTOOL
# LT_INIT
AC_PROG_LIBTOOL
AC_SUBST(LIBTOOL_DEPS)

dnl verbose compilation progress
if test "x$bc_build_progress" != "xyes" ; then
	LIBTOOLFLAGS=--silent
	AC_SUBST(LIBTOOLFLAGS)
	# LIBTOOLFLAGS isn't often not enough;
	# tack --silent onto the LIBTOOL command.
	if test "x$LIBTOOL" != "x" ; then
		LIBTOOL="$LIBTOOL --silent"
	fi
fi

# AN_MAKEVAR([AR], [BC_PROG_AR])
# AN_PROGRAM([ar], [BC_PROG_AR])
# AC_DEFUN([BC_PROG_AR], [AC_CHECK_TOOL(AR, ar, :)])
# BC_PROG_AR

# XXX tests for ranlib may be required.  "ar ts" was used in cake for
# sgi and aix so more compensation may be required still.

dnl Libtool may need AR so try to find it
AC_PATH_PROG(AR, ar, [], $PATH:/usr/bin:/usr/local/bin:/usr/ccs/bin)
AC_SUBST(AR)

dnl check for basic shell facilities
AC_PATH_PROG(SH, sh)
AC_PATH_PROG(MV, mv)
AC_PATH_PROG(CP, cp)
AC_PATH_PROG(RM, rm)

if test "$bc_with_dtrace" == "yes" ; then
	AC_PATH_PROG(DTRACE, dtrace, bc_with_dtrace=no, [$PATH:/usr/sbin])
fi

dnl figure out which compiler is seems like we are using
dnl detected values include: gcc, mipspro, sunpro
dnl none of the tests should be compiler-specific, but it's good to
dnl know in the log which it seems we are using
compiler=unknown

dnl Determine whether we are using GCC
if test "x$GCC" = "xyes" ; then
	compiler=gnu
fi

dnl Determine whether we are using the MIPSpro compiler on SGI systems
if test "x$build_vendor" = "xsgi" ; then
	AC_MSG_CHECKING([whether we are using the MIPSpro compiler])
	using_mipspro=no
	AC_LINK_IFELSE([#if defined(sgi) && defined(_COMPILER_VERSION) && !defined(__GNUC__)
If we get here, we are using the MIPSPro compiler (and the link should fail).
#endif
int main() { return 0; }
	], [using_mipspro=no], [using_mipspro=yes])
	AC_MSG_RESULT($using_mipspro)
	if test "x$using_mipspro" = "xyes" ; then
		compiler=sgi
	fi
fi

dnl Determine whether we are using the SUNWspro Sun Workshop compiler
if test "x$build_vendor" = "xsun" ; then
	AC_MSG_CHECKING([whether we are using the SUNWspro compiler])
	using_sunpro=no
	AC_LINK_IFELSE([#if defined(sun) && defined(__SUNPRO_C) && !defined(__GNUC__)
If we get here, we are using the SUNWspro compiler (and the link should fail).
#endif
int main() { return 0; }
	], [using_sunpro=no], [using_sunpro=yes])
	AC_MSG_RESULT($using_sunpro)
	if test "x$using_sunpro" = "xyes" ; then
		AR="CC -xar"
		LD="CC -G"
		export AR LD
		compiler=sun
	fi
fi

AC_DEFINE(EXTERN_STDOUT,,[Stdout is extern])

AC_FUNC_ALLOCA

dnl if building jove wasn't specifically requested and wasn't
dnl disabled, see if there is either emacs or jove available.
dnl i.e. auto for jove is dependant on what is installed
BCEDITOR=""
if test "x$bc_build_jove" = "xauto" ; then
	AC_PATH_PROG(BCEDITOR, emacs, , $PATH)
	if test "x$BCEDITOR" = "x" ; then
		AC_PATH_PROG(BCEDITOR, jove, , $PATH)
	fi
fi


dnl ***************************
dnl *** Check for libraries ***
dnl ***************************

BC_CONFIGURE_STAGE([libraries], [3 of 9])

dnl check if there is a threading library that links, the order of
dnl these checks is consistent with libbu's bu_parallel()
dnl implementation preference.  this is usually in order of highest
dnl performing threading interface.
thread_link_works=no
LIBTHREAD=""
dnl try sgi sproc first
AC_CHECK_LIB(c, sproc, thread_link_works=yes ; LIBTHREAD="-lc",
    dnl try solaris threading
    [AC_CHECK_LIB(thread, thr_create, thread_link_works=yes ; LIBTHREAD="-lthread",
	dnl pthreading is a good default if none of the others are available
	dnl XXX need to test HPUX -- may require -lcma with pthreads
	[AC_CHECK_LIB(pthread, pthread_create, thread_link_works=yes ; LIBTHREAD="-lpthread",
	    dnl check if the BSD c_r threading library link works
	    [AC_CHECK_LIB(c_r, pthread_create, thread_link_works=yes ; LIBTHREAD="-pthread")]
	)]
    )]
)

dnl check whether we ended up with functioning posix threading.
AC_MSG_CHECKING([whether we are using POSIX threading])
posix_threading=no
PRELIBS="$LIBS"
LIBS="$LIBS $LIBTHREAD"
AC_TRY_LINK([#include <pthread.h>], [
    pthread_t th;
    pthread_join(th, 0);
    pthread_attr_init(0);
    pthread_cleanup_push(0,0);
    pthread_create(0,0,0,0);
    pthread_cleanup_pop(0);
], [posix_threading=yes])
LIBS="$PRELIBS"
AC_MSG_RESULT($posix_threading)

dnl check whether the CoreFoundation framework is available (used when
dnl linking against static tcl)
AC_MSG_CHECKING([whether -framework CoreFoundation is available])
framework_cf=no
FRAMEWORK_COREFOUNDATION=""
PRELIBS="$LIBS"
LIBS="$LIBS -Xlinker -framework -Xlinker CoreFoundation"
AC_TRY_LINK([#include <CoreFoundation/CoreFoundation.h>], [
CFBundleRef bref = CFBundleGetMainBundle();
], [framework_cf=yes ; FRAMEWORK_COREFOUNDATION="-Xlinker -framework -Xlinker CoreFoundation"])
LIBS="$PRELIBS"
AC_MSG_RESULT($framework_cf)
AC_SUBST(FRAMEWORK_COREFOUNDATION)

dnl check whether the Carbon framework is available (used for X11 focus)
AC_MSG_CHECKING([whether -framework Carbon is available])
framework_carbon=no
FRAMEWORK_CARBON=""
PRELIBS="$LIBS"
LIBS="$LIBS -Xlinker -framework -Xlinker Carbon"
AC_TRY_LINK([#include <Carbon/Carbon.h>], [
OSStatus status;
ProcessSerialNumber psn = {kNoProcess, kNoProcess};
CFStringRef processName = NULL;
GetCurrentProcess(&psn);
CopyProcessName(&psn, &processName);
if (processName != NULL) {
   CFShow(processName);
}
], [framework_carbon=yes ; FRAMEWORK_CARBON="-Xlinker -framework -Xlinker Carbon"])
LIBS="$PRELIBS"
AC_MSG_RESULT($framework_carbon)
AC_SUBST(FRAMEWORK_CARBON)

dnl check whether the JavaVM framework is available (used for librtserver)
AC_MSG_CHECKING([whether -framework JavaVM is available])
framework_javavm=no
FRAMEWORK_JAVAVM=""
PRELIBS="$LIBS"
LIBS="$LIBS -framework JavaVM"
AC_TRY_LINK([#include <JavaVM/jni.h>], [
JavaVM *jvm;
JNIEnv *env;
JavaVMInitArgs args;
jint i = JNI_GetDefaultJavaVMInitArgs(&args);
jboolean j = JNI_CreateJavaVM(&jvm, (void**)&env, &args);
if (j && jvm) {
  (*jvm)->DestroyJavaVM(jvm);
}
], [framework_javavm=yes ; FRAMEWORK_JAVAVM="-framework JavaVM"])
LIBS="$PRELIBS"
AC_MSG_RESULT($framework_javavm)
AC_SUBST(FRAMEWORK_JAVAVM)


dnl check for java
JAVA_CFLAGS="$FRAMEWORK_JAVAVM"
JAVA_LDFLAGS="-shrext .jnilib $FRAMEWORK_JAVAVM"
if test "x$bc_with_java" = "xyes" ; then
    if test "x$bc_with_java_val" = "xyes" ; then
	bc_with_java_val="/usr"
    fi
    if test "x$bc_with_java_val" != "x" ; then
	JAVA_CFLAGS="-I$bc_with_java_val/include -I$bc_with_java_val/include/`uname | tr [A-Z] [a-z]`"
	JAVA_LDFLAGS="-shrext .jnilib -L$bc_with_java_val/lib64 -L$bc_with_java_val/lib"
    fi
fi
AC_SUBST(JAVA_CFLAGS)
AC_SUBST(JAVA_LDFLAGS)


dnl find a curses or other terminal library
LIBTERMLIB=""
AC_CHECK_LIB(termlib, tputs, LIBTERMLIB="-ltermlib",
    [AC_CHECK_LIB(ncurses, tputs, LIBTERMLIB="-lncurses",
	[AC_CHECK_LIB(curses, tputs, LIBTERMLIB="-lcurses",
	    [AC_CHECK_LIB(termcap, tputs, LIBTERMLIB="-ltermcap",
		[AC_CHECK_LIB(terminfo, tputs, LIBTERMLIB="-lterminfo",
		    [AC_CHECK_LIB(tinfo, tputs, LIBTERMLIB="-ltinfo",
			[AC_CHECK_LIB(ocurses, tputs, LIBTERMLIB="-locurses")]
		    )]
		)]
	    )]
	)]
    )]
)

dnl *** X11 ***
if test "x$bc_with_x11" != "xno" ; then

    if test "x$bc_with_x11_val" != "x" ; then
        if test "x$bc_with_x11_val" != "xyes" ; then
	    if test "x$x_includes" = "xNONE"; then
		x_includes="$bc_with_x11_val/include"
		ac_x_includes="$x_includes"
	    fi
	    if test "x$x_libraries" = "xNONE"; then
		x_libraries="$bc_with_x11_val/lib"
		ac_x_libraries="$x_libraries"
	    fi
	fi
    fi

    dnl find X11 libraries.  sets X_CFLAGS, X_LIBS, and X_EXTRA_LIBS
    AC_PATH_XTRA
    if test "x$have_x" = "xyes" ; then
	AC_DEFINE(HAVE_X11_XLIB_H, 1, Define to 1 if you have the <X11/Xlib.h> header file.)
    fi

    dnl add X11 libraries that link to X_LIBS
    LIBX11=""
    LIBXEXT=""
    LIBXI=""

    PRELIBS="$LIBS"
    PRECPPFLAGS="$CPPFLAGS"

    CPPFLAGS="$CPPFLAGS $X_CFLAGS"

    LIBS="$LIBS $X_LIBS"
    AC_CHECK_LIB(X11, XCreateWindow, LIBX11="-lX11")

    LIBS="$LIBS $LIBX11"
    AC_CHECK_LIB(Xext, XShapeCombineMask, LIBXEXT="-lXext")

    LIBS="$LIBS $LIBXEXT"
    AC_CHECK_LIB(Xi, XGetExtensionVersion, LIBXI="-lXi")
    X_LIBS="$LIBS $LIBXI"

    # common for systems to not have Xi X11 input library .. warn
    # verbosely about that being a problem since the build will
    # probably fail in src/bwish with undefined references to
    # XFreeDeviceList, XOpenDevice, XSelectExtensionEvent, and
    # XListInputDevices.
    if test "x$LIBXI" = "x" ; then
	AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	AC_MSG_WARN([X11 support is enabled but the Xi library was not found.])
	AC_MSG_WARN([This will likely result in a build failure.])
	AC_MSG_WARN([See config.log for details why (look for this comment)])
	AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
	sleep 1
    fi

    CPPFLAGS="$PRECPPFLAGS"
    LIBS="$PRELIBS"
fi

dnl check if a math library links
m_link_works=no
LIBM=""
AC_CHECK_LIB(m, cos, m_link_works=yes ; LIBM="-lm")

dnl detect a useable system regular expression library
regex_link_works=no
LIBREGEX=""
AC_CHECK_LIB(c, regcomp, regex_link_works=yes ; LIBREGEX="-lc",
    [AC_CHECK_LIB(regex, regcomp, regex_link_works=yes ; LIBREGEX="-lregex",
	[AC_CHECK_LIB(compat, regcomp, regex_link_works=yes ; LIBREGEX="-lcompat")]
    )]
)

dnl check if zlib library links
z_link_works=no
LIBZLIB=""
if test "x$bc_build_zlib" != "xyes" ; then
    AC_CHECK_LIB(z, deflate, z_link_works=yes ; LIBZLIB="-lz")
fi

dnl check if a png library links
png_link_works=no
LIBPNG=""
PRELIBS="$LIBS"
LIBS="$LIBS $LIBZLIB"
AC_CHECK_LIB(png, png_access_version_number, png_link_works=yes ; LIBPNG="-lpng $LIBZLIB")
LIBS="$PRELIBS"

dnl check if utahrle library links
utahrle_link_works=no
UTAHRLE=""
if test "x$bc_build_urt" != "xyes" ; then
    # checking for rle_hdr_init is NOT sufficient to get urt 3.x
    PRELIBS="$LIBS"
    LIBS="$LIBS $LIBM"
    AC_CHECK_LIB(utahrle, rle_getraw, utahrle_link_works=yes ; UTAHRLE="-lutahrle $LIBM",
	[AC_CHECK_LIB(rle, rle_getraw, utahrle_link_works=yes ; UTAHRLE="-lrle $LIBM")]
    )
    LIBS="$PRELIBS"
fi

dnl check if openNURBS library links
opennurbs_link_works=no
LIBOPENNURBS=""
if test "x$bc_build_opennurbs" != "xyes" ; then
    AC_CHECK_LIB(openNURBS, onmalloc, opennurbs_link_works=yes ; LIBOPENNURBS="-lopenNURBS")
fi

dnl check if libtcl library links
tcl_link_works=no
LIBTCL=""
AC_CHECK_LIB(tcl8.6, Tcl_Main, tcl_link_works=yes ; LIBTCL="-ltcl8.6",
    [AC_CHECK_LIB(tcl86, Tcl_Main, tcl_link_works=yes ; LIBTCL="-ltcl86",
	[AC_CHECK_LIB(tcl8.5, Tcl_Main, tcl_link_works=yes ; LIBTCL="-ltcl8.5",
	    [AC_CHECK_LIB(tcl85, Tcl_Main, tcl_link_works=yes ; LIBTCL="-ltcl85",
		[AC_CHECK_LIB(tcl8.4, Tcl_Main, tcl_link_works=yes ; LIBTCL="-ltcl8.4",
		    [AC_CHECK_LIB(tcl84, Tcl_Main, tcl_link_works=yes ; LIBTCL="-ltcl84",
			[AC_CHECK_LIB(tcl, Tcl_Main, tcl_link_works=yes ; LIBTCL="-ltcl")]
		    )]
	    	)]
	    )]
	)]
    )]
)

dnl check if libtclstub library links
tclstub_link_works=no
LIBTCLSTUB=""
AC_CHECK_LIB(tclstub8.6, Tcl_InitStubs, tclstub_link_works=yes ; LIBTCLSTUB="-ltclstub8.6",
    [AC_CHECK_LIB(tclstub86, Tcl_InitStubs, tclstub_link_works=yes ; LIBTCLSTUB="-ltclstub86",
	[AC_CHECK_LIB(tclstub8.5, Tcl_InitStubs, tclstub_link_works=yes ; LIBTCLSTUB="-ltclstub8.5",
	    [AC_CHECK_LIB(tclstub85, Tcl_InitStubs, tclstub_link_works=yes ; LIBTCLSTUB="-ltclstub85",
	    	[AC_CHECK_LIB(tclstub8.4, Tcl_InitStubs, tclstub_link_works=yes ; LIBTCLSTUB="-ltclstub8.4",
		    [AC_CHECK_LIB(tclstub84, Tcl_InitStubs, tclstub_link_works=yes ; LIBTCLSTUB="-ltclstub84",
			[AC_CHECK_LIB(tclstub, Tcl_InitStubs, tclstub_link_works=yes ; LIBTCLSTUB="-ltclstub")]
		    )]
		)]
	    )]
	)]
    )]
)

dnl check if libtk library links
tk_link_works=no
LIBTK=""
AC_CHECK_LIB(tk8.6, Tk_MainLoop, tk_link_works=yes ; LIBTK="-ltk8.6",
    [AC_CHECK_LIB(tk86, Tk_MainLoop, tk_link_works=yes ; LIBTK="-ltk86",
	[AC_CHECK_LIB(tk8.5, Tk_MainLoop, tk_link_works=yes ; LIBTK="-ltk8.5",
	    [AC_CHECK_LIB(tk85, Tk_MainLoop, tk_link_works=yes ; LIBTK="-ltk85",
		[AC_CHECK_LIB(tk8.4, Tk_MainLoop, tk_link_works=yes ; LIBTK="-ltk8.4",
		    [AC_CHECK_LIB(tk84, Tk_MainLoop, tk_link_works=yes ; LIBTK="-ltk84",
			[AC_CHECK_LIB(tk, Tk_MainLoop, tk_link_works=yes ; LIBTK="-ltk")]
		    )]
	        )]
	    )]
	)]
    )]
)

dnl check if libtkstub library links
tkstub_link_works=no
LIBTKSTUB=""
PRELIBS="$LIBS"
LIBS="$LIBS $LIBTCLSTUB"
AC_CHECK_LIB(tkstub8.6, Tk_InitStubs, tkstub_link_works=yes ; LIBTKSTUB="-ltkstub8.6",
    [AC_CHECK_LIB(tkstub86, Tk_InitStubs, tkstub_link_works=yes ; LIBTKSTUB="-ltkstub86",
	[AC_CHECK_LIB(tkstub8.5, Tk_InitStubs, tkstub_link_works=yes ; LIBTKSTUB="-ltkstub8.5",
	    [AC_CHECK_LIB(tkstub85, Tk_InitStubs, tkstub_link_works=yes ; LIBTKSTUB="-ltkstub85",
	    	[AC_CHECK_LIB(tkstub8.4, Tk_InitStubs, tkstub_link_works=yes ; LIBTKSTUB="-ltkstub8.4",
		    [AC_CHECK_LIB(tkstub84, Tk_InitStubs, tkstub_link_works=yes ; LIBTKSTUB="-ltkstub84",
			[AC_CHECK_LIB(tkstub, Tk_InitStubs, tkstub_link_works=yes ; LIBTKSTUB="-ltkstub")]
		    )]
		)]
	    )]
	)]
    )]
)
LIBS="$PRELIBS"

dnl check if libitcl library links
itcl_link_works=no
LIBITCL=""
AC_CHECK_LIB(itcl3.4, Itcl_Init, itcl_link_works=yes ; LIBITCL="-litcl3.4",
    [AC_CHECK_LIB(itcl34, Itcl_Init, itcl_link_works=yes ; LIBITCL="-litcl34",
	[AC_CHECK_LIB(itcl3.3, Itcl_Init, itcl_link_works=yes ; LIBITCL="-litcl3.3",
	    [AC_CHECK_LIB(itcl33, Itcl_Init, itcl_link_works=yes ; LIBITCL="-litcl33",
		[AC_CHECK_LIB(itcl3.2, Itcl_Init, itcl_link_works=yes ; LIBITCL="-litcl3.2",
		    [AC_CHECK_LIB(itcl32, Itcl_Init, itcl_link_works=yes ; LIBITCL="-litcl32",
			[AC_CHECK_LIB(itcl, Itcl_Init, itcl_link_works=yes ; LIBITCL="-litcl")]
		    )]
		)]
	    )]
	)]
    )]
)

dnl check if libitk library links
itk_link_works=no
LIBITK=""
AC_CHECK_LIB(itk3.4, Itk_Init, itk_link_works=yes ; LIBITK="-litk3.4",
    [AC_CHECK_LIB(itk34, Itk_Init, itk_link_works=yes ; LIBITK="-litk34",
	[AC_CHECK_LIB(itk3.3, Itk_Init, itk_link_works=yes ; LIBITK="-litk3.3",
	    [AC_CHECK_LIB(itk33, Itk_Init, itk_link_works=yes ; LIBITK="-litk33",
		[AC_CHECK_LIB(itk3.2, Itk_Init, itk_link_works=yes ; LIBITK="-litk3.2",
		    [AC_CHECK_LIB(itk32, Itk_Init, itk_link_works=yes ; LIBITK="-litk32",
			[AC_CHECK_LIB(itk, Itk_Init, itk_link_works=yes ; LIBITK="-litk")]
		    )]
		)]
	    )]
	)]
    )]
)

dnl check if a socket library links
socket_link_works=no
LIBSOCKET=""
AC_CHECK_LIB(socket, socket, socket_link_works=yes ; LIBSOCKET="-lsocket")

dnl check if a network socket library links
nsl_link_works=no
LIBNSL=""
AC_CHECK_LIB(nsl, gethostbyaddr, nsl_link_works=yes ; LIBNSL="-lnsl")

dnl check if a malloc library links
malloc_link_works=no
LIBMALLOC=""
AC_CHECK_LIB(c, mallopt, malloc_link_works=yes ; LIBMALLOC="-lc",
    [AC_CHECK_LIB(malloc, mallopt, malloc_link_works=yes ; LIBMALLOC="-lmalloc")]
)

dnl check if a mx library links
mx_link_works=no
LIBMX=""
AC_CHECK_LIB(mx, matherr, mx_link_works=yes ; LIBMX="-lmx")

dnl check if a dynamic link library links
dl_link_works=no
LIBDL=""
AC_CHECK_LIB(dl, dlopen, dl_link_works=yes ; LIBDL="-ldl")

dnl check if the SGI generic SCSI library links
ds_link_works=no
LIBDS=""
AC_CHECK_LIB(ds, dsopen, ds_link_works=yes ; LIBDS="-lds")

dnl check if an OpenGL graphics library links
gl_link_works=no
LIBGL=""
if test "x$bc_with_opengl" != "xno" ; then
    AC_CHECK_LIB(GL, glEnable, gl_link_works=yes ; LIBGL="$LIBGL -lGL",
	 [AC_CHECK_LIB(GL2, glEnable, gl_link_works=yes ; LIBGL="$LIBGL -lGL2")]
    )
    if test "x$gl_link_works" = "xno" ; then
	PRELDFLAGS="$LDFLAGS"
	PRELIBS="$LIBS"
	for bc_dir in "$ac_x_libraries" `echo "$ac_x_includes $ac_x_header_dirs" |
		sed s/include/lib/g` ; do

	    LDFLAGS="$PRELDFLAGS -L$bc_dir"
	    LIBS="$PRELIBS -lGL"
	    AC_LINK_IFELSE([AC_LANG_CALL([],[glEnable])],
		gl_link_works=yes ; LIBGL="-L$bc_dir -lGL" ; break)
	    LIBS="$PRELIBS -lGL2"
	    AC_LINK_IFELSE([AC_LANG_CALL([],[glEnable])],
		gl_link_works=yes ; LIBGL="-L$bc_dir -lGL2" ; break)
	done
	LDFLAGS="$PRELDFLAGS"
	LIBS="$PRELIBS"
    fi
fi

dnl check if the Windows WGL graphics library links
wgl_link_works=no
LIBWGL=""
if test "xbc_with_wgl" != "xno" ; then
    AC_CHECK_LIB(opengl32, glEnable, wgl_link_works=yes ; LIBWGL="-lopengl32")
fi

dnl check if the SGI graphics library links
sgigl_link_works=no
LIBSGIGL=""
AC_CHECK_LIB(gl, gconfig, sgigl_link_works=yes ; LIBSGIGL="-lgl")

dnl check if the Solaris lexer library links
l_link_works=no
LIBL=""
AC_CHECK_LIB(l, yyless, l_link_works=yes ; LIBL="-ll")

dnl check for the IRIX libgen library (for basename/dirname)
gen_link_works=no
LIGEN=""
AC_CHECK_LIB(gen, basename, gen_link_works=yes ; LIBGEN="-lgen")

dnl check if the standard c++ library links without checking for any particular symbol
dnl library is needed when linking c++ code against c code (e.g. openNURBS)
stdcxx_link_works=no
LIBSTDCXX=""
AC_CHECK_LIB(stdc++, main, stdcxx_link_works=yes ; LIBSTDCXX="-lstdc++",
	[PRELIBS="$LIBS"
	 LIBS="$LIBS $LIBM"
	 AC_CHECK_LIB(stdc++, main, stdcxx_link_works=yes ; LIBSTDCXX="-lstdc++ $LIBM"
	 LIBS="$PRELIBS"
	 )]
)


dnl *************************
dnl *** Check for headers ***
dnl *************************

BC_CONFIGURE_STAGE([headers], [4 of 9])

# C89 headers: assert.h, ctype.h, errno.h, float.h, limits.h, locale.h,
# math.h, setjmp.h, signal.h, stdarg.h, stddef.h, stdio.h, stdlib.h,
# string.h, time.h

# C95 headers: wchar.h, wctype.h, iso646.h

# C99 headers: complex.h, fenv.h, inttypes.h, stdbool.h, stdint.h,
# tgmath.h

# POSIX.1 headers includes C89, C95, and C99 plus the following:
# aio.h, arpa/inet.h, cpio.h, dirent.h, dlfcn.h, fcntl.h, fmtmsg.h,
# fnmatch.h, ftw.h, glob.h, grp.h, iconv.h, langinfo.h, libgen.h,
# monetary.h, mqueue.h, ndbm.h, net/if.h, netdb.h, netinet/in.h,
# netinet/tcp.h, nl_types.h, poll.h, pthread.h, pwd.h, regex.h,
# sched.h, search.h, semaphore.h, spawn.h, strings.h, stropts.h,
# sys/ipc.h, sys/mman.h, sys/msg.h, sys/resource.h, sys/select.h,
# sys/stat.h, sys/statvfs.h, sys/time.h, sys/timeb.h, sys/times.h,
# sys/types.h, sys/uio.h, sys/un.h, sys/utsname.h, sys/wait.h,
# syslog.h, tar.h, termios.h, trace.h, ucontext.h, ulimit.h, unistd.h,
# utime.h, utmpx.h, wordexp.h

AC_HEADER_STDC
AC_HEADER_DIRENT
AC_HEADER_SYS_WAIT
AC_CHECK_HEADERS( \
	Carbon/Carbon.h \
	curses.h \
	dslib.h \
	getopt.h \
	gl/device.h \
	grp.h \
	inttypes.h \
	io.h \
	libgen.h \
	memory.h \
	ncurses.h \
	netinet/in.h \
	pthread.h \
	pwd.h \
	rle.h \
	sched.h \
	sgtty.h \
	stdint.h \
	sys/file.h \
	sys/_ioctl.h \
	sys/ioctl.h \
	sys/ioctl_compat.h \
	sys/machd.h \
	sys/mman.h \
	sys/param.h \
	sys/prctl.h \
	sys/select.h \
	sys/socket.h \
	sys/stat.h \
	sys/sysctl.h \
	sys/sysinfo.h \
	sys/sysmp.h \
	sys/time.h \
	sys/times.h \
	sys/types.h \
	sys/un.h \
	sys/wait.h \
	syslog.h \
	tcl.h \
	termcap.h \
	terminfo.h \
	termio.h \
	termios.h \
	termlib.h \
	tinfo.h \
	tk.h \
	ulocks.h \
	unistd.h \
	winsock.h \
)

if test "x$bc_with_dtrace" != "xno" ; then
    AC_CHECK_HEADER(sys/sdt.h,, [bc_with_dtrace=no])
fi

GL_CPPFLAGS=""
# optionally check for OpenGL headers
if test "x$bc_with_opengl" != "xno" -o "x$bc_with_wgl" != "xno" ; then
    gl_include_works=no

    AC_COMPILE_IFELSE([AC_LANG_SOURCE([@%:@include <GL/gl.h>])],
	[gl_include_works="yes"])
    AC_COMPILE_IFELSE([AC_LANG_SOURCE([@%:@include <GL/glx.h>])],
	[gl_include_works="yes"])

    PRECPPFLAGS="$CPPFLAGS"
    if test "x$gl_include_works" = "xno" ; then
	for bc_dir in "$ac_x_includes" `echo $ac_x_header_dirs` ; do
	    CPPFLAGS="$PRECPPFLAGS -I$bc_dir"
	    AC_COMPILE_IFELSE([AC_LANG_SOURCE([@%:@include <GL/gl.h>])],
		[gl_include_works="yes"])
	    AC_COMPILE_IFELSE([AC_LANG_SOURCE([@%:@include <GL/glx.h>])],
		[gl_include_works="yes"])
	    if test "x$gl_include_works" = "xyes" ; then
		GL_CPPFLAGS="-I$bc_dir"
		break
	    fi
	done
    fi
    AC_CHECK_HEADERS([GL/gl.h GL/glx.h])
    CPPFLAGS="$PRECPPFLAGS"

fi # bc_with_opengl

GL_CFLAGS=$GL_CPPFLAGS
AC_SUBST(GL_CFLAGS)

# optionally (yes or auto) check for vectorization headers for opennurbs
if test "x$bc_build_opennurbs" != "xno" ; then
    AC_CHECK_HEADERS( \
	emmintrin.h \
    )
fi # bc_build_opennurbs

AC_CHECK_HEADER(sys/sched.h,
		AC_DEFINE(HAVE_SYS_SCHED_H, 1, Define to 1 if you have the <sys/sched.h> header file.),,
		[
#ifdef HAVE_PTHREAD_H
#  include <pthread.h>
#endif
#include <sys/sched.h>
])

AC_CHECK_HEADER(sys/mount.h,
		AC_DEFINE(HAVE_SYS_MOUNT_H,1, Define to 1 if you have the <sys/mount.h> header file.),,
		[
#ifdef HAVE_SYS_PARAM_H
#  include <sys/param.h>
#endif
#include <sys/mount.h>
])

AC_CHECK_HEADER(term.h,
		AC_DEFINE(HAVE_TERM_H, 1, Define to 1 if you have the <term.h> header file.),,
		[
#if HAVE_NCURSES_H
#  include <ncurses.h>
#else
#  ifdef HAVE_CURSES_H
#    include <curses.h>
#  else
#    ifdef HAVE_TERMCAP_H
#      include <termcap.h>
#    else
#      ifdef HAVE_TERMINFO_H
#        include <terminfo.h>
#      else
#        ifdef HAVE_TINFO_H
#          include <tinfo.h>
#        endif
#      endif
#    endif
#  endif
#endif
#include <term.h>
])

found_regex_h=no
AC_CHECK_HEADER(regex.h,
		AC_DEFINE(HAVE_REGEX_H,1,[Define to 1 if you have the '<regex.h>' header file])
		found_regex_h=yes )


# check for java headers
if test "x$bc_with_java " != "xno" ; then
    PRECPPFLAGS="$CPPFLAGS"
    CPPFLAGS="$CPPFLAGS $JAVA_CFLAGS"
    found_jni_h=no
    AC_CHECK_HEADER(JavaVM/jni.h,
		    AC_DEFINE(HAVE_JAVAVM_JNI_H,1,[Define to 1 if you have the '<JavaVM/jni.h>' header file])
		    found_jni_h=yes)
    AC_CHECK_HEADER(jni.h,
		    AC_DEFINE(HAVE_JNI_H,1,[Define to 1 if you have the '<jni.h>' header file])
		    found_jni_h=yes )

    search_for_jni_h_more=no
    if test "x$found_jni_h" = "xno" ; then
	if test "x$bc_only_rts" = "xyes" ; then
	    search_for_jni_h_more=yes
	fi
    fi

    if test "x$search_for_jni_h_more" = "xyes" ; then
	# darwin systems may have a prior jni.h stashed away elsewhere
	macjvmdir=/System/Library/Frameworks/JavaVM.framework/Versions
	if test -d "$macjvmdir"  ; then
	    for dir in `ls $macjvmdir` ; do
		if test -d "$macjvmdir/$dir/Headers" ; then
		    JAVA_CFLAGS="$JAVA_CFLAGS -I$macjvmdir/$dir/Headers"
		    CPPFLAGS="$CPPFLAGS -I$macjvmdir/$dir/Headers"
		fi
	    done
	fi

	# try one last time to find jni.h (must disable cached result)
	unset ac_cv_header_jni_h
	AC_CHECK_HEADER(jni.h,
			AC_DEFINE(HAVE_JNI_H,
				  1,
				  [Define to 1 if you have the '<jni.h>' header file])
			found_jni_h=yes )

	if test "x$found_jni_h" != "xno" ; then
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_WARN([jni.h was found by hunting through the JavaVM framework])
	    AC_MSG_WARN([This means you probably need to install the latest Java SDK])
	    AC_MSG_WARN([Build will try to use what it found, but you should update])
	    AC_MSG_NOTICE([See http://developer.apple.com/java/ for updates])
	    AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
	    sleep 1
	fi
    fi # search_for_jni_h_more
    CPPFLAGS="$PRECPPFLAGS"
fi # bc_with_java

# check for proe headers
PROE_CFLAGS=""
if test "x$bc_with_proe" != "xno" ; then
   PRE_CFLAGS="$CFLAGS"
   found_protk_h=no
   if test "x$bc_with_proe" = "xyes" ; then
      if test "x$bc_with_proe_val" = "x" ; then
            found_proe_base=no
	    proe_base=/usr/local/ptc/proeWildfire3.0
	    if test -e "$proe_base" ; then
	       found_proe_base=yes
	       PROE_CFLAGS="-I$proe_base/protoolkit/includes -I$proe_base/prodevelop/includes"
	       CFLAGS="$CFLAGS $PROE_CFLAGS"
	       AC_CHECK_HEADER(ProToolkit.h,
			 AC_DEFINE(HAVE_PROTOOLKIT,1,[Define to 1 if you have Pro/TOOLKIT header files])
			 found_protk_h=yes)
	       if test "x$found_protk_h" = "xyes" ; then
		  bc_with_proe_val=$proe_base
		  PRO_ENGINEER_DIR=$bc_with_proe_val
		  AC_SUBST(PRO_ENGINEER_DIR)
	       fi
	    fi
      else
        PROE_CFLAGS="-I$bc_with_proe_val/protoolkit/includes -I$bc_with_proe_val/prodevelop/includes"
        CFLAGS="$CFLAGS $PROE_CFLAGS"
        AC_CHECK_HEADER(ProToolkit.h,
		        AC_DEFINE(HAVE_PROTOOLKIT,1,[Define to 1 if you have Pro/TOOLKIT header files])
		        found_protk_h=yes)
      fi
   fi
   CFLAGS="$PRE_CFLAGS"
fi


dnl **********************************
dnl *** Check for types/structures ***
dnl **********************************

BC_CONFIGURE_STAGE([types], [5 of 9])

dnl added in autoconf 2.55
dnl AC_HEADER_STDBOOL

AC_C_CHAR_UNSIGNED
AC_HEADER_STAT
AC_HEADER_TIME
AC_STRUCT_ST_BLOCKS
AC_STRUCT_ST_BLKSIZE
AC_CHECK_MEMBERS([struct stat.st_blksize])
AC_CHECK_MEMBERS([struct stat.st_rdev])
AC_STRUCT_TM
AC_TYPE_UID_T
AC_TYPE_MODE_T
AC_TYPE_OFF_T
AC_TYPE_PID_T
AC_TYPE_SIZE_T
AC_CHECK_TYPE(socklen_t, ,
    AC_DEFINE([socklen_t], [int], [Define to int if <sys/socket.h> nor <sys/types.h define socklen_t]),
    [
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
#  include <sys/socket.h>
#endif
])


dnl ******************************************
dnl *** Check for compiler characteristics ***
dnl ******************************************

BC_CONFIGURE_STAGE([compiler], [6 of 9])

if test "xyes" = "xyes" ; then

    dnl try to use -pipe to speed up the compiles
    BC_COMPILER_AND_LINKER_RECOGNIZES([-pipe])


    dnl check for -fno-strict-aliasing
    dnl XXX - THIS FLAG IS REQUIRED if any level of optimization is
    dnl enabled with GCC as we do use aliasing and type-punning.
    BC_COMPILER_AND_LINKER_RECOGNIZES([-fno-strict-aliasing])

    dnl check for -fno-common (libtcl needs it on darwin)
    BC_COMPILER_AND_LINKER_RECOGNIZES([-fno-common])

    dnl check for -fexceptions
    dnl this is needed to resolve __Unwind_Resume when compiling and
    dnl linking against openNURBS in librt for some binaries, for
    dnl example rttherm (i.e. any -static binaries)
    BC_COMPILER_AND_LINKER_RECOGNIZES([-fexceptions], [fexceptions])
    if test "x$bc_fexceptions_works" = "xyes" ; then
       FEXCEPTIONS="-fexceptions"
       AC_SUBST(FEXCEPTIONS)
    fi

    dnl dynamic SSE optimizations for NURBS processing
    BC_COMPILER_AND_LINKER_RECOGNIZES([-msse], [msse], [nokeep])
    MSSE=""
    if test "x$bc_msse_works" = "xyes" ; then
       MSSE="-msse"
    fi
    MSSE2=""
    BC_COMPILER_AND_LINKER_RECOGNIZES([-msse2], [msse2], [nokeep])
    if test "x$bc_msse2_works" = "xyes" ; then
       MSSE2="-msse2"
    fi
    SSE="$MSSE $MSSE2"
    AC_SUBST(SSE)

    dnl check for -search_paths_first linker flag.
    dnl prevent a false-positive where it can be treated as a -s and-e
    dnl linker option by adding a benign flag that should succeed.
    dnl this flag allows dylibs and archives to be found based on a
    dnl library path search order, not biasing a preference for dylibs.
    BC_LINKER_RECOGNIZES([-Wl,-search_paths_first -Wnewline-eof])

    dnl 64bit compilation flags
    if test "x$bc_build_64bit" = "xyes" ; then
	found_64bit_flag=no

	AC_MSG_CHECKING([if configure snuck on a 32bit flag to ld])
	PRELD="$LD"
	LD="`echo $LD | sed 's/32/64/'`"
	if test "x$LD" = "x$PRELD" ; then
		AC_MSG_RESULT(no)
	else
		AC_MSG_RESULT(yes)
	fi

	if test "x$found_64bit_flag" = "xno" ; then
		BC_COMPILER_AND_LINKER_RECOGNIZES([-64], [64_flag])
		if test "x$bc_64_flag_works" = "xyes" ; then
			found_64bit_flag=yes
		fi
	fi

	if test "x$found_64bit_flag" = "xno" ; then
		BC_COMPILER_AND_LINKER_RECOGNIZES([-mabi=64], [64_flag])
		if test "x$bc_64_flag_works" = "xyes" ; then
			found_64bit_flag=yes
		fi
	fi

	if test "x$found_64bit_flag" = "xno" ; then
		BC_COMPILER_AND_LINKER_RECOGNIZES([-m64], [64_flag])
		if test "x$bc_64_flag_works" = "xyes" ; then
			found_64bit_flag=yes
		fi
	fi

	if test "x$found_64bit_flag" = "xno" ; then
		BC_COMPILER_AND_LINKER_RECOGNIZES([-q64], [64_flag])
		if test "x$bc_64_flag_works" = "xyes" ; then
			found_64bit_flag=yes
		fi
	fi
    fi

# end check for automatic flags
fi

dnl profile flags
if test "x$bc_use_profiling" != "xno" ; then
	BC_COMPILER_AND_LINKER_RECOGNIZES([-pg], [profile_flag])
	if test "x$bc_profile_flag_works" = "xno" ; then
		# intel gprof compiler flag
		BC_COMPILER_AND_LINKER_RECOGNIZES([-p], [profile_flag])
	fi

	if test "x$bc_profile_flag_works" = "xno" ; then
		if test "x$bc_use_profiling" = "xyes" ; then
			dnl profiling was requested, so abort
			AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
			AC_MSG_NOTICE([Profiling was enabled but could not find a profile flag])
			AC_MSG_ERROR([*** Don't know how to profile with this compiler ***])
		fi
		AC_MSG_WARN([Don't know how to profile with this compiler])
		sleep 1
	else
		# convert 'auto' to 'no' even though it works
		bc_use_profiling=no
	fi
fi

dnl debug flags
if test "x$bc_use_debug" != "xno" ; then
	BC_COMPILER_AND_LINKER_RECOGNIZES([-g], [debug_flag])
	if test "x$bc_debug_flag_works" = "xno" ; then
		if test "x$bc_use_debug" = "xyes" ; then
			dnl debug was requested, so abort
			AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
			AC_MSG_NOTICE([Debug was enabled but -g does not work])
			AC_MSG_ERROR([*** Don't know how to debug with this compiler ***])
		fi
		AC_MSG_WARN([Do not know how to debug with this compiler])
		sleep 1
	else
		# convert 'auto' to 'yes'
		bc_use_debug="yes"
	fi
fi

dnl optimization flags
if test "x$bc_use_optimized" != "xno" ; then
	BC_COMPILER_AND_LINKER_RECOGNIZES([-O3], [o3_flag])
	if test "x$bc_o3_flag_works" = "xno" ; then
		AC_MSG_WARN([Don't know how to compile optimized with this compiler])
		sleep 1
	fi


# XXX -fast seems to provoke stack corruption in the shadow
# computations, possible that the corruption is indeed valid and
# there's something that needs to be checked/changed.
#
#	BC_COMPILER_AND_LINKER_RECOGNIZES([-fast], [mac_opt_flag])
#	if test "x$bc_mac_opt_flag_works" = "xno" ; then
#		BC_COMPILER_AND_LINKER_RECOGNIZES([-fast -mcpu=7450], [mac_opt_flag])
#	fi
	if test "xdisabled" = "xyes" ; then
		extra_optimization_flag="-ffast-math -fstrength-reduce -fexpensive-optimizations -finline-functions"
		if test "x$bc_use_debug" = "xno" ; then
			dnl non-debug can omit the frame pointer, debug cannot
			extra_optimization_flag="$extra_optimization_flag -fomit-frame-pointer"
		else
			extra_optimization_flag="$extra_optimization_flag -fno-omit-frame-pointer"
		fi
		BC_COMPILER_AND_LINKER_RECOGNIZES([$extra_optimization_flag])
	fi
fi

dnl verbose warning flags (if yes or auto)
if test "x$bc_build_warnings" != "xno" ; then
	BC_COMPILER_AND_LINKER_RECOGNIZES([-W -Wall -Wundef -Wfloat-equal -Wshadow -Wunreachable-code -Winline -Wconversion], [warning])
	# XXX also of interest
	# -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -pedantic -ansi -Werror

	if test "x$bc_warning_flag_works" = "xno" ; then
		AC_MSG_WARN([Don't know how to output verbose warnings with this compiler])
		sleep 1
	fi
fi

# determine the minimum single-precision floating point tolerance
# value at compile time such that: 1.0 + value != 1.0
# ANSI defines this as FLT_EPSILON but float.h may not provide it.
BC_FLOAT_EPSILON

# determine the minimum double-precision floating point tolerance
# value at compile time such that: 1.0 + value != 1.0
# ANSI defines this as DBL_EPSILON but float.h may not provide it.
BC_DOUBLE_EPSILON

# determine whether the single-precision floating point implementation
# seems IEEE 754 compliant.
BC_COMPLIANT_FLOAT

# determine whether the double-precision floating point implementation
# seems IEEE 754 compliant.
BC_COMPLIANT_DOUBLE

# warn if either floating point compliance failed
if test "x$bc_compliant_float" = "xno" || test "x$bc_compliant_double" = "xno" ; then
    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
    AC_MSG_WARN([The floating point implementation does not seem to be IEEE 754])
    AC_MSG_WARN([compliant.  The behavior or htond and htonf may be incorrect.])
    AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
    sleep 1
fi

dnl AC_C_PROTOTYPES
AM_C_PROTOTYPES
AC_DEFINE(USE_PROTOTYPES,1,heh)

AC_C_CONST
AC_C_INLINE
AC_C_VOLATILE
AC_C_BIGENDIAN

# figure out what size pointers the compiler is actually generating
AC_CHECK_SIZEOF(int)
AC_CHECK_SIZEOF(long)
AC_CHECK_SIZEOF(long long)
AC_CHECK_SIZEOF(void *, 4)
pointer_size="$ac_cv_sizeof_void_p"

dnl Make sure that we can actually compile C code
BC_SANITY_CHECK([$CC compiler and flags for sanity])

dnl Make sure that we can actually compile C++ code
AC_LANG_PUSH([C++])
BC_SANITY_CHECK([$CXX compiler and flags for sanity])
AC_LANG_POP


dnl ***************************
dnl *** Check for functions ***
dnl ***************************

BC_CONFIGURE_STAGE([functions], [7 of 9])

AC_TYPE_SIGNAL

# specifically not checked for and not used:
#   access - security concerns

# specifically not checked for but used including any well-behaved
# C89/posix functions.  this includes:
#   stat

# specifically checked for even though C89 (provided by libsysv):
#   memset, strchr, strtok

# some C89 functions: assert, isalnum, isalpha, iscntrl, isdigit,
# isgraph, islower, isprint, ispunct, isspace, isupper, isxdigit,
# tolower, toupper, localeconv, setlocale, acos, asin, atan, atan2,
# ceil, cos, cosh, exp, fabs, floor, fmod, frexp, ldexp, log, log10,
# modf, pow, sin, sinh, sqrt, tan, longjmp, setjmp, raise, signal,
# va_arg, va_end, va_start, offsetof, clearerr, fclose, feof, ferror,
# fflush, fgetc, fgetpos, fgets, fopen, fprintf, fputc, fputs, fread,
# freopen, fscanf, fseek, fsetpos, fwrite, getc, getchar, gets,
# perror, printf, putc, putchar, puts, remove, rename, rewind, scanf,
# setbuf, setvbuf, sprintf, sscanf, tmpfile, tmpnam, ungetc, vprintf,
# vsprintf, abort, abs, atexit, atof, atoi, atol, bsearch, calloc,
# div, exit, free, ftell, getenv, labs, ldiv, malloc, mblen, mbtowcs,
# mbtowc, qsort, rand, realloc, sizeof, srand, strtod, strtol,
# strtoul, system, wctomb, wcstombs, memchr, memcmp, memcpy, memmove,
# memset, strcat, strchr, strcmp, strcoll, strcpy, strcspn, strerror,
# strlen, strncat, strncmp, strncpy, strpbrk, strrchr, strspn, strstr,
# strtok, strxfrm, asctime, clock, ctime, difftime, gmtime, localtime,
# mktime, strftime, time

AC_CHECK_FUNCS(\
	XQueryExtension \
	alarm \
	dlopen \
	drand48 \
	fchmod \
	fsync \
	geteuid \
	getegid \
	gethostname \
	getopt_long \
	getprogname \
	kill \
	lrand48 \
	memset \
	mkstemp \
	pipe \
	random \
	sbrk \
	setenv \
	setpgid \
	setpriority \
	setprogname \
	srand48 \
	strcasecmp \
	strchr \
	strdup \
	strlcat \
	strlcpy \
	strsep \
	strtok \
	sync \
	sysctl \
	sysmp \
	vfork \
	writev \
)
# strcasecmp checked for BLT

dnl *** check if basename() exists ***
AC_MSG_CHECKING([for basename])
PRELIBS="$LIBS"
LIBS="$LIBS $LIBGEN"
AC_TRY_RUN([
#ifdef HAVE_LIBGEN_H
#  include <libgen.h>
#endif
int main(int argc, char *argv[]) {
  (void)basename(argv[0]);
  return 0;
}],
[ AC_MSG_RESULT(yes)
  AC_DEFINE([HAVE_BASENAME], [1], [Define to 1 if you have the `basename' function.])
],
[ AC_MSG_RESULT(no) ])
LIBS="$PRELIBS"

dnl *** check if dirname() exists ***
AC_MSG_CHECKING([for dirname])
PRELIBS="$LIBS"
LIBS="$LIBS $LIBGEN"
AC_TRY_RUN([
#ifdef HAVE_LIBGEN_H
#  include <libgen.h>
#endif
int main(int argc, char *argv[]) {
  (void)dirname(argv[0]);
  return 0;
}],
[ AC_MSG_RESULT(yes)
  AC_DEFINE([HAVE_DIRNAME], [1], [Define to 1 if you have the `dirname' function.])
],
[ AC_MSG_RESULT(no) ])
LIBS="$PRELIBS"


dnl *********************************
dnl *** Check for system services ***
dnl *********************************

BC_CONFIGURE_STAGE([services], [8 of 9])

dnl *** check for bison/yacc or flex/lex ***
# scanner and parser are optionally needed for mged and other tools
# that utilize a parser.  if both are found, provide a make var so we
# can conditionally compile the parsers.
build_parsers=no
if test "x$ac_cv_prog_LEX" != "x" ; then
    if test "x$ac_cv_prog_YACC" != "x" ; then
	# we have both
	build_parsers=yes
    else
	AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	AC_MSG_WARN([A YACC-style parser was not found so dependant portions])
	AC_MSG_WARN([of the package (various MGED commands) will be disabled.])
	AC_MSG_NOTICE([Installation of GNU Bison or Yacc before continuing is recommended.])
	AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
	sleep 1
    fi
else
    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
    if test "x$ac_cv_prog_YACC" != "x" ; then
	AC_MSG_WARN([A LEX-style scanner was not found so dependant portions])
	AC_MSG_WARN([of the package (various MGED commands) will be disabled.])
	AC_MSG_NOTICE([Installation of GNU Flex or Lex before continuing is recommended.])
    else
	AC_MSG_WARN([Neither a YACC-style parser or a LEX-style scanner was found.])
	AC_MSG_WARN([Dependant portions of the package will be disabled.])
	AC_MSG_NOTICE([Installation of Bison/Yacc and Flex/Lex before continuing is recommended.])
    fi
    AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
    sleep 1
fi
AC_MSG_CHECKING([whether we have the essentials to make parsers])
if test "x$build_parsers" = "xyes" ; then
    AC_DEFINE(BC_WITH_PARSERS, 1, [Define to enable compilation of parsers])
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi


dnl *** libpng ***
png_works=no
AC_MSG_CHECKING(for portable network graphics functionality)
PRELIBS="$LIBS"
LIBS="$LIBS $LIBPNG"
AC_TRY_RUN([
#include <png.h>
main() {
    int i = png_access_version_number();
    return 0;
}
], [png_works=yes])
LIBS="$PRELIBS"
AC_MSG_RESULT($png_works)

dnl figure out whether we need to build libpng
build_brlcad_png="no (using system)"
if test "x$bc_build_png" = "xyes" ; then
    build_brlcad_png=yes
else
    if test "x$bc_build_png" = "xno" ; then
	if test "x$png_works" != "xyes" ; then
	    AC_MSG_NOTICE([libpng was disabled, but no system png library was found])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --enable-png-build])
	    AC_MSG_ERROR([*** Building libpng was disabled, yet no system png library was found ***])
	fi
    else
	dnl automatic detection, we need to build if it won't run or won't link
	if test "x$png_works" = "xno" ; then
	    build_brlcad_png=yes
	elif test "x$png_link_works" = "xno" ; then
	    build_brlcad_png=yes
	fi
    fi
fi
AC_MSG_CHECKING(whether to build the included portable network graphics library)
PNG=""
PNG_CPPFLAGS=""
if test "x$build_brlcad_png" = "xyes" ; then
    PNG='${top_builddir}/src/other/libpng/libpng.la'
    PNG_CPPFLAGS='-I${top_srcdir}/src/other/libpng'
    AC_MSG_RESULT(yes)
else
    PNG="$LIBPNG"
    AC_MSG_RESULT(no)
fi
AC_SUBST(PNG)
AC_SUBST(PNG_CPPFLAGS)


dnl *** libregex ***
dnl See if regular expression support works
regex_works=no
AC_MSG_CHECKING(for regular expression functionality)
PRELIBS="$LIBS"
LIBS="$LIBS $LIBREGEX"
AC_TRY_RUN([
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#include <regex.h>
int main() {
    regex_t re;
    regcomp(&re, "abc", REG_EXTENDED);
    regexec(&re, "", 0, 0, 0);
    return 0;
}
], [regex_works=yes])
LIBS="$PRELIBS"
AC_MSG_RESULT($regex_works)

dnl figure out whether we need to build libregex
build_brlcad_regex="no (using system)"
if test "x$bc_build_regex" = "xyes" ; then
    build_brlcad_regex=yes
else
    if test "x$bc_build_regex" = "xno" ; then
	if test "x$regex_works" != "xyes" ; then
	    AC_MSG_NOTICE([libregex was disabled, but no system regular expression library was found])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --enable-regex-build])
	    AC_MSG_ERROR([*** Building libregex was disabled, yet no system regex was found ***])
	fi
    else
	dnl automatic detection
	if test "x$regex_works" = "xno" ; then
	    build_brlcad_regex=yes
	fi
    fi
fi
AC_MSG_CHECKING(whether to build the included regular expression library)
REGEX=""
REGEX_CPPFLAGS=""
if test "x$build_brlcad_regex" = "xyes" ; then
    REGEX='${top_builddir}/src/other/libregex/libregex.la'
    REGEX_CPPFLAGS='-I${top_srcdir}/src/other/libregex'
    AC_MSG_RESULT(yes)
else
    REGEX="$LIBREGEX"
    AC_MSG_RESULT(no)
fi
AC_SUBST(REGEX)
AC_SUBST(REGEX_CPPFLAGS)


dnl *** libz ***
dnl See if zlib library support works
zlib_works=no
AC_MSG_CHECKING(for zlib compression functionality)
PRELIBS="$LIBS"
LIBS="$LIBS $LIBZLIB"
AC_TRY_RUN([
#include <zlib.h>
int main () {
    char *zlibver = ZLIB_VERSION;
    return 0;
}
], [zlib_works=yes])
LIBS="$PRELIBS"
AC_MSG_RESULT($zlib_works)

dnl figure out whether we need to build libz
build_brlcad_zlib="no (using system)"
if test "x$bc_build_zlib" = "xyes" ; then
    build_brlcad_zlib=yes
else
    if test "x$bc_build_zlib" = "xno" ; then
	if test "x$zlib_works" != "xyes" ; then
	    AC_MSG_NOTICE([libz was disabled, but no system zlib compression library was found])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --enable-zlib-build])
	    AC_MSG_ERROR([*** Building libz was disabled, yet no system zlib compression library was found ***])
	fi
    else
	dnl automatic detection
	if test "x$zlib_works" = "xno" ; then
	    build_brlcad_zlib=yes
	fi
    fi
fi
AC_MSG_CHECKING(whether to build the included zlib compression library)
LIBZ=""
LIBZ_CPPFLAGS=""
if test "x$build_brlcad_zlib" = "xyes" ; then
    LIBZ='${top_builddir}/src/other/libz/libz.la'
    LIBZ_CPPFLAGS='-I${top_srcdir}/src/other/libz'
    AC_MSG_RESULT(yes)
else
    LIBZ="$LIBZLIB"
    AC_MSG_RESULT(no)
fi
AC_SUBST(LIBZ)
AC_SUBST(LIBZ_CPPFLAGS)


dnl *** X11 interface compilation ***
build_against_x11="no"
if test "x$bc_with_x11" != "xno" ; then
    x11_works=no
    AC_MSG_CHECKING(for X11 header functionality)
    PRELIBS="$LIBS"
    PRECPPFLAGS="$CPPFLAGS"
    CPPFLAGS="$CPPFLAGS $X_CFLAGS"
    AC_TRY_RUN([
#include <X11/Xlib.h>
main() {
    XPoint pt;
    pt.x = pt.y = 0;
    return pt.x;
}
    ],[x11_works=yes])
    AC_MSG_RESULT($x11_works)
    if test "x$x11_works" = "xyes" ; then
	LIBS="$LIBS $X_LIBS"
	AC_MSG_CHECKING(for X11 link functionality)
	AC_TRY_RUN([
#include <X11/Xlib.h>
main() {
    XModifierKeymap *xmkm;
    xmkm=XNewModifiermap(1);
    return xmkm==NULL;
}
	],,x11_works=no)
	AC_MSG_RESULT($x11_works)
    fi
    LIBS="$PRELIBS"
    CPPFLAGS="$PRECPPFLAGS"

    dnl figure out whether we need to build against X11
    if test "x$bc_with_x11" != "xno" ; then
	if test "x$bc_build_aquatk" = "xyes" ; then
	    X_LIBS=""
	    LIBGL=""
	    X_CFLAGS=""
	    build_against_opengl="no"
	    if test "x$bc_with_x11" = "xyes" ; then
		AC_MSG_ERROR([*** X11 was requested, but tk will be built for AquaTk ***])
	    fi
	else
	    if test "x$x11_works" = "xyes" ; then
		build_against_x11="yes"
	    else
		if test "x$bc_with_x11" = "xyes" ; then
		    AC_MSG_NOTICE([X11 was requested, but no system X11 libraries were found])
		    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
		    AC_MSG_NOTICE([Try adding --without-x11])
		    AC_MSG_ERROR([*** Using X11 was requested, yet no system X11 was found ***])
		else
		    AC_MSG_NOTICE([X11 does not appear to be functionally available])
		fi
	    fi
	fi
    fi
fi
AC_SUBST(X_PREFIX)
AC_SUBST(X_CFLAGS)
AC_SUBST(X_LIBS)
AC_MSG_CHECKING(whether to build against X11)
AC_MSG_RESULT($build_against_x11)


dnl *** utah raster toolkit ***
dnl See if libutahrle seems to work
urt_works=no
AC_MSG_CHECKING(for Utah Raster Toolkit library functionality)
PRELIBS="$LIBS"
if test "x$utahrle_link_works" = "xyes" ; then
    LIBS="$LIBS $UTAHRLE"
fi
AC_TRY_RUN([
#ifdef HAVE_RLE_H
#  include <rle.h>
#endif
int main () {
    rle_hdr header = *rle_hdr_init( NULL );
    return 0;
}
], [urt_works=yes])
if test "x$utahrle_link_works" = "xyes" ; then
    LIBS="$PRELIBS"
fi
AC_MSG_RESULT($urt_works)

dnl figure out whether we need to build urt
build_brlcad_urt="no (using system)"
if test "x$bc_build_urt" = "xyes" ; then
    build_brlcad_urt=yes
else
    if test "x$bc_build_urt" = "xno" ; then
	if test "x$urt_works" != "xyes" ; then
	    AC_MSG_NOTICE([Utah Raster Toolkit was disabled, but no system URT/RLE library was found ***])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --enable-urt-build])
	    AC_MSG_ERROR([*** Utah Raster Toolkit was disabled, yet no usable RLE system library was found ***])
	fi
    else
	dnl automatic detection
	if test "x$urt_works" = "xno" ; then
	    build_brlcad_urt=yes
	fi
    fi
fi
AC_MSG_CHECKING(whether to build the Utah Raster Toolkit)
RLE=""
RLE_CPPFLAGS=""
if test "x$build_brlcad_urt" = "xyes" ; then
    RLE='${top_builddir}/src/other/libutahrle/libutahrle.la'
    RLE_CPPFLAGS='-I${top_srcdir}/src/other/libutahrle/include'
    AC_MSG_RESULT(yes)
else
    if test "x$utahrle_link_works" = "xyes" ; then
	RLE="$UTAHRLE"
    fi
    AC_MSG_RESULT(no)
fi
AC_SUBST(RLE)
AC_SUBST(RLE_CPPFLAGS)


dnl *** openNURBS ***
dnl See if openNURBS library support works
opennurbs_works=no
AC_MSG_CHECKING(for openNURBS functionality)
PRELIBS="$LIBS"
LIBS="$LIBS $LIBOPENNURBS $LIBZLIB"
AC_LANG_PUSH([C++])
AC_TRY_RUN([
#include <opennurbs.h>
int main () {
    int version = ON::Version();
    return 0;
}
], [opennurbs_works=yes])
AC_LANG_POP
LIBS="$PRELIBS"
AC_MSG_RESULT($opennurbs_works)

dnl figure out whether we need to build openNURBS
build_brlcad_opennurbs="no (using system)"
if test "x$bc_build_opennurbs" = "xyes" ; then
    build_brlcad_opennurbs=yes
else
    if test "x$bc_build_opennurbs" = "xno" ; then
	if test "x$opennurbs_works" != "xyes" ; then
	    AC_MSG_NOTICE([openNURBS was disabled, but no system openNURBS library was found])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --enable-opennurbs-build])
	    AC_MSG_ERROR([*** openNURBS was disabled, yet no usable system openNURBS was found ***])
	fi
    else
	dnl automatic detection
	if test "x$opennurbs_works" = "xno" ; then
	    build_brlcad_opennurbs=yes
	fi
    fi
fi
AC_MSG_CHECKING(whether to build the included openNURBS library)
OPENNURBS=""
OPENNURBS_CPPFLAGS='-I${top_srcdir}/src/other/openNURBS ${LIBZ_CPPFLAGS}'
if test "x$build_brlcad_opennurbs" = "xyes" ; then
    OPENNURBS='${top_builddir}/src/other/openNURBS/libopenNURBS.la ${LIBSTDCXX}'
    AC_MSG_RESULT(yes)
else
    OPENNURBS="$LIBOPENNURBS $LIBSTDCXX $LIBZ"	# produces "  " if we didn't find OpenNURBS
    AC_MSG_RESULT(no)
fi
AC_SUBST(OPENNURBS)
AC_SUBST(OPENNURBS_CPPFLAGS)


dnl *** Tcl ***
dnl See if libtcl seems to work
tcl_works=no
AC_MSG_CHECKING(for Tcl library functionality)
PRELIBS="$LIBS"
if test "x$tcl_link_works" = "xyes" ; then
    LIBS="$LIBS $LIBTCL"
fi
AC_TRY_RUN([
#ifdef HAVE_TCL_H
#  include <tcl.h>
#endif
#ifndef TCL_MAJOR_VERSION
#  error Unknown major version of Tcl
#endif
#ifndef TCL_MINOR_VERSION
#  error Unknown minor version of Tcl
#endif
#include <stdio.h>
int main() {
    Tcl_Time time;
    Tcl_Interp *interp;
    interp = Tcl_CreateInterp();
    if (Tcl_Init(interp) == TCL_ERROR) {
	fprintf(stderr, "Tcl_Init returned error\n");
	return 1;
    }
    /* Tcl_GetTime is an 8.4 symbol */
    Tcl_GetTime(&time);
#if TCL_MAJOR_VERSION < 8
    fprintf(stderr, "major version < 8\n");
    return 1;
#elif TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION < 4
    fprintf(stderr, "minor version < 4\n");
    return 1;
#endif
    return 0;
}
], [tcl_works=yes])
if test "x$tcl_link_works" = "xyes" ; then
    LIBS="$PRELIBS"
fi
AC_MSG_RESULT($tcl_works)

dnl figure out whether we need to build Tcl
build_brlcad_tcl="no (using system)"
if test "x$bc_build_tcl" = "xyes" ; then
    build_brlcad_tcl=yes
else
    if test "x$bc_build_tcl" = "xno" ; then
	if test "x$tcl_works" = "xno" ; then
	    AC_MSG_NOTICE([libtcl was disabled, but no system Tcl library was found])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --enable-tcl-build])
	    AC_MSG_ERROR([*** Tcl was disabled, yet no usable libtcl system library was found ***])
	fi
    else
	dnl automatic detection
	if test "x$tcl_works" = "xno" ; then
	    build_brlcad_tcl=yes
	fi
    fi
fi

AC_MSG_CHECKING(whether to build Tcl)
TCL=""
TCLSTUB=""
TCL_CPPFLAGS=""
unset ac_cv_c_tclconfig
if test "x$build_brlcad_tcl" = "xyes" ; then
    TCL_VERSION="8.5"
    AC_MSG_RESULT(yes)
    case $host_os in
	 darwin*)
	     TCL='-L${top_builddir}/src/other/tcl/unix'" -ltcl${TCL_VERSION} $FRAMEWORK_COREFOUNDATION"
	     ;;
    	 *)
	     TCL='-L${top_builddir}/src/other/tcl/unix'" -ltcl${TCL_VERSION} ${LIBDL} ${LIBM}"
	     ;;
    esac
    TCLSTUB='-L${top_builddir}/src/other/tcl/unix'" -ltclstub${TCL_VERSION}"
    TCL_CPPFLAGS='-I${top_srcdir}/src/other/tcl/generic -I${top_srcdir}/src/other/tcl/unix'
else
    AC_MSG_RESULT(no)

    dnl find tclConfig.sh, add --with-tcl option, don't cache result for AC_CONFIG_SUBDIRS
    SC_PATH_TCLCONFIG
    # keep TCL_BIN_DIR, don't keep ac_cv_c_tclconfig
    unset ac_cv_c_tclconfig

    dnl If we're using the system Tcl, then we need to load
    dnl tclConfig.sh to get the TCL_VERSION and other vars.
    SC_LOAD_TCLCONFIG

    if test "x$tcl_link_works" = "xyes" ; then
	TCL="$LIBTCL"
    else
	AC_MSG_WARN([Unable to link against a system Tcl library])
	sleep 1
    fi
    if test "x$tclstub_link_works" = "xyes" ; then
	TCLSTUB="$LIBTCLSTUB"
    else
	AC_MSG_WARN([Unable to link against a system Tclstub library])
	sleep 1
    fi
fi
dnl AC_SUBST values are below after itcl sanity check


dnl *** Tk ***
dnl See if libtk seems to work
tk_works=no
AC_MSG_CHECKING(for Tk library functionality)
PRELIBS="$LIBS"
if test "x$tk_link_works" = "xyes" ; then
    LIBS="$LIBS $LIBTK $LIBTCL"
fi
AC_TRY_RUN([
#ifdef HAVE_TCL_H
#  include <tcl.h>
#endif
#ifdef HAVE_TK_H
#  include <tk.h>
#endif
#ifndef TK_MAJOR_VERSION
#  error Unknown major version of Tk
#endif
#ifndef TK_MINOR_VERSION
#  error Unknown minor version of Tk
#endif
#include <stdio.h>
int cow = 0;
Tk_ArgvInfo argtbl[] = {
    {"-h", TK_ARGV_CONSTANT, (char *)1, (char *)&cow, "cow."},
    {NULL, TK_ARGV_END, NULL, NULL, NULL}};
int main() {
    Tcl_Interp *interp;
    const char *arg[5] = {".", "xview", "moveto", "1.0", NULL};
    int argl = 1, cow = 0;
    interp = Tcl_CreateInterp();
#define ATTEMPT(try,fail) if(try) { fprintf(stderr, fail": %s\n", \
	interp->result); return -1; }
    ATTEMPT(Tcl_Init(interp) == TCL_ERROR,"Tcl_Init returned error");
    ATTEMPT(Tk_ParseArgv(interp, NULL, &argl, arg, argtbl,
 	TK_ARGV_DONT_SKIP_FIRST_ARG) != TCL_OK, "Tk_ParseArgv");
#if TK_MAJOR_VERSION < 8
    fprintf(stderr, "major version < 8  (it's %d)\n", TK_MAJOR_VERSION);
    return 4;
#elif TK_MAJOR_VERSION == 8 && TK_MINOR_VERSION < 4
    fprintf(stderr, "minor version < 4  (it's %d)\n", TK_MINOR_VERSION);
    return 5;
#endif
    return 0;
}
], [tk_works=yes])
if test "x$tk_link_works" = "xyes" ; then
    LIBS="$PRELIBS"
fi
AC_MSG_RESULT($tk_works)

dnl figure out whether we need to build Tk
build_brlcad_tk="no (using system)"
build_against_tk=$tk_works
if test "x$bc_build_tk" = "xyes" ; then
    build_brlcad_tk=yes
else
    if test "x$bc_build_tk" = "xno" ; then
	if test "x$tk_works" = "xno" ; then
	    AC_MSG_NOTICE([libtk was disabled, but no system Tk library was found])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --enable-tk-build])
	    AC_MSG_ERROR([*** Tk was disabled, yet no usable libtk system library was found ***])
	fi
    else
	dnl automatic detection
	if test "x$tk_works" = "xno" ; then
	    build_brlcad_tk=yes
	fi
    fi
fi
AC_MSG_CHECKING(whether to build Tk)
TK=""
TKSTUB=""
TK_CPPFLAGS=""
unset ac_cv_c_tkconfig
if test "x$build_brlcad_tk" = "xyes" ; then
    TK_VERSION="8.5"
    build_against_tk="yes"
    AC_MSG_RESULT(yes)
    TK='-L${top_builddir}/src/other/tk/unix'" -ltk${TCL_VERSION}"
    TKSTUB='-L${top_builddir}/src/other/tk/unix'" -ltkstub${TK_VERSION}"
    TK_CPPFLAGS='-I${top_srcdir}/src/other/tk/generic -I${top_srcdir}/src/other/tk/unix -I${top_srcdir}/src/other/tk/win'
    if test "x$bc_build_aquatk" = "xyes" ; then
	TK_CPPFLAGS="$TK_CPPFLAGS "'-I${top_srcdir}/src/other/tk/xlib'
    fi
else
    AC_MSG_RESULT(no)

    dnl find tkConfig.sh, add --with-tk option, don't cache result for AC_CONFIG_SUBDIRS
    SC_PATH_TKCONFIG
    # keep TK_BIN_DIR, don't keep ac_cv_c_tkconfig
    unset ac_cv_c_tkconfig

    dnl If we're using the system Tk, then we need to load
    dnl tkConfig.sh to get the TK_VERSION and other vars.
    SC_LOAD_TKCONFIG

    if test "x$tk_link_works" = "xyes" ; then
	TK="$LIBTK"
    else
	AC_MSG_WARN([Unable to link against a system Tk library])
	sleep 1
    fi
    if test "x$tkstub_link_works" = "xyes" ; then
	TKSTUB="$LIBTKSTUB"
    else
	AC_MSG_WARN([Unable to link against a system Tkstub library])
	sleep 1
    fi
fi
dnl AC_SUBST values are below after itcl sanity check


dnl *** incrTcl ***
dnl See if libitcl and libitk seem to work, make sure it's not dependant upon libtcl
itcl_works=no
AC_MSG_CHECKING(for incrTcl library functionality)
PRELIBS="$LIBS"
if test "x$itcl_link_works" = "xyes" ; then
    LIBS="$LIBS $LIBITCL $LIBTCL"
fi
AC_TRY_RUN([
#include <itcl.h>
#ifndef ITCL_MAJOR_VERSION
#  error Unknown major version of incrTcl
#endif
#ifndef ITCL_MINOR_VERSION
#  error Unknown minor version of incrTcl
#endif
#include <stdio.h>
int main() {
    Itcl_Stack stack;
    Itcl_InitStack(&stack);
#if ITCL_MAJOR_VERSION < 3
    fprintf(stderr, "major version < 3\n");
    return 1;
#elif ITCL_MAJOR_VERSION == 3 && ITCL_MINOR_VERSION < 2
    fprintf(stderr, "minorversion < 2\n");
    return 1;
#endif
    return 0;
}
], [itcl_works=yes])
if test "x$itcl_link_works" = "xyes" ; then
    LIBS="$PRELIBS"
fi
AC_MSG_RESULT($itcl_works)

dnl figure out whether we need to build incrTcl
build_brlcad_itcl="no (using system)"
if test "x$bc_build_itcl" = "xyes" ; then
    build_brlcad_itcl=yes
else
    if test "x$bc_build_itcl" = "xno" ; then
	if test "x$itcl_works" = "xno" ; then
	    AC_MSG_NOTICE([incrTcl was disabled, but no system incrTcl library was found])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --enable-itcl-build])
	    AC_MSG_ERROR([*** incrTcl was disabled, yet no usable libitcl system library was found ***])
	fi
    else
	dnl automatic detection
	if test "x$itcl_works" = "xno" ; then
	    build_brlcad_itcl=yes
	fi
    fi
fi
AC_MSG_CHECKING(whether to build incrTcl)

dnl itcl/itk
ITCL=""
ITK=""
ITCL_CPPFLAGS=""
ITK_CPPFLAGS=""
ITCL_VERSION=3.4
case $host_os in
     *netbsd-*|*freebsd-[[1-3]]*.*|*openbsd-[[1-3]]*|*sunos4*)
	 # some OS's don't like dots in the lib name
	 ITCL_VERSION="`echo ${ITCL_VERSION} | tr -d .`"
	 ;;
esac
AC_SUBST(ITCL_VERSION)
if test "x$build_brlcad_itcl" = "xyes" ; then
    ITCL='${top_builddir}/src/other/incrTcl/libitcl.la'
    ITK='${top_builddir}/src/other/incrTcl/libitk.la'
    ITCL_CPPFLAGS='-I${top_srcdir}/src/other/incrTcl/itcl/generic'
    ITK_CPPFLAGS='-I${top_srcdir}/src/other/incrTcl/itk/generic'
    AC_MSG_RESULT(yes)
else
    if test "x$itcl_link_works" = "xyes" ; then
	ITCL="$LIBITCL"
	ITK="$LIBITK"
    fi
    AC_MSG_RESULT(no)
fi
AC_SUBST(ITCL)
AC_SUBST(ITK)
AC_SUBST(ITCL_CPPFLAGS)
AC_SUBST(ITK_CPPFLAGS)
AC_SUBST(LIBITCL)
AC_SUBST(LIBITK)

# XXX need incrTcl's configure for the proper .so/.dylib value
ITCL_LIB_FILE="libitcl${ITCL_VERSION}.a"
ITK_LIB_FILE="libitk${ITCL_VERSION}.a"
AC_SUBST(ITCL_LIB_FILE)
AC_SUBST(ITK_LIB_FILE)


dnl *** tcl+itcl sanity ***
dnl See if the tcl we're using is compatible with the incrTcl we're using
if test "x$TCL" = "x$LIBTCL" ; then
    if test "x$ITCL" != "x$LIBITCL" ; then
	# apparently want to use system tcl with non-system incrTcl
	# is that sane?
	if test "x$TCL_VERSION" = "x8.4" ; then
	    AC_MSG_WARN([Unable to find a system incrTcl compatible with the available system Tcl])
	    AC_MSG_WARN([Enabling compilation of both Tcl and incrTcl])
	    # nope!
	    build_brlcad_tcl="yes"
	    build_brlcad_tk="yes"
	    TCL_VERSION="8.5"
	    TK_VERSION="8.5"

	    case $host_os in
		darwin*)
		    TCL='-L${top_builddir}/src/other/tcl/unix'" -ltcl${TCL_VERSION} $FRAMEWORK_COREFOUNDATION"
		    ;;
		*)
		    TCL='-L${top_builddir}/src/other/tcl/unix'" -ltcl${TCL_VERSION} ${LIBDL} ${LIBM}"
		    ;;
	    esac
	    TCLSTUB='-L${top_builddir}/src/other/tcl/unix'" -ltclstub${TCL_VERSION}"
	    TCL_CPPFLAGS='-I${top_srcdir}/src/other/tcl/generic -I${top_srcdir}/src/other/tcl/unix'

	    TK='-L${top_builddir}/src/other/tk/unix'" -ltk${TCL_VERSION}"
	    TKSTUB='-L${top_builddir}/src/other/tk/unix'" -ltkstub${TK_VERSION}"
	    TK_CPPFLAGS='-I${top_srcdir}/src/other/tk/generic -I${top_srcdir}/src/other/tk/unix -I${top_srcdir}/src/other/tk/win'
	    if test "x$bc_build_aquatk" = "xyes" ; then
		TK_CPPFLAGS="$TK_CPPFLAGS "'-I${top_srcdir}/src/other/tk/xlib'
	    fi
	fi
    fi
fi
AC_SUBST(TCL)
AC_SUBST(TCLSTUB)
AC_SUBST(TCL_CPPFLAGS)
AC_SUBST(TCL_VERSION)
AC_SUBST(LIBTCL)
AC_SUBST(TK)
AC_SUBST(TKSTUB)
AC_SUBST(TK_CPPFLAGS)
AC_SUBST(TK_VERSION)
AC_SUBST(LIBTK)


dnl *** iwidgets ***
dnl See if the iwidgets are available
iwidgets_works=no
AC_MSG_CHECKING(for iwidgets functionality)
PRELIBS="$LIBS"
if test "x$tcl_link_works" = "xyes" ; then
    LIBS="$LIBS $LIBTCL $LIBITCL"
fi
dnl this test is probably not sufficient if iwidgets is not locateable
dnl in the tcl auto_path.
AC_TRY_RUN([
#ifdef HAVE_TCL_H
#  include <tcl.h>
#endif
int main() {
    int res = TCL_OK;
    Tcl_Interp *interp;
    const char *cmd = "package require Iwidgets";
    char *b = NULL;
    interp = Tcl_CreateInterp();
    if (Tcl_Init(interp) == TCL_ERROR) {
	printf("TCL interpreter failed to init: %s\n", interp->result);
	return 1;
    }
    if (Itcl_Init(interp) == TCL_ERROR) {
	printf("ITCL interp failed to initaliaze: %s\n", interp->result);
	return 1;
    }
    res = Tcl_Eval(interp, cmd);
    if ( res != TCL_OK) {
	printf("Failed to load Iwidgets: %s\n", interp->result);
	if(Tcl_Eval(interp, "package names") == TCL_ERROR)
	    return 1;
	while(b=strtok(b?NULL:interp->result," "))
	  if(!strncmp(b,"Iwidgets",8))
	    return 0;
        return 1;
    }
    return 0;
}
], [iwidgets_works=yes])
if test "x$tcl_link_works" = "xyes" ; then
    LIBS="$PRELIBS"
fi
AC_MSG_RESULT($iwidgets_works)

dnl figure out whether we need to install the iwidgets package
build_brlcad_iwidgets="no (using system)"
if test "x$bc_build_iwidgets" = "xyes" ; then
    build_brlcad_iwidgets=yes
else
    if test "x$bc_build_iwidgets" = "xno" ; then
	if test "x$iwidgets_works" = "xno" ; then
	    AC_MSG_NOTICE([iwidgets was disabled, but no system iwidgets package was found])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --enable-iwidgets-build])
	    AC_MSG_ERROR([*** iwidgets was disabled, yet no usable iwidgets system package was found ***])
	fi
    else
	dnl automatic detection
	if test "x$iwidgets_works" = "xno" ; then
	    build_brlcad_iwidgets=yes
	fi
    fi
fi
AC_MSG_CHECKING(whether to install iwidgets)
AC_MSG_RESULT($build_brlcad_iwidgets)
IWIDGETS_VERSION="4.0.1"
AC_DEFINE_UNQUOTED([IWIDGETS_VERSION], "$IWIDGETS_VERSION", "Version of iWidgets")
AC_SUBST(IWIDGETS_VERSION)


dnl *** BLT ***
dnl figure out whether we need to build BLT
BLT_VERSION="2.4"
BLT_SUFFIX="`echo ${BLT_VERSION} | tr -d .`"
case $host_os in
     *netbsd-*|*freebsd-[[1-3]]*.*|*openbsd-[[1-3]]*|*sunos4*)
	 # some OS's don't like dots in the lib name
	 BLT_VERSION=$BLT_SUFFIX
	 ;;
esac
AC_SUBST(BLT_VERSION)
AC_SUBST(BLT_SUFFIX)
BLT_LIBRARY="${BRLCAD_ROOT}/lib/blt${BLT_VERSION}"
AC_SUBST(BLT_LIBRARY)
AC_MSG_CHECKING(whether to build libblt)
if test "x$build_against_x11" = "xno" ; then
    # BLT *requires* X11
    bc_built_blt=no
fi
if test ! "x$bc_build_blt" = "xno" ; then
    build_brlcad_blt=yes
    BLT='${top_builddir}/src/other/blt/libBLT${BLT_SUFFIX}.la'
    AC_MSG_RESULT(yes)
else
    build_brlcad_blt=no
    BLT=""
    AC_MSG_RESULT(no)
fi
AC_SUBST(BLT)


dnl *** tkImg ***
dnl figure out whether we need to build tkImg
TKIMG_VERSION="1.3"
case $host_os in
     *netbsd-*|*freebsd-[[1-3]]*.*|*openbsd-[[1-3]]*|*sunos4*)
	 # some OS's don't like dots in the lib name
	 TKIMG_VERSION="`echo ${TKIMG_VERSION} | tr -d .`"
	 ;;
esac
AC_SUBST(TKIMG_VERSION)
AC_MSG_CHECKING(whether to build tkimg)
if test ! "x$bc_build_tkimg" = "xno" ; then
    build_brlcad_tkimg=yes
    TKIMG='${top_builddir}/src/other/tkimg/tkimg${TKIMG_VERSION}.la'
    AC_MSG_RESULT(yes)
else
    build_brlcad_tkimg=no
    TKIMG=""
    AC_MSG_RESULT(no)
fi
AC_SUBST(TKIMG)


dnl *** TNT ***
dnl See if template numerical toolkit works
tnt_works=no
AC_MSG_CHECKING(for TNT w/JAMA functionality)
AC_LANG_PUSH(C++)
AC_TRY_RUN([
#include <stdio.h>
#include <jama_lu.h>
int main () {
    Array2D<double> matrix = Array2D<double>(2,2);
    matrix[0][0] = matrix[1][0] = 1.0;
    matrix[0][1] = matrix[1][1] = 0.0;
    JAMA::LU<double> decomposition = JAMA::LU<double>(matrix);
    if (decomposition.isNonsingular()) {
	printf("JAMA:LU decomposition returned non-singular on a singular matrix\n");
	return 1;
    }
    return 0;
}
], [tnt_works=yes])
AC_LANG_POP(C++)
AC_MSG_RESULT($tnt_works)

dnl figure out whether we need to build libz
build_brlcad_tnt="no (using system)"
if test "x$bc_build_tnt" = "xyes" ; then
    build_brlcad_tnt=yes
else
    if test "x$bc_build_tnt" = "xno" ; then
	if test "x$tnt_works" != "xyes" ; then
	    AC_MSG_NOTICE([TNT was disabled, but no suitable system TNT was found])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --enable-tnt-build])
	    AC_MSG_ERROR([*** Use of the included TNT was disabled, yet no system TNT was found ***])
	fi
    else
	dnl automatic detection
	if test "x$tnt_works" = "xno" ; then
	    build_brlcad_tnt=yes
	fi
    fi
fi
AC_MSG_CHECKING(whether to use the included Template Numerical Toolkit)
TNT_CPPFLAGS=""
if test "x$build_brlcad_tnt" = "xyes" ; then
    TNT_CPPFLAGS='-I${top_srcdir}/src/other/tnt'
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi
AC_SUBST(TNT_CPPFLAGS)


dnl *** libthread ***
AC_MSG_CHECKING(for threading library availability)
AC_MSG_RESULT($thread_link_works)
AC_SUBST(LIBTHREAD)

AC_MSG_CHECKING(if pthreading works)
thread_works=no
AC_TRY_RUN([
#ifdef HAVE_PTHREAD_H
#  include <pthread.h>
#endif
void *thread_hook(void *arg) {
    return NULL;
}
main () {
    pthread_t thread;
    pthread_create(&thread, (void *)0, thread_hook, (void *)0);
    pthread_join(thread, NULL);
    return 0;
}
], [thread_works=yes])
AC_MSG_RESULT($thread_works)


dnl *** libtermlib ***
dnl See if termlib library support works
termlib_works=no
AC_MSG_CHECKING(for termlib functionality)
PRELIBS="$LIBS"
LIBS="$LIBS $LIBTERMLIB"
AC_TRY_RUN([
#ifdef HAVE_TERMLIB_H
#  include <termlib.h>
#else
#  if HAVE_NCURSES_H
#    include <ncurses.h>
#  else
#    ifdef HAVE_CURSES_H
#      include <curses.h>
#    else
#      ifdef HAVE_TERMCAP_H
#        include <termcap.h>
#      else
#        ifdef HAVE_TERMINFO_H
#          include <terminfo.h>
#        else
#          ifdef HAVE_TINFO_H
#            include <tinfo.h>
#          endif
#        endif
#      endif
#    endif
#  endif
#  if HAVE_TERM_H
#    include <term.h>
#  endif
#endif
int main () {
    char buffer[2048] = {0};
    int result = tgetent(buffer, "vt100");
    return 0;
}
], [termlib_works=yes])
LIBS="$PRELIBS"
AC_MSG_RESULT($termlib_works)

dnl figure out whether we need to build libtermlib
build_brlcad_termlib="no (using system)"
if test "x$bc_build_termlib" = "xyes" ; then
    build_brlcad_termlib=yes
else
    if test "x$bc_build_termlib" = "xno" ; then
	if test "x$termlib_works" != "xyes" ; then
	    AC_MSG_NOTICE([termlib was disabled, but no system terminal library was found])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --enable-termlib-build])
	    AC_MSG_ERROR([*** Building termlib was disabled, yet no system termcap or curses library was found ***])
	fi
    else
	dnl automatic detection
	if test "x$termlib_works" = "xno" ; then
	    build_brlcad_termlib=yes
	fi
    fi
fi
AC_MSG_CHECKING(whether to build the included termlib library)
TERMLIB=""
TERMLIB_CPPFLAGS=""
if test "x$build_brlcad_termlib" = "xyes" ; then
    TERMLIB='${top_builddir}/src/other/libtermlib/libtermlib.la'
    TERMLIB_CPPFLAGS='-I${top_srcdir}/src/other/libtermlib'
    AC_MSG_RESULT(yes)
else
    TERMLIB="$LIBTERMLIB"
    AC_MSG_RESULT(no)
fi
AC_SUBST(TERMLIB)
AC_SUBST(TERMLIB_CPPFLAGS)


dnl *** libm ***
AC_MSG_CHECKING(whether to link with the system math library)
AC_MSG_RESULT($m_link_works)
AC_SUBST(LIBM)

dnl *** libsocket ***
AC_MSG_CHECKING(for system socket library availability)
AC_MSG_RESULT([$socket_link_works])
AC_SUBST(LIBSOCKET)

dnl *** libnsl ***
AC_MSG_CHECKING(for system network socket library availablity)
AC_MSG_RESULT([$nsl_link_works])
AC_SUBST(LIBNSL)

dnl *** libmalloc ***
AC_MSG_CHECKING(for system malloc library availability)
AC_MSG_RESULT([$malloc_link_works])
AC_SUBST(LIBMALLOC)

dnl *** libmx ***
AC_MSG_CHECKING(for system mx library availability)
AC_MSG_RESULT([$mx_link_works])
AC_SUBST(LIBMX)

dnl *** libdl ***
AC_MSG_CHECKING(for system dynamic linker library availability)
AC_MSG_RESULT([$dl_link_works])
AC_SUBST(LIBDL)

dnl *** libds ***
AC_MSG_CHECKING(for SGI /dev/scsi library availability)
AC_MSG_RESULT([$ds_link_works])
AC_SUBST(LIBDS)

dnl *** libgl ***
AC_MSG_CHECKING(for OpenGL library availability)
AC_MSG_RESULT($gl_link_works)
AC_SUBST(LIBGL)

dnl *** libopengl32 ***
AC_MSG_CHECKING(for WindowsGL library availability)
AC_MSG_RESULT($wgl_link_works)
AC_SUBST(LIBWGL)

dnl *** sgigl ***
AC_MSG_CHECKING(for SGI graphics library availability)
AC_MSG_RESULT($sgigl_link_works)
AC_SUBST(LIBSGIGL)
if test "x$sgigl_link_works" = "xyes" ; then
    AC_DEFINE(HAS_SGIGL, 1, Irix GL is present.)
fi

dnl *** libl Solaris lexer library ***
AC_MSG_CHECKING(for Solaris lexer library availability)
AC_MSG_RESULT($l_link_works)
AC_SUBST(LIBL)

dnl *** libgen IRIX dirname/basename library ***
AC_MSG_CHECKING(for libgen library availability)
AC_MSG_RESULT($gen_link_works)
AC_SUBST(LIBGEN)

dnl *** libregex ***
AC_MSG_CHECKING(for system regular expression library availability)
AC_MSG_RESULT($regex_link_works)
AC_SUBST(LIBREGEX)

dnl *** libpng ***
AC_MSG_CHECKING(for system portable network graphics availability)
AC_MSG_RESULT($png_link_works)
AC_SUBST(LIBPNG)

dnl *** openNURBS library ***
AC_MSG_CHECKING(for system openNURBS library availability)
AC_MSG_RESULT($opennurbs_link_works)
AC_SUBST(LIBOPENNURBS)

dnl *** libstdc++ C++ library ***
AC_MSG_CHECKING(whether the Standard C++ library is available)
AC_MSG_RESULT($stdcxx_link_works)
AC_SUBST(LIBSTDCXX)

if test "x$bc_with_dtrace" = "xyes" ; then
    AC_DEFINE(USE_DTRACE, 1, [Are we building with DTrace support?])
    DTRACE_SRC="\${DTRACE_SRC}"
    DTRACE_HDR="\${DTRACE_HDR}"
    DTRACE_OBJ="\${DTRACE_OBJ}"
    AC_SUBST(DTRACE_SRC)
    AC_SUBST(DTRACE_HDR)
    AC_SUBST(DTRACE_OBJ)
fi

dnl *** 64-bit compilation ***
dnl figure out whether we are building 64-bit
build_brlcad_64bit="no"
if test "x$bc_build_64bit" = "xyes" ; then
    if test "x$pointer_size" != "x8" ; then
	AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	AC_MSG_NOTICE([Try removing --enable-64bit-build or modifying the CFLAGS/LDFLAGS])
	AC_MSG_ERROR([*** Building 64-bit was requested, yet the build seems to be non-64-bit ***])
    fi
    build_brlcad_64bit=yes
else
    if test "x$bc_build_64bit" = "xno" ; then
	if test "x$pointer_size" = "x8" ; then
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try removing --disable-64bit-build or modifying the CFLAGS/LDFLAGS])
	    AC_MSG_ERROR([*** Building non-64-bit was requested, yet the build seems to be 64-bit ***])
	fi
    fi

    dnl automatic detection
    if test "x$pointer_size" = "x8" ; then
	build_brlcad_64bit="yes"
    elif test "x$pointer_size" = "x4" ; then
	build_brlcad_64bit="no (32-bit)"
    elif test "x$pointer_size" = "x2" ; then
	build_brlcad_64bit="no (16-bit)"
    elif test "x$pointer_size" = "x1" ; then
	build_brlcad_64bit="no (8-bit)"
    else
	AC_MSG_WARN([Unknown pointer size: $pointer_size])
	sleep 1
    fi
fi


dnl *** Jove compilation ***
build_brlcad_jove=no
if test "x$bc_build_jove" = "xyes" ; then
    build_brlcad_jove=yes
elif test "x$bc_build_jove" = "xno" ; then
    build_brlcad_jove=no	# body for the sake of body
else
    # enable jove if no suitable system emacs/jove was found
    if test "x$BCEDITOR" = "x" ; then
	build_brlcad_jove=yes
    fi
fi


dnl *** Java interface compilation ***
build_against_java=no
if test "x$bc_with_java" != "xno" ; then
    AC_MSG_CHECKING(for Java functionality)
    if test "x$found_jni_h" = "xno" ; then
	if test "x$bc_only_rts" != "xno" ; then
	    AC_MSG_RESULT(no)
	    AC_MSG_NOTICE([searching more extensively])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --with-jdk=/path/to/jdk to find jni.h])
	    AC_MSG_ERROR([*** Cannot locate jni.h for building librtserver ***])
	fi
	if test "x$bc_with_java" = "xyes" ; then
	    AC_MSG_RESULT(no)
	    AC_MSG_NOTICE([searching more extensively])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_ERROR([Failed to locate a functioning jni.h for Java])
	fi

	if test "x$bc_with_java" != "xauto" ; then
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_WARN([Unable to locate a functioning Java])
	    AC_MSG_WARN([Compilation of librtserver will be disabled])
	    AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
	    sleep 1
	fi
	AC_MSG_RESULT(no)
    else # found_jni_h
	if test "x$bc_with_java" = "xauto" ; then
	    build_against_java=yes
	else
	    build_against_java="yes ($bc_with_java_val)"
	fi
	AC_MSG_RESULT(yes)
    fi # found_jni_h
fi # bc_with_java


dnl *** Pro/ENGINEER installation / plugin compilation ***
build_against_proe=no
if test "x$bc_with_proe" != "xno" ; then
    if test "x$pointer_size" != "x4" ; then
	AC_MSG_RESULT(no)
	AC_MSG_WARN([The Pro/E plugin must be built as a 32-bit library. Please disable 64-bit builds and set appropriate C/CXXFLAGS])
	sleep 1
    else
	AC_MSG_CHECKING(for Pro/ENGINEER installation)
	if test "x$found_protk_h" = "xno" ; then
	    AC_MSG_RESULT(no)
	    if test "x$bc_with_proe" = "xyes" ; then
		AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
		AC_MSG_WARN([Unable to locate ProToolkit.h. Make sure your installation of Pro/E also has Pro/TOOLKIT])
		AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
		sleep 1
	    fi
	    if test "x$bc_with_proe" = "xauto" ; then
		AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
		AC_MSG_WARN([Pro/E was not installed in the standard place (/usr/local/ptc/proeWildfire3.0).])
		AC_MSG_WARN([Try adding --with-proe=/path/to/proe to find the ProToolkit.h])
		AC_MSG_WARN([Compilation of Pro/ENGINEER plugin will be disabled])
		AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
		sleep 1
	    fi
	else
	    if test "x$bc_with_proe" = "xauto" ; then
		build_against_proe=yes
	    else
		build_against_proe="yes ($bc_with_proe_val)"
	    fi
	    AC_MSG_RESULT(yes)
	fi
    fi
fi


dnl *** OpenGL interface compilation ***
build_against_opengl="no"
if test "x$bc_with_opengl" != "xno" ; then
    AC_MSG_CHECKING(for OpenGL functionality)
    opengl_works=no
    PRELIBS="$LIBS"
    PRECPPFLAGS="$CPPFLAGS"
    LIBS="$LIBS $LIBGL"
    CPPFLAGS="$CPPFLAGS $GL_CPPFLAGS"
    AC_TRY_RUN([
#ifdef HAVE_GL_GL_H
#  include <GL/gl.h>
#endif
main(int argc, char *argv[]) {
    GLboolean values;
    void (*func)() = glBegin;
    if (GL_FALSE || argc > 1) {
	func(GL_POINTS);
	glGetBooleanv(GL_DEPTH_TEST, &values);
	glEnd();
    }
    return 0;
}
    ], [opengl_works=yes])
    LIBS="$PRELIBS"
    CPPFLAGS="$PRECPPFLAGS"
    AC_MSG_RESULT($opengl_works)

    dnl figure out whether we need to build against opengl
    if test "x$opengl_works" = "xyes" ; then
	build_against_opengl="yes"
    else
	if test "x$bc_with_opengl" = "xyes" ; then
	    AC_MSG_NOTICE([OpenGL was requested, but no system OpenGL libraries were found])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --without-opengl])
	    AC_MSG_ERROR([*** Using OpenGL was requested, yet no system OpenGL was found ***])
	else
	    AC_MSG_NOTICE([OpenGL does not appear to be functionally available])
	fi
    fi
fi # bc_with_opengl
AC_MSG_CHECKING(whether to build against OpenGL)
AC_MSG_RESULT($build_against_opengl)


dnl *** WindowsGL interface compilation ***
build_against_wgl="no"
if test "x$bc_with_wgl" != "xno" ; then
    AC_MSG_CHECKING(for WindowsGL functionality)
    wgl_works=no
    PRELIBS="$LIBS"
    LIBS="$LIBS $LIBWGL"
    AC_TRY_RUN([
#ifdef HAVE_GL_GL_H
#  include <GL/gl.h>
#endif
main(int argc, char *argv[]) {
    GLboolean values;
    void (*func)() = glBegin;
    if (GL_FALSE || argc > 1) {
        func(GL_POINTS);
	glGetBooleanv(GL_DEPTH_TEST, &values);
	glEnd();
    }
    return 0;
}
    ], [wgl_works=yes])
    LIBS="$PRELIBS"
    AC_MSG_RESULT($wgl_works)

    dnl figure out whether we need to build against wgl
    if test "x$wgl_works" = "xyes" ; then
	build_against_wgl="yes"
    else
	if test "x$bc_with_wgl" = "xyes" ; then
	    AC_MSG_NOTICE([WindowsGL was requested, but no system WGL OpenGL libraries were found])
	    AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	    AC_MSG_NOTICE([Try adding --without-wgl])
	    AC_MSG_ERROR([*** Using WindowsGL was requested, yet no system WGL OpenGL was found ***])
	else
	    AC_MSG_NOTICE([WindowsGL does not appear to be functionally available])
	fi
    fi
fi # bc_with_wgl
AC_MSG_CHECKING(whether to build against WindowsGL)
AC_MSG_RESULT($build_against_wgl)

dnl *** Knobs availability ***
dials_and_buttons=no
AC_MSG_CHECKING(for SGI dials and buttons support)
AC_TRY_RUN([
#ifdef HAVE_GL_DEVICE_H
#  include <gl/device.h>
#endif
main () {
    if (DIAL0 | DIAL1 | DIAL2 | DIAL3) {
	return 0;
    }
    return 1;
}
], [dials_and_buttons=yes])
if test "x$dials_and_buttons" = "xyes" ; then
    AC_DEFINE(IR_KNOBS, 8, [Turn on SGI knobs])
    AC_DEFINE(IR_BUTTONS, 32, [Turn on SGI buttons])
fi
AC_MSG_RESULT($dials_and_buttons)


# XXX nasty temp hack for backwards cake compatibility. code needs to be fixed.
if test "x$host_os" = "xirix6.5" ; then
    # XXX the code that relies on this will be going away, but until then..
    if test "x$build_brlcad_64bit" = "xyes" ; then
	CFLAGS="$CFLAGS -DIRIX64=65"
    else
	CFLAGS="$CFLAGS -DIRIX=6"
    fi
fi

dnl search the BRL-CAD include directory (required for non-srcdir builds).
dnl should come after the system services checks otherwise or our headers
dnl may conflict.
CPPFLAGS="$CPPFLAGS -DBRLCADBUILD=1 -I\${top_srcdir}/include $OPENNURBS_CPPFLAGS"

# make sure ECHO and ECHO_N got defined and substituted
if test "x$ECHO" = "x" ; then
    ECHO=echo
    AC_MSG_NOTICE([ECHO was not defined by configure so defining manually])
fi
AC_SUBST(ECHO)
AC_SUBST(ECHO_N)


dnl **************************************
dnl *** Configure Makefiles and output ***
dnl **************************************

BC_CONFIGURE_STAGE([output], [9 of 9])

# remove surrounding whitspace
CFLAGS="`echo $CFLAGS`"
CXXFLAGS="`echo $CXXFLAGS`"
CPPFLAGS="`echo $CPPFLAGS`"
LDFLAGS="`echo $LDFLAGS`"
LIBS="`echo $LIBS`"

AM_CONDITIONAL(BUILD_TCL, [test "x$build_brlcad_tcl" = "xyes"])
AM_CONDITIONAL(BUILD_TK, [test "x$build_brlcad_tk" = "xyes"])
AM_CONDITIONAL(BUILD_ITCL, [test "x$build_brlcad_itcl" = "xyes"])
AM_CONDITIONAL(BUILD_IWIDGETS, [test "x$build_brlcad_iwidgets" = "xyes"])
AM_CONDITIONAL(BUILD_BLT, [test "x$build_brlcad_blt" = "xyes"])
AM_CONDITIONAL(BUILD_TKIMG, [test "x$build_brlcad_tkimg" = "xyes"])
AM_CONDITIONAL(BUILD_PNG, [test "x$build_brlcad_png" = "xyes"])
AM_CONDITIONAL(BUILD_REGEX, [test "x$build_brlcad_regex" = "xyes"])
AM_CONDITIONAL(BUILD_ZLIB, [test "x$build_brlcad_zlib" = "xyes"])
AM_CONDITIONAL(BUILD_URT, [test "x$build_brlcad_urt" = "xyes"])
AM_CONDITIONAL(BUILD_OPENNURBS, [test "x$build_brlcad_opennurbs" = "xyes"])
AM_CONDITIONAL(BUILD_TERMLIB, [test "x$build_brlcad_termlib" = "xyes"])
AM_CONDITIONAL(BUILD_TNT, [test "x$build_brlcad_tnt" = "xyes"])
AM_CONDITIONAL(BUILD_JOVE, [test "x$build_brlcad_jove" = "xyes"])
AM_CONDITIONAL(BUILD_EF, [test "x$bc_build_ef" = "xyes"])
AM_CONDITIONAL(BUILD_CUBIT, [test "x$bc_build_cubit" = "xyes"])
AM_CONDITIONAL(BUILD_UG, [test "x$bc_build_ug" = "xyes"])

# libfb and libdm interfaces
AM_CONDITIONAL(WITH_X11, [test "x$build_against_x11" != "xno"])
AM_CONDITIONAL(WITH_OPENGL, [test "x$build_against_opengl" != "xno" && test "x$build_against_x11" != "xno"])
AM_CONDITIONAL(WITH_WGL, [test "x$build_against_wgl" != "xno"])
AM_CONDITIONAL(WITH_TK, [test "xyes" = "xno"])
#AM_CONDITIONAL(WITH_TK, [test "x$build_against_tk" != "xno"])

AM_CONDITIONAL(WITH_JAVA, [test "x$build_against_java" != "xno"])
AM_CONDITIONAL(WITH_PROE, [test "x$build_against_proe" != "xno"])
AM_CONDITIONAL(WITH_PARSERS, [test "x$build_parsers" != "xno"])

AM_CONDITIONAL(INSTALL_MODELS, [test "x$bc_install_geometry" = "xyes"])
AM_CONDITIONAL(ONLY_BENCHMARK, [test "x$bc_only_benchmark" != "xno"])
AM_CONDITIONAL(ONLY_RTS, [test "x$bc_only_rts" != "xno"])


dnl Any combination of the different optimizations listed below may individually be
dnl optionally turned off by commenting out the unwanted defines in the config file.
dnl
dnl NO_BOMBING_MACROS
dnl      turns off many macros in h/bu.h and h/bn.h that check a condition (such as a
dnl      magic number) and bu_bomb on failure.  note that turning this flag on will
dnl      remove the debug capability to catch fatal runtime erros (bugs) and exit
dnl      gracefully.
dnl NO_MAGIC_CHECKING
dnl      turns off allocation of (some) variables and calls to check magic numbers.
dnl      note that this will hinder memory corrupting bug detection.
dnl NO_BADRAY_CHECKING
dnl      is a risky optimization to turn off checking in librt/shoot.c for bad rays
dnl      passed in to the expensive shootray() routine.
dnl NO_DEBUG_CHECKING
dnl      is an optimization that replaces instances of rt_g.debug in if statements
dnl      where checking for a debug level occurs (in order to output a debug message)
dnl      with the integer constant 0.  note that turning this flag on will remove the
dnl      capability to output debug messages and commands that take a debug-level args
dnl      will not output as expected.  see h/raytrace.h for the implementation details.

if test "x$bc_build_runtime_debug" = "xno" ; then
	AC_MSG_NOTICE([}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}])
	AC_MSG_WARN([While disabling run-time debugging should increase])
	AC_MSG_WARN([performance, it will likewise remove several])
	AC_MSG_WARN([data-protection safeguards that are in place to])
	AC_MSG_WARN([minimize the possibility of corrupted data files])
	AC_MSG_WARN([in the inevitable event of a user encountering a bug.])
	AC_MSG_WARN([You have been warned.  Proceed at your own risk.])
	AC_MSG_NOTICE([{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{])
	sleep 1
	AC_DEFINE(NO_BOMBING_MACROS, 1, [Define to not do anything for macros that only bomb on a fatal error])
	AC_DEFINE(NO_MAGIC_CHECKING, 1, [Define to not perform magic number checking])
	AC_DEFINE(NO_BADRAY_CHECKING, 1, [Define to not check for divide by zero during ray shots])
	AC_DEFINE(NO_DEBUG_CHECKING, 1, [Define to not provide run-time debug facilities via rt_g.debug])
fi

dnl compile-time debug
if test "x$bc_use_debug" != "xno" ; then
	AC_DEFINE(DEBUG, 1, [Define to enable compile-time debug code])
else
	AC_DEFINE(NDEBUG, 1, [Define to indicate non-debug code (assert utilizes)])
fi

dnl SMP-aware (i.e. PARALLEL) build
if test "x$bc_build_parallel" != "xno" ; then
	AC_DEFINE(PARALLEL, 1, [Define to enable SMP architecture parallel computation support ])
fi

AC_DEFINE_UNQUOTED([USE_FBSERV], [1], [Required for libdm/mged to allow direct fbserv render connections])


#
# set up the BRL-CAD libraries
#

BN='${top_builddir}/src/libbn/libbn.la'
BU='${top_builddir}/src/libbu/libbu.la'
CURSOR='${top_builddir}/src/libcursor/libcursor.la'
DM='${top_builddir}/src/libdm/libdm.la'
FB='${top_builddir}/src/libfb/libfb.la'
FFT='${top_builddir}/src/libfft/libfft.la'
GED='${top_builddir}/src/libged/libged.la'
MULTISPECTRAL='${top_builddir}/src/libmultispectral/libmultispectral.la'
OPTICAL='${top_builddir}/src/liboptical/liboptical.la'
ORLE='${top_builddir}/src/liborle/liborle.la'
PKG='${top_builddir}/src/libpkg/libpkg.la'
RT='${top_builddir}/src/librt/librt.la'
SYSV='${top_builddir}/src/libsysv/libsysv.la'
TCLCAD='${top_builddir}/src/libtclcad/libtclcad.la'
TERMIO='${top_builddir}/src/libtermio/libtermio.la'
WDB='${top_builddir}/src/libwdb/libwdb.la'
BRLCAD='${top_builddir}/src/libbrlcad.la'

ORLE_LIBS=
PKG_LIBS="${LIBSOCKET} ${LIBNSL}"
SYSV_LIBS=
TERMIO_LIBS="${TERMLIB}"
CURSOR_LIBS="${TERMLIB}"
FFT_LIBS="${LIBM}"
BU_LIBS="${TCL} ${PNG} ${LIBM} ${LIBMALLOC} ${LIBTHREAD}"
BN_LIBS="${BU} ${BU_LIBS} ${TCL} ${LIBM}"
RT_LIBS="${BN} ${BN_LIBS} ${BU} ${BU_LIBS} ${REGEX} ${LIBM} ${SYSV} ${OPENNURBS}"
GED_LIBS="${RT} ${RT_LIBS} ${BN} ${BN_LIBS} ${BU} ${BU_LIBS}"
WDB_LIBS="${RT} ${RT_LIBS} ${BN} ${BN_LIBS} ${BU} ${BU_LIBS}"
FB_LIBS="${BU} ${BU_LIBS} ${PKG} ${TCL} ${SOCKET} ${NSL}" # additional/optional FB_LIBS: ${TK} ${X_LIBS} ${LIBGL}
OPTICAL_LIBS="${RT} ${RT_LIBS} ${BN} ${BN_LIBS} ${BU} ${BU_LIBS} ${TCL}"
MULTISPECTRAL_LIBS="${OPTICAL} ${OPTICAL_LIBS} ${RT} ${RT_LIBS} ${BN} ${BN_LIBS} ${BU} ${BU_LIBS}"
DM_LIBS="${GED} ${GED_LIBS} ${RT} ${RT_LIBS} ${FB} ${FB_LIBS} ${PNG} ${TK} ${X_LIBS} ${FRAMEWORK_CARBON}"
TCLCAD_LIBS="${GED} ${GED_LIBS} ${DM} ${DM_LIBS} ${FB} ${FB_LIBS} ${ITK} ${ITCL} ${TK} ${TCLSTUB} ${BLT} ${TCL}"
BRLCAD_LIBS="${GED} ${GED_LIBS} ${WDB} ${WDB_LIBS} ${RT} ${RT_LIBS} ${BN} ${BN_LIBS} ${BU} ${BU_LIBS}"

AC_SUBST(BN)
AC_SUBST(BU)
AC_SUBST(CURSOR)
AC_SUBST(DM)
AC_SUBST(FB)
AC_SUBST(FFT)
AC_SUBST(GED)
AC_SUBST(MULTISPECTRAL)
AC_SUBST(OPTICAL)
AC_SUBST(ORLE)
AC_SUBST(PKG)
AC_SUBST(RT)
AC_SUBST(SYSV)
AC_SUBST(TCLCAD)
AC_SUBST(TERMIO)
AC_SUBST(WDB)
AC_SUBST(BRLCAD)

AC_SUBST(BN_LIBS)
AC_SUBST(BU_LIBS)
AC_SUBST(CURSOR_LIBS)
AC_SUBST(DM_LIBS)
AC_SUBST(FB_LIBS)
AC_SUBST(FFT_LIBS)
AC_SUBST(GED_LIBS)
AC_SUBST(MULTISPECTRAL_LIBS)
AC_SUBST(OPTICAL_LIBS)
AC_SUBST(ORLE_LIBS)
AC_SUBST(PKG_LIBS)
AC_SUBST(RT_LIBS)
AC_SUBST(SYSV_LIBS)
AC_SUBST(TCLCAD_LIBS)
AC_SUBST(TERMIO_LIBS)
AC_SUBST(WDB_LIBS)
AC_SUBST(BRLCAD_LIBS)


# if compiling with the MIPSpro 7.3 compiler, there is a bug when
# trying to link using an rpath longer than 256 that causes the linker
# to core dump.
AM_CONDITIONAL(LINK_STATIC_REQUIRED, [test "x$build_vendor" = "xsgi" -a "x$compiler" = "xsgi" ])

dnl XXX - hack for justins g.c file
AM_CONDITIONAL(HAVE_BRLCAD, true)
AM_CONDITIONAL(HAVE_DOXYGEN, false)

dnl sample applications
SAMPLE_APPLICATIONS_DIR='${BRLCAD_DATA}/sample_applications'
AC_SUBST(SAMPLE_APPLICATIONS_DIR)

# stash the top builddir before configuring subdirectories
bc_top_builddir="$ac_top_builddir"

# stash the current configuration args before adding additional ones
# for subconfigure
bc_configure_args="$ac_configure_args"

dnl the way to turn on debug for tcl/tk configure
if test "x$bc_use_debug" != "xno" ; then
   ac_configure_args="$ac_configure_args --enable-symbols"
fi

dnl configure Tcl
if test "x$build_brlcad_tcl" = "xyes" ; then
    TCL_PATH="$PWD/${ac_top_builddir}/src/other/tcl/unix"
    ac_configure_args="$ac_configure_args --with-tcl=\"$TCL_PATH\""
    AC_CONFIG_SUBDIRS([src/other/tcl/unix])
    TCL_PATH="`echo ${TCL_PATH} | sed 's/\\/\\//\\//g;s/\\//\\\\\\//g'`"
fi
AC_SUBST(TCL_PATH)

dnl configure Tk
if test "x$build_brlcad_tk" = "xyes" ; then
    if test "x$bc_build_aquatk" = "xyes" ; then
	ac_configure_args="$ac_configure_args --enable-aqua --disable-xft"
    fi
    TK_PATH="$PWD/${ac_top_builddir}/src/other/tk/unix"
    ac_configure_args="$ac_configure_args --with-tk=\"$TK_PATH\""
    AC_CONFIG_SUBDIRS([src/other/tk/unix])
    TK_PATH="`echo ${TK_PATH} | sed 's/\\/\\//\\//g;s/\\//\\\\\\//g'`"
fi
AC_SUBST(TK_PATH)

dnl configure enigma
AC_CONFIG_SUBDIRS([misc/enigma])

AC_CONFIG_FILES([
	Makefile
	bench/Makefile
	regress/Makefile
	db/Makefile
	db/include/Makefile
	doc/Makefile
	doc/book/Makefile
	doc/docbook/Makefile
	doc/docbook/oed/Makefile
	doc/html/Makefile
	doc/html/ReleaseNotes/Makefile
	doc/html/ReleaseNotes/Rel5.0/Makefile
	doc/html/ReleaseNotes/Rel5.0/Summary/Makefile
	doc/html/ReleaseNotes/Rel6.0/Makefile
	doc/html/manuals/Anim_Tutorial/Makefile
	doc/html/manuals/Makefile
	doc/html/manuals/archer/Makefile
	doc/html/manuals/cadwidgets/Makefile
	doc/html/manuals/libbu/Makefile
	doc/html/manuals/libdm/Makefile
	doc/html/manuals/librt/Makefile
	doc/html/manuals/mged/Makefile
	doc/html/manuals/mged/animmate/Makefile
	doc/html/manuals/shaders/Makefile
	doc/legal/Makefile
	doc/pad_file.xml
	include/Makefile
	include/conf/Makefile
	m4/Makefile
	misc/Makefile
	misc/archlinux/Makefile
	misc/brlcad-config
	misc/brlcad.spec
	misc/debian/Makefile
	misc/debian/changelog
	misc/macosx/Makefile
	misc/macosx/Resources/Makefile
	misc/macosx/Resources/ReadMe.rtfd/Makefile
	misc/macosx/Resources/Welcome.rtfd/Makefile
	misc/nsis/Makefile
	misc/pkgconfig/Makefile
	misc/pkgconfig/bn.pc
	misc/pkgconfig/brlcad.pc
	misc/pkgconfig/bu.pc
	misc/pkgconfig/dm.pc
	misc/pkgconfig/fb.pc
	misc/pkgconfig/fft.pc
	misc/pkgconfig/multispectral.pc
	misc/pkgconfig/optical.pc
	misc/pkgconfig/pkg.pc
	misc/pkgconfig/rt.pc
	misc/pkgconfig/wdb.pc
	misc/win32-msvc/Dll/Makefile
	misc/win32-msvc/Makefile
	misc/win32-msvc8/Makefile
	pix/Makefile
	sh/Makefile
	src/Makefile
	src/adrt/Makefile
	src/adrt/bench/Makefile
	src/adrt/doc/Makefile
	src/adrt/isst/Makefile
	src/adrt/libcommon/Makefile
	src/adrt/librender/Makefile
	src/adrt/libtexture/Makefile
	src/adrt/libtie/Makefile
	src/adrt/libtienet/Makefile
	src/adrt/libutil/Makefile
	src/adrt/master/Makefile
	src/adrt/misc/Makefile
	src/adrt/rise/Makefile
	src/adrt/scripts/Makefile
	src/adrt/slave/Makefile
	src/anim/Makefile
	src/archer/Makefile
	src/archer/plugins/Commands/Makefile
	src/archer/plugins/Core/Makefile
	src/archer/plugins/Makefile
	src/archer/plugins/Utility/Makefile
	src/archer/plugins/Wizards/Makefile
	src/archer/plugins/Wizards/tankwizardIA/Makefile
	src/archer/plugins/Wizards/tankwizardIA/images/Makefile
	src/brlman/Makefile
	src/brlman/awf
	src/brlman/brlman
	src/burst/Makefile
	src/bwish/Makefile
	src/canon/Makefile
	src/conv/Makefile
	src/conv/comgeom/Makefile
	src/conv/iges/Makefile
	src/conv/jack/Makefile
	src/conv/off/Makefile
	src/conv/patch/Makefile
	src/conv/3dm/Makefile
	src/external/Makefile
	src/external/Cubit/Makefile
	src/external/EndgameFramework/Makefile
	src/external/ProEngineer/Makefile
	src/external/ProEngineer/mk
	src/external/ProEngineer/protk.dat
	src/external/Unigraphics/Makefile
	src/fb/Makefile
	src/fbed/Makefile
	src/fbserv/Makefile
	src/gtools/Makefile
	src/gtools/beset/Makefile
	src/halftone/Makefile
	src/irprep/Makefile
	src/java/Makefile
	src/java/mil/Makefile
	src/java/mil/army/Makefile
	src/java/mil/army/arl/Makefile
	src/java/mil/army/arl/brlcad/Makefile
	src/lgt/Makefile
	src/libbn/Makefile
	src/libbu/Makefile
	src/libcursor/Makefile
	src/libdm/Makefile
	src/libfb/Makefile
	src/libfft/Makefile
	src/libged/Makefile
	src/libmultispectral/Makefile
	src/liboptical/Makefile
	src/liborle/Makefile
	src/libpkg/Makefile
	src/librt/Makefile
	src/librtserver/Makefile
	src/libsysv/Makefile
	src/libtclcad/Makefile
	src/libtermio/Makefile
	src/libwdb/Makefile
	src/mged/Makefile
	src/mged/points/Makefile
	src/mk/Makefile
	src/nirt/Makefile
	src/nirt/sfiles/Makefile
	src/other/Makefile
	src/other/URToolkit/Makefile
	src/other/URToolkit/cnv/Makefile
	src/other/URToolkit/cnv/rletoabA62/Makefile
	src/other/URToolkit/cnv/rletogif/Makefile
	src/other/URToolkit/man/Makefile
	src/other/URToolkit/tools/Makefile
	src/other/URToolkit/tools/clock/Makefile
	src/other/awf/Makefile
	src/other/blt/Makefile
	src/other/blt/cf/Makefile
	src/other/blt/demos/Makefile
	src/other/blt/demos/bitmaps/Makefile
	src/other/blt/examples/Makefile
	src/other/blt/html/Makefile
	src/other/blt/library/Makefile
	src/other/blt/library/dd_protocols/Makefile
	src/other/blt/library/pkgIndex.tcl
	src/other/blt/man/Makefile
	src/other/blt/src/Makefile
	src/other/blt/win/Makefile
	src/other/incrTcl/Makefile
	src/other/incrTcl/doc/Makefile
	src/other/incrTcl/itcl/Makefile
	src/other/incrTcl/itcl/doc/Makefile
	src/other/incrTcl/itcl/generic/Makefile
	src/other/incrTcl/itcl/library/Makefile
	src/other/incrTcl/itcl/pkgIndex.tcl
	src/other/incrTcl/itk/Makefile
	src/other/incrTcl/itk/doc/Makefile
	src/other/incrTcl/itk/generic/Makefile
	src/other/incrTcl/itk/library/Makefile
	src/other/incrTcl/itk/pkgIndex.tcl
	src/other/incrTcl/tools/Makefile
	src/other/intaval/Makefile
	src/other/iwidgets/Makefile
	src/other/iwidgets/doc/Makefile
	src/other/iwidgets/generic/Makefile
	src/other/iwidgets/iwidgets.tcl
	src/other/iwidgets/pkgIndex.tcl
	src/other/jove/Makefile
	src/other/jove/teach-jove
	src/other/libpng/Makefile
	src/other/libregex/Makefile
	src/other/libtermlib/Makefile
	src/other/libutahrle/Makefile
	src/other/libutahrle/include/Makefile
	src/other/libz/Makefile
	src/other/openNURBS/Makefile
	src/other/tcl/Makefile
	src/other/tk/Makefile
	src/other/tkimg/Makefile
	src/other/tkimg/base/Makefile
	src/other/tkimg/png/Makefile
	src/other/tkimg/pngtcl/Makefile
	src/other/tkimg/zlibtcl/Makefile
	src/other/tnt/Makefile
	src/proc-db/Makefile
	src/remrt/Makefile
	src/rt/Makefile
	src/rttherm/Makefile
	src/sig/Makefile
	src/tab/Makefile
	src/tclscripts/Makefile
	src/tclscripts/archer/Makefile
	src/tclscripts/archer/images/Makefile
	src/tclscripts/archer/images/Themes/Makefile
	src/tclscripts/archer/images/Themes/Crystal/Makefile
	src/tclscripts/archer/images/Themes/Crystal_Large/Makefile
	src/tclscripts/archer/images/Themes/Windows/Makefile
	src/tclscripts/geometree/Makefile
	src/tclscripts/lib/Makefile
	src/tclscripts/mged/Makefile
	src/tclscripts/nirt/Makefile
	src/tclscripts/pl-dm/Makefile
	src/tclscripts/rtwizard/Makefile
	src/tclscripts/rtwizard/examples/Makefile
	src/tclscripts/rtwizard/examples/PictureTypeA/Makefile
	src/tclscripts/rtwizard/examples/PictureTypeB/Makefile
	src/tclscripts/rtwizard/examples/PictureTypeC/Makefile
	src/tclscripts/rtwizard/examples/PictureTypeD/Makefile
	src/tclscripts/rtwizard/examples/PictureTypeE/Makefile
	src/tclscripts/rtwizard/examples/PictureTypeF/Makefile
	src/tclscripts/rtwizard/lib/Makefile
	src/tclscripts/sdialogs/Makefile
	src/tclscripts/sdialogs/scripts/Makefile
	src/tclscripts/swidgets/Makefile
	src/tclscripts/swidgets/images/Makefile
	src/tclscripts/swidgets/scripts/Makefile
	src/tclscripts/util/Makefile
	src/util/Makefile
	src/vas4/Makefile
	src/vdeck/Makefile
	src/vfont/Makefile
])

AC_OUTPUT

# ac_top_builddir and other variables are modified after AC_OUTPUT so
# plan accordingly and save them beforehand.
ac_configure_args="$bc_configure_args"

# patch libtool if it has one of several common bugs and/or busted
# default configurations (e.g. Debian)
BC_PATCH_LIBTOOL


dnl
dnl Expand the variables for summary reporting
dnl
prefix=`eval "echo $prefix"`
prefix=`eval "echo $prefix"`
bindir=`eval "echo $bindir"`
bindir=`eval "echo $bindir"`
sysconfdir=`eval "echo $sysconfdir"`
sysconfdir=`eval "echo $sysconfdir"`
mandir=`eval "echo $mandir"`
mandir=`eval "echo $mandir"`
datadir=`eval "echo $datadir"`
datadir=`eval "echo $datadir"`

dnl
dnl Compute configuration time elapsed
dnl
if test -x "${srcdir}/sh/elapsed.sh" ; then
	time_elapsed="`${srcdir}/sh/elapsed.sh $CONFIG_TIME`"
else
	time_elapsed="unknown"
fi


# AC_OUTPUT won't update the brlcad_config.h.in template timestamp if
# the file is unchanged.  forcibly update the timestamp so autoheader
# doesn't try to invoke.
if test ! "x`cat include/brlcad_config.h.in`" = "x" ; then
    touch include/brlcad_config.h.in
fi


dnl **********************
dnl *** Report Summary ***
dnl **********************

AC_MSG_RESULT([Done.])
AC_MSG_RESULT([])
BC_BOLD
AC_MSG_RESULT([BRL-CAD Release $BRLCAD_VERSION, Build $CONFIG_DATE])
BC_UNBOLD
AC_MSG_RESULT([])
AC_MSG_RESULT([             Prefix: ${bc_prefix}])
AC_MSG_RESULT([           Binaries: ${bindir}])
AC_MSG_RESULT([       Manual pages: ${mandir}])
AC_MSG_RESULT([Configuration files: ${sysconfdir}])
AC_MSG_RESULT([Data resource files: ${bc_data_dir}])
if test ! "x$BC_ARGS" = "x" ; then
AC_MSG_RESULT([Options & variables: $BC_ARGS])
fi
AC_MSG_RESULT([])
AC_MSG_RESULT([CC       = ${CC}])
AC_MSG_RESULT([CXX      = ${CXX}])
if test ! "x$CFLAGS" = "x" ; then
AC_MSG_RESULT([CFLAGS   = ${CFLAGS}])
fi
if test ! "x$CXXFLAGS" = "x" ; then
AC_MSG_RESULT([CXXFLAGS = ${CXXFLAGS}])
fi
if test ! "x$CPPFLAGS" = "x" ; then
AC_MSG_RESULT([CPPFLAGS = ${CPPFLAGS}])
fi
if test ! "x$LDFLAGS" = "x" ; then
AC_MSG_RESULT([LDFLAGS  = ${LDFLAGS}])
fi
if test ! "x$LIBS" = "x" ; then
AC_MSG_RESULT([LIBS     = ${LIBS}])
fi
AC_MSG_RESULT([])
AC_MSG_RESULT([Build Tcl ............................: $build_brlcad_tcl])
AC_MSG_RESULT([Build Tk .............................: $build_brlcad_tk])
AC_MSG_RESULT([Build Itcl/Itk .......................: $build_brlcad_itcl])
AC_MSG_RESULT([Build IWidgets .......................: $build_brlcad_iwidgets])
AC_MSG_RESULT([Build BLT ............................: $build_brlcad_blt])
AC_MSG_RESULT([Build tkImg ..........................: $build_brlcad_tkimg])
AC_MSG_RESULT([Build libpng .........................: $build_brlcad_png])
AC_MSG_RESULT([Build libregex .......................: $build_brlcad_regex])
AC_MSG_RESULT([Build zlib ...........................: $build_brlcad_zlib])
AC_MSG_RESULT([Build termlib ........................: $build_brlcad_termlib])
AC_MSG_RESULT([Build Utah Raster Toolkit.............: $build_brlcad_urt])
AC_MSG_RESULT([Build Template Numerical Toolkit......: $build_brlcad_tnt])
AC_MSG_RESULT([Build openNURBS.......................: $build_brlcad_opennurbs])
AC_MSG_RESULT([Build jove ...........................: $build_brlcad_jove])
AC_MSG_RESULT([])
AC_MSG_RESULT([X11 support ..........................: $build_against_x11])
AC_MSG_RESULT([OpenGL support .......................: $build_against_opengl])
AC_MSG_RESULT([Java Developer Kit support ...........: $build_against_java])
AC_MSG_RESULT([Enable run-time debugging ............: $bc_build_runtime_debug])
AC_MSG_RESULT([])
AC_MSG_RESULT([Build 64-bit release .................: $build_brlcad_64bit])
AC_MSG_RESULT([Build optimized release ..............: $bc_use_optimized])
AC_MSG_RESULT([Build debug release ..................: $bc_use_debug])
AC_MSG_RESULT([Build profile release ................: $bc_use_profiling])
AC_MSG_RESULT([Build SMP-capable release ............: $bc_build_parallel])
AC_MSG_RESULT([Build static libraries ...............: $enable_static])
AC_MSG_RESULT([Build shared/dynamic libraries .......: $enable_shared])
AC_MSG_RESULT([Print verbose compilation warnings ...: $bc_build_warnings])
AC_MSG_RESULT([Print verbose compilation progress ...: $bc_build_progress])
AC_MSG_RESULT([])
AC_MSG_RESULT([Only build benchmark suite ...........: $bc_only_benchmark])
AC_MSG_RESULT([Only build librtserver ...............: $bc_only_rts])
AC_MSG_RESULT([Install example geometry models ......: $bc_install_geometry])
AC_MSG_RESULT([])
if test "x$time_elapsed" != "xunknown" ; then
AC_MSG_RESULT([Elapsed configuration time ...........: $time_elapsed])
fi
AC_MSG_RESULT([---])
AC_MSG_RESULT([$0 complete, type 'make' to begin building])
AC_MSG_RESULT([])

# Local Variables:
# tab-width: 8
# mode: autoconf
# sh-indentation: 4
# sh-basic-offset: 4
# indent-tabs-mode: t
# End:
# ex: shiftwidth=4 tabstop=8
blob
data 5090
						 -*- coding: utf-8 -*-
BRL-CAD Deprecation Log
=======================

Included below is a deprecation log and notes for BRL-CAD API changes
that potentially impact developers.  The general practice is that
public API changes may go from deprecated to obsolete during one of
the following events:

a) during a major release
    (e.g. going from 7.*.* to 8.*.*)
b) during a minor release provided that
    1) change was publicly announced as deprecated beforehand
    2) sufficient deprecation warning was been given
	i) at least three minor releases have passed since deprecation
	ii) at least three months have passed since deprecation
c) during a minor release provided that
    1) the API was never publicly announced or otherwise documented
    2) the interface was declared in a public header
    3) there exists a an equivalent alternative interface
    (e.g. changing the name of a function)

Otherwise, changes to interfaces that are never publicly announced,
are not part of publicly available documentation, and are not in
public headers are fair game to implement as needed at any time.

If a change will intentionally replace or remove routines, then those
routines should be then marked as deprecated first.  If the change is
"minimally impacting", i.e. a change to a non-critical routine that
has a suitable and completely equivalent alternative, can generally be
changed during minor releases.  An example of minimally impacting
changes include modifications like adding a new parameter to a
function or renaming a non-critical function.  Critical functions are
those related directly to geometry creation, loading, processing, and
ray-tracing; as well as the common library facilities in bu and bn.

Marking routines as deprecated can be done during compile-time with
#warning pre-processor declarations or during run-time with print
statements.

The items listed below are items that are deprecated or obsolete,
categorized by the release in which the change was made.  If the
change involved a rename/removal of a routine, both the original and
new names should be listed for reference.


**************
* DEPRECATED *
**************
7.12
----
include/raytrace.h
	rt_functab size -> growing ft_label and new callbacks [deprecated 7.12]
include/vmath.h
	M_SQRT2_DIV2 -> M_SQRT1_2
srt/librt/cmd.c
	rt_split_cmd() -> bu_argv_from_string() [deprecated 7.12]
src/rt/viewarea.c
	terminology and output format [deprecated 7.12]
include/wdb.h
	mk_fastgen_region() -> mk_comb() [deprecated 7.12]
src/libbu/parallel.c
	bu_get_load_average(), remove [deprecated 7.12]
src/vas4
	vas4, remove [deprecated 7.12]
include/raytrace.h
	RT_HIT_NORM -> RT_HIT_NORMAL [deprecated 7.12]

7.10
----
include/machine.h
	machine.h -> common.h && bu.h [deprecated 7.10]	
src/librt/bomb.c
	rt_bomb() -> bu_bomb() [deprecated 7.10]

pre 7.0
-------
include/raytrace.h
	RT_HIT_NORM -> RT_HIT_NORMAL [deprecated pre-7.0]
	struct hit.hit_point -> RT_HIT_POINT [deprecated pre-7.0]
	struct hit.hit_normal -> RT_HIT_NORMAL [deprecated pre-7.0]


************
* OBSOLETE *
************

7.12.4
------
include/raytrace.h
	removed iterator from NMG_CK_HITMISS_LIST
include/bu.h
	BU_QFLSTR -> BU_FLSTR

7.12.0
------
include/common.h
	NATURAL_IEEE -> bu_byteorder() == BU_BIG_ENDIAN || defined(WORDS_BIGENDIAN)
	REVERSE_IEEE -> bu_byteorder() == BU_LITTLE_ENDIAN
include/bu.h
	bu_log(char *, ...) -> bu_log(const char *, ...) [const]
	bu_flog(FILE *, char *, ...) -> bu_flog(FILE *, const char *, ...) [const]
	bu_vls_printf(struct bu_vls *, char *) -> bu_vls_printf(struct bu_vls *, const char *) [const]
	bu_vls_sprintf(struct bu_vls *, char *) -> bu_vls_sprintf(struct bu_vls *, const char *) [const]
include/wdb.h
	removed mk_poly() [deprecated pre-7.0]
	removed mk_polysolid() [deprecated pre-7.0]
	removed mk_fpoly() [deprecated pre-7.0]
	removed write_shell_as_polysolid() [deprecated 6.0]
include/bu.h
	char *bu_brlcad_path() -> const char *bu_brlcad_path() [const]
include/bn.h
	bn_mat_zero() -> MAT_ZERO() [deprecated pre-7.0]
	bn_mat_idn() -> MAT_IDN() [deprecated pre-7.0]
	bn_mat_copy() -> MAT_COPY() [deprecated pre-7.0]
include/compat4.h
	compat4.h -> bu.h && bn.h [deprecated 5.0]
include/raytrace.h
	rt_overlap_quietly() -> struct application.a_logoverlap = rt_silent_logoverlap [deprecated pre 7.0]
include/bu.h
	bu_brlcad_path() -> bu_brlcad_root() || bu_brlcad_data() [deprecated 7.4]
	bu_tcl_brlcad_path() -> bu_tcl_brlcad_root() || bu_tcl_brlcad_data() [deprecated 7.4]
include/fb.h
	fb_log(char *fmt) -> fb_log(const char *fmt) [const]
include/noalias-prag.h
	removed [non-stdc]
include/noalias.h
	removed [non-stdc]
src/librt/wdb_obj.c -> src/librt/db_obj.c
	removed wdb_tree_cmd(), added dgo_tree_cmd() [rename]


7.10.4
------
include/msr.h [pre 7.0]
	msr.h -> bu.h
include/rtlist.h [pre 7.0]
	rtlist.h -> bu.h
include/rtstring.h [pre 7.0]
	rtstring.h -> bu.h
include/shortvect.h [pre 7.0]
include/shortvect-pr.h [pre 7.0]

7.10.2
------
include/raytrace.h
	rt_version -> rt_version() [private]
include/[library].h (several)
	[library]_version -> [library]_version() [private]
blob
data 202434
/*                      R A Y T R A C E . H
 * BRL-CAD
 *
 * Copyright (c) 1993-2008 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @addtogroup librt */
/** @{ */
/** @file raytrace.h
 *
 * All the data structures and manifest constants necessary for
 * interacting with the BRL-CAD LIBRT ray-tracing library.
 *
 * Note that this header file defines many internal data structures,
 * as well as the library's external (interface) data structures.
 * These are provided for the convenience of applications builders.
 * However, the internal data structures are subject to change in each
 * release.
 *
 */

#ifndef __RAYTRACE_H__
#define __RAYTRACE_H__

#include "common.h"

/* interface headers */
#include "tcl.h"
#include "bu.h"
#include "bn.h"
#include "db5.h"
#include "nmg.h"

__BEGIN_DECLS

#ifndef RT_EXPORT
#  if defined(_WIN32) && !defined(__CYGWIN__) && defined(BRLCAD_DLL)
#    ifdef RT_EXPORT_DLL
#      define RT_EXPORT __declspec(dllexport)
#    else
#      define RT_EXPORT __declspec(dllimport)
#    endif
#  else
#    define RT_EXPORT
#  endif
#endif


/**
 * D E B U G
 *
 * Each type of debugging support is independently controled, by a
 * separate bit in the word RT_G_DEBUG
 *
 * For programs based on the "RT" program, these flags follow the "-x"
 * (lower case x) option.
 */
#define DEBUG_OFF	0	/**< @brief No debugging */

/* These definitions are each for one bit */

/* Options useful for debugging applications */
#define DEBUG_ALLRAYS	0x00000001	/**< @brief 1 Print calls to rt_shootray() */
#define DEBUG_ALLHITS	0x00000002	/**< @brief 2 Print partitions passed to a_hit() */
#define DEBUG_SHOOT	0x00000004	/**< @brief 3 Info about rt_shootray() processing */
#define DEBUG_INSTANCE	0x00000008	/**< @brief 4 regionid instance revectoring */

/* Options useful for debugging the database */
#define DEBUG_DB	0x00000010	/**< @brief 5 Database debugging */
#define DEBUG_SOLIDS	0x00000020	/**< @brief 6 Print prep'ed solids */
#define DEBUG_REGIONS	0x00000040	/**< @brief 7 Print regions & boolean trees */
#define DEBUG_ARB8	0x00000080	/**< @brief 8 Print voluminus ARB8 details */
#define DEBUG_SPLINE	0x00000100	/**< @brief 9 Splines */
#define DEBUG_ANIM	0x00000200	/**< @brief 10 Animation */
#define DEBUG_ANIM_FULL	0x00000400	/**< @brief 11 Animation matrices */
#define DEBUG_VOL	0x00000800	/**< @brief 12 Volume & opaque Binary solid */

/* Options useful for debugging the library */
#define DEBUG_ROOTS	0x00001000	/**< @brief 13 Print rootfinder details */
#define DEBUG_PARTITION	0x00002000	/**< @brief 14 Info about bool_weave() */
#define DEBUG_CUT	0x00004000	/**< @brief 15 Print space cutting statistics */
#define DEBUG_BOXING	0x00008000	/**< @brief 16 Object/box checking details */
#define DEBUG_MEM	0x00010000	/**< @brief 17 -->> BU_DEBUG_MEM_LOG */
#define DEBUG_MEM_FULL	0x00020000	/**< @brief 18 -->> BU_DEBUG_MEM_CHECK */
#define DEBUG_FDIFF	0x00040000	/**< @brief 19 bool/fdiff debugging */
#define DEBUG_PARALLEL	0x00080000	/**< @brief 20 -->> BU_DEBUG_PARALLEL */
#define DEBUG_CUTDETAIL	0x00100000	/**< @brief 21 Print space cutting details */
#define DEBUG_TREEWALK	0x00200000	/**< @brief 22 Database tree traversal */
#define DEBUG_TESTING	0x00400000	/**< @brief 23 One-shot debugging flag */
#define DEBUG_ADVANCE	0x00800000	/**< @brief 24 Cell-to-cell space partitioning */
#define DEBUG_MATH	0x01000000	/**< @brief 25 nmg math routines */

/* Options for debugging particular solids */
#define DEBUG_EBM	0x02000000	/**< @brief 26 Extruded bit-map solids */
#define DEBUG_HF	0x04000000	/**< @brief 27 Height Field solids */

/* Options which will cause the library to write binary debugging output */
#define DEBUG_PLOTSOLIDS 0x40000000	/**< @brief 31 plot all solids */
#define DEBUG_PLOTBOX	0x80000000	/**< @brief 32 Plot(3) bounding boxes and cuts */

/** Format string for bu_printb() */
#define DEBUG_FORMAT	\
"\020\040PLOTBOX\
\037PLOTSOLIDS\
\033HF\032EBM\031MATH\030ADVANCE\
\027TESTING\026TREEWALK\025CUTDETAIL\024PARALLEL\023FDIFF\022MEM_FULL\
\021MEM\020BOXING\017CUTTING\016PARTITION\015ROOTS\014VOL\
\013ANIM_FULL\012ANIM\011SPLINE\010ARB8\7REGIONS\6SOLIDS\5DB\
\4INSTANCE\3SHOOT\2ALLHITS\1ALLRAYS"

/**
 * It is necessary to have a representation of 1.0/0.0, or "infinity"
 * that fits within the dynamic range of the machine being used.  This
 * constant places an upper bound on the size object which can be
 * represented in the model.
 */
#ifdef INFINITY
#	undef INFINITY
#endif

#if defined(vax) || (defined(sgi) && !defined(mips))
#	define INFINITY	(1.0e20)	/* VAX limit is 10**37 */
#else
#	define INFINITY	(1.0e40)	/* IBM limit is 10**75 */
#endif

#define	RT_BADNUM(n)	(!((n) >= -INFINITY && (n) <= INFINITY))
#define RT_BADVEC(v)	(RT_BADNUM((v)[X]) || RT_BADNUM((v)[Y]) || RT_BADNUM((v)[Z]))

/*
 * Unfortunately, to prevent divide-by-zero, some tolerancing needs to
 * be introduced.
 *
 *
 * RT_LEN_TOL is the shortest length, in mm, that can be stood as the
 * dimensions of a primitive.  Can probably become at least
 * SQRT_SMALL_FASTF.
 *
 * Dot products smaller than RT_DOT_TOL are considered to have a dot
 * product of zero, i.e., the angle is effectively zero.  This is used
 * to check vectors that should be perpendicular.
 *
 * asin(0.1   ) = 5.73917 degrees
 * asin(0.01  ) = 0.572967
 * asin(0.001 ) = 0.0572958 degrees
 * asin(0.0001) = 0.00572958 degrees
 *
 * sin(0.01 degrees) = sin(0.000174 radians) = 0.000174533
 *
 * Many TGCs at least, in existing databases, will fail the
 * perpendicularity test if DOT_TOL is much smaller than 0.001, which
 * establishes a 1/20th degree tolerance.  The intent is to eliminate
 * grossly bad primitives, not pick nits.
 *
 * RT_PCOEF_TOL is a tolerance on polynomial coefficients to prevent
 * the root finder from having heartburn.
 */
#define RT_LEN_TOL	(1.0e-8)
#define RT_DOT_TOL	(0.001)
#define RT_PCOEF_TOL	(1.0e-10)


/**
 * R T _ T E S S _ T O L
 *
 * Tessellation (geometric) tolerances, different beasts than the
 * calcuation tolerance in bn_tol.
 */
struct rt_tess_tol  {
    unsigned long	magic;
    double		abs;			/**< @brief absolute dist tol */
    double		rel;			/**< @brief rel dist tol */
    double		norm;			/**< @brief normal tol */
};
#define RT_CK_TESS_TOL(_p)	BU_CKMAG(_p, RT_TESS_TOL_MAGIC, "rt_tess_tol")


/**
 * R T _ D B _ I N T E R N A L
 *
 * A handle on the internal format of an MGED database object.
 */
struct rt_db_internal  {
    unsigned long	idb_magic;
    int			idb_major_type;
    int			idb_minor_type;		/**< @brief ID_xxx */
    const struct rt_functab *idb_meth;	/**< @brief for ft_ifree(), etc. */
    genptr_t		idb_ptr;
    struct bu_attribute_value_set idb_avs;
};
#define idb_type		idb_minor_type
#define RT_INIT_DB_INTERNAL(_p)	{(_p)->idb_magic = RT_DB_INTERNAL_MAGIC; \
	(_p)->idb_type = -1; (_p)->idb_ptr = GENPTR_NULL;\
	(_p)->idb_avs.magic = -1;}
#define RT_CK_DB_INTERNAL(_p)	BU_CKMAG(_p, RT_DB_INTERNAL_MAGIC, "rt_db_internal")

/**
 * D B _ F U L L _ P A T H
 *
 * For collecting paths through the database tree
 */
struct db_full_path {
    unsigned long	magic;
    int			fp_len;
    int			fp_maxlen;
    struct directory **	fp_names;	/**< @brief array of dir pointers */
};
#define DB_FULL_PATH_POP(_pp)	{(_pp)->fp_len--;}
#define DB_FULL_PATH_CUR_DIR(_pp)	((_pp)->fp_names[(_pp)->fp_len-1])
#define DB_FULL_PATH_GET(_pp, _i)	((_pp)->fp_names[(_i)])
#define RT_CK_FULL_PATH(_p)	BU_CKMAG(_p, DB_FULL_PATH_MAGIC, "db_full_path")

/**
 * X R A Y
 *
 * All necessary information about a ray.
 * Not called just "ray" to prevent conflicts with VLD stuff.
 */
struct xray {
    unsigned long	magic;
    int			index;		/**< @brief Which ray of a bundle */
    point_t		r_pt;		/**< @brief Point at which ray starts */
    vect_t		r_dir;		/**< @brief Direction of ray (UNIT Length) */
    fastf_t		r_min;		/**< @brief entry dist to bounding sphere */
    fastf_t		r_max;		/**< @brief exit dist from bounding sphere */
};
#define RAY_NULL	((struct xray *)0)
#define RT_CK_RAY(_p)	BU_CKMAG(_p, RT_RAY_MAGIC, "struct xray");

/**
 * H I T
 *
 * Information about where a ray hits the surface
 *
 * Important Note:  Surface Normals always point OUT of a solid.
 *
 * DEPRECATED: The hit_point and hit_normal elements will be removed
 * from this structure, so as to separate the concept of the solid's
 * normal at the hit point from the post-boolean normal at the hit
 * point.
 */
struct hit {
    unsigned long	hit_magic;
    fastf_t		hit_dist;	/**< @brief dist from r_pt to hit_point */
    point_t		hit_point;	/**< @brief DEPRECATED: Intersection point, use VJOIN1 hit_dist */
    vect_t		hit_normal;	/**< @brief DEPRECATED: Surface Normal at hit_point, use RT_HIT_NORMAL */
    vect_t		hit_vpriv;	/**< @brief PRIVATE vector for xxx_*() */
    genptr_t		hit_private;	/**< @brief PRIVATE handle for xxx_shot() */
    int			hit_surfno;	/**< @brief solid-specific surface indicator */
    struct xray	*	hit_rayp;	/**< @brief pointer to defining ray */
};
#define HIT_NULL	((struct hit *)0)
#define RT_CK_HIT(_p)	BU_CKMAG(_p, RT_HIT_MAGIC, "struct hit")

/**
 * Old macro: DEPRECATED, use RT_HIT_NORMAL
 *
 * Only the hit_dist field of pt_inhit and pt_outhit are valid when
 * a_hit() is called; to compute both hit_point and hit_normal, use
 * RT_HIT_NORM() macro; to compute just hit_point, use 
 * VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
 */
#define RT_HIT_NORM( _hitp, _stp, _unused )  { \
	RT_CK_HIT(_hitp); \
	RT_CK_SOLTAB(_stp); \
	(_stp)->st_meth->ft_norm(_hitp, _stp, (_hitp)->hit_rayp); }

/**
 * New macro: Compute normal into (_hitp)->hit_normal, but leave it
 * un-flipped, as one hit may be shared between multiple partitions
 * with different flip status.
 *
 * Example: box.r = box.s - sph.s; sph.r = sph.s
 *
 * Return the post-boolean normal into caller-provided _normal vector.
 */
#define RT_HIT_NORMAL( _normal, _hitp, _stp, _unused, _flipflag )  { \
	RT_CK_HIT(_hitp); \
	RT_CK_SOLTAB(_stp); \
	RT_CK_FUNCTAB((_stp)->st_meth); \
	(_stp)->st_meth->ft_norm(_hitp, _stp, (_hitp)->hit_rayp); \
	if ( _flipflag )  { \
		VREVERSE( _normal, (_hitp)->hit_normal ); \
	} else { \
		VMOVE( _normal, (_hitp)->hit_normal ); \
	} \
 }

/* A more powerful interface would be: */
/* RT_GET_NORMAL( _normal, _partition, inhit/outhit flag, ap ) */


/**
 * C U R V A T U R E
 *
 * Information about curvature of the surface at a hit point.  The
 * principal direction pdir has unit length and principal curvature
 * c1.  |c1| <= |c2|, i.e. c1 is the most nearly flat principle
 * curvature.  A POSITIVE curvature indicates that the surface bends
 * TOWARD the (outward pointing) normal vector at that point.  c1 and
 * c2 are the inverse radii of curvature.  The other principle
 * direction is implied: pdir2 = normal x pdir1.
 */
struct curvature {
    vect_t	crv_pdir;	/**< @brief Principle direction */
    fastf_t	crv_c1;		/**< @brief curvature in principle dir */
    fastf_t	crv_c2;		/**< @brief curvature in other direction */
};
#define CURVE_NULL	((struct curvature *)0)

/**
 * Use this macro after having computed the normal, to compute the
 * curvature at a hit point.
 *
 * In Release 4.4 and earlier, this was called RT_CURVE().  When the
 * extra argument was added the name was changed.
 */
#define RT_CURVATURE( _curvp, _hitp, _flipflag, _stp )  { \
	RT_CK_HIT(_hitp); \
	RT_CK_SOLTAB(_stp); \
	RT_CK_FUNCTAB((_stp)->st_meth); \
	(_stp)->st_meth->ft_curve( _curvp, _hitp, _stp ); \
	if ( _flipflag )  { \
		(_curvp)->crv_c1 = - (_curvp)->crv_c1; \
		(_curvp)->crv_c2 = - (_curvp)->crv_c2; \
	} \
 }

/* A more powerful interface would be: */
/* RT_GET_CURVATURE(_curvp, _partition, inhit/outhit flag, ap) */

/**
 * U V C O O R D
 *
 * Mostly for texture mapping, information about parametric space.
 */
struct uvcoord {
    fastf_t uv_u;	/**< @brief Range 0..1 */
    fastf_t uv_v;	/**< @brief Range 0..1 */
    fastf_t uv_du;	/**< @brief delta in u */
    fastf_t uv_dv;	/**< @brief delta in v */
};
#define RT_HIT_UVCOORD( ap, _stp, _hitp, uvp )  { \
	RT_CK_HIT(_hitp); \
	RT_CK_SOLTAB(_stp); \
	RT_CK_FUNCTAB((_stp)->st_meth); \
	(_stp)->st_meth->ft_uv( ap, _stp, _hitp, uvp ); }

/* A more powerful interface would be: */
/* RT_GET_UVCOORD(_uvp, _partition, inhit/outhit flag, ap) */


/**
 * S E G
 *
 * Intersection segment.
 *
 * Includes information about both endpoints of intersection.
 * Contains forward link to additional intersection segments if the
 * intersection spans multiple segments (eg, shooting a ray through a
 * torus).
 */
struct seg {
    struct bu_list	l;
    struct hit		seg_in;		/**< @brief IN information */
    struct hit		seg_out;	/**< @brief OUT information */
    struct soltab *	seg_stp;	/**< @brief pointer back to soltab */
};
#define RT_SEG_NULL	((struct seg *)0)

#define RT_CHECK_SEG(_p)	BU_CKMAG(_p, RT_SEG_MAGIC, "struct seg")
#define RT_CK_SEG(_p)		BU_CKMAG(_p, RT_SEG_MAGIC, "struct seg")

#define RT_GET_SEG(p, res)    { \
	while ( !BU_LIST_WHILE((p), seg, &((res)->re_seg)) || !(p) ) \
		rt_get_seg(res); \
	BU_LIST_DEQUEUE( &((p)->l) ); \
	(p)->l.forw = (p)->l.back = BU_LIST_NULL; \
	(p)->seg_in.hit_magic = (p)->seg_out.hit_magic = RT_HIT_MAGIC; \
	res->re_segget++; }

#define RT_FREE_SEG(p, res)  { \
	RT_CHECK_SEG(p); \
	BU_LIST_INSERT( &((res)->re_seg), &((p)->l) ); \
	res->re_segfree++; }

/**
 * This could be
 *	BU_LIST_INSERT_LIST( &((_res)->re_seg), &((_segheadp)->l) )
 * except for security of checking & counting each element this way.
 */
#define RT_FREE_SEG_LIST( _segheadp, _res )	{ \
	register struct seg *_a; \
	while ( BU_LIST_WHILE( _a, seg, &((_segheadp)->l) ) )  { \
		BU_LIST_DEQUEUE( &(_a->l) ); \
		RT_FREE_SEG( _a, _res ); \
	} }

/**
 * Macros to operate on Right Rectangular Parallelpipeds (RPPs).
 * XXX move to vmath.h?
 */
struct bound_rpp {
    point_t min;
    point_t max;
};


/**
 * S O L T A B
 *
 * Internal information used to keep track of solids in the model.
 * Leaf name and Xform matrix are unique identifier.
 */
struct soltab {
    struct bu_list		l;		/**< @brief links, headed by rti_headsolid */
    struct bu_list		l2;		/**< @brief links, headed by st_dp->d_use_hd */
    const struct rt_functab *	st_meth;	/**< @brief pointer to per-solid methods */
    struct rt_i	*		st_rtip;	/**< @brief "up" pointer to rt_i */
    long			st_uses;	/**< @brief Usage count, for instanced solids */
    int				st_id;		/**< @brief Solid ident */
    point_t			st_center;	/**< @brief Centroid of solid */
    fastf_t			st_aradius;	/**< @brief Radius of APPROXIMATING sphere */
    fastf_t			st_bradius;	/**< @brief Radius of BOUNDING sphere */
    genptr_t			st_specific;	/**< @brief -> ID-specific (private) struct */
    const struct directory *	st_dp;		/**< @brief Directory entry of solid */
    point_t			st_min;		/**< @brief min X, Y, Z of bounding RPP */
    point_t			st_max;		/**< @brief max X, Y, Z of bounding RPP */
    long			st_bit;		/**< @brief solids bit vector index (const) */
    struct bu_ptbl		st_regions;	/**< @brief ptrs to regions using this solid (const) */
    matp_t			st_matp;	/**< @brief solid coords to model space, NULL=identity */
    struct db_full_path 	st_path;	/**< @brief path from region to leaf */
    /* Experimental stuff for accelerating "pieces" of solids */
    long			st_npieces;	/**< @brief #  pieces used by this solid */
    long			st_piecestate_num; /**< @brief re_pieces[] subscript */
    struct bound_rpp *		st_piece_rpps;	/**< @brief bounding RPP of each piece of this solid */
};
#define st_name		st_dp->d_namep
#define RT_SOLTAB_NULL	((struct soltab *)0)
#define	SOLTAB_NULL	RT_SOLTAB_NULL		/**< @brief backwards compat */

#define RT_CHECK_SOLTAB(_p)	BU_CKMAG( _p, RT_SOLTAB_MAGIC, "struct soltab")
#define RT_CK_SOLTAB(_p)	BU_CKMAG( _p, RT_SOLTAB_MAGIC, "struct soltab")

/*
 * Values for Solid ID.
 */
#define ID_NULL		0	/**< @brief Unused */
#define ID_TOR		1	/**< @brief Toroid */
#define ID_TGC		2	/**< @brief Generalized Truncated General Cone */
#define ID_ELL		3	/**< @brief Ellipsoid */
#define ID_ARB8		4	/**< @brief Generalized ARB.  V + 7 vectors */
#define ID_ARS		5	/**< @brief ARS */
#define ID_HALF		6	/**< @brief Half-space */
#define ID_REC		7	/**< @brief Right Elliptical Cylinder [TGC special] */
#define ID_POLY		8	/**< @brief Polygonal facted object */
#define ID_BSPLINE	9	/**< @brief B-spline object */
#define ID_SPH		10	/**< @brief Sphere */
#define	ID_NMG		11	/**< @brief n-Manifold Geometry solid */
#define ID_EBM		12	/**< @brief Extruded bitmap solid */
#define ID_VOL		13	/**< @brief 3-D Volume */
#define ID_ARBN		14	/**< @brief ARB with N faces */
#define ID_PIPE		15	/**< @brief Pipe (wire) solid */
#define ID_PARTICLE	16	/**< @brief Particle system solid */
#define ID_RPC		17	/**< @brief Right Parabolic Cylinder  */
#define ID_RHC		18	/**< @brief Right Hyperbolic Cylinder  */
#define ID_EPA		19	/**< @brief Elliptical Paraboloid  */
#define ID_EHY		20	/**< @brief Elliptical Hyperboloid  */
#define ID_ETO		21	/**< @brief Elliptical Torus  */
#define ID_GRIP		22	/**< @brief Pseudo Solid Grip */
#define ID_JOINT	23	/**< @brief Pseudo Solid/Region Joint */
#define ID_HF		24	/**< @brief Height Field */
#define ID_DSP		25	/**< @brief Displacement map */
#define	ID_SKETCH	26	/**< @brief 2D sketch */
#define	ID_EXTRUDE	27	/**< @brief Solid of extrusion */
#define ID_SUBMODEL	28	/**< @brief Instanced submodel */
#define	ID_CLINE	29	/**< @brief FASTGEN4 CLINE solid */
#define	ID_BOT		30	/**< @brief Bag o' triangles */

/* Add a new primitive id above here (this is will break v5 format)
 * XXX must update the non-geometric object id's below XXX
 */
#define	ID_MAX_SOLID	39	/**< @brief Maximum defined ID_xxx for solids */

/*
 * Non-geometric objects
 */
#define ID_COMBINATION	31	/**< @brief Combination Record */
#define ID_BINEXPM	32	/**< @brief Experimental binary */
#define ID_BINUNIF	33	/**< @brief Uniform-array binary */
#define ID_BINMIME	34	/**< @brief MIME-typed binary */

/* XXX - superellipsoid should be 31, but is not v5 compatible */
#define ID_SUPERELL	35	/**< @brief Superquadratic ellipsoid */
#define ID_METABALL	36	/**< @brief Metaball */
#define ID_BREP         37      /**< @brief B-rep object */
#define ID_HYP		38	/**< @brief Hyperboloid of one sheet */

#define ID_MAXIMUM	39	/**< @brief Maximum defined ID_xxx value */

/**
 * M A T E R _ I N F O
 */
struct mater_info {
    float	ma_color[3];	/**< @brief explicit color:  0..1  */
    float	ma_temperature;	/**< @brief positive ==> degrees Kelvin */
    char	ma_color_valid;	/**< @brief non-0 ==> ma_color is non-default */
    char	ma_cinherit;	/**< @brief color: DB_INH_LOWER / DB_INH_HIGHER */
    char	ma_minherit;	/**< @brief mater: DB_INH_LOWER / DB_INH_HIGHER */
    char	*ma_shader;	/**< @brief shader name & parms */
};

/**
 * R E G I O N
 *
 * The region structure.
 */
struct region  {
    struct bu_list	l;		/**< @brief magic # and doubly linked list */
    const char *	reg_name;	/**< @brief Identifying string */
    union tree *	reg_treetop;	/**< @brief Pointer to boolean tree */
    int			reg_bit;	/**< @brief constant index into Regions[] */
    int			reg_regionid;	/**< @brief Region ID code.  If <=0, use reg_aircode */
    int			reg_aircode;	/**< @brief Region ID AIR code */
    int			reg_gmater;	/**< @brief GIFT Material code */
    int			reg_los;	/**< @brief approximate line-of-sight thickness equivalence */
    struct mater_info	reg_mater;	/**< @brief Real material information */
    genptr_t		reg_mfuncs;	/**< @brief User appl. funcs for material */
    genptr_t		reg_udata;	/**< @brief User appl. data for material */
    int			reg_transmit;	/**< @brief flag:  material transmits light */
    long		reg_instnum;	/**< @brief instance number, from d_uses */
    short		reg_all_unions;	/**< @brief 1=boolean tree is all unions */
    short		reg_is_fastgen;	/**< @brief FASTGEN-compatability mode? */
#define REGION_NON_FASTGEN	0
#define REGION_FASTGEN_PLATE	1
#define REGION_FASTGEN_VOLUME	2
    struct bu_mro **	attr_values;	/**< @brief Null terminated array of MRO structs
					 * Each containing a value for the corresponding
					 * attribute name passed to rt_gettrees_and_attrs() */
};
#define REGION_NULL	((struct region *)0)
#define RT_CK_REGION(_p)	BU_CKMAG(_p, RT_REGION_MAGIC, "struct region")

/**
 * P A R T I T I O N
 *
 * Partitions of a ray.  Passed from rt_shootray() into user's a_hit()
 * function.
 *
 * Not changed to a bu_list for backwards compatability, but you can
 * iterate the whole list by writing:
 *
 * for ( BU_LIST_FOR( pp, partition, (struct bu_list *)PartHeadp ) )
 */

struct partition {
    /* This can be thought of and operated on as a struct bu_list */
    unsigned long	pt_magic;	/**< @brief sanity check */
    struct partition *	pt_forw;	/**< @brief forwards link */
    struct partition *	pt_back;	/**< @brief backwards link */
    struct seg *	pt_inseg;	/**< @brief IN seg ptr (gives stp) */
    struct hit *	pt_inhit;	/**< @brief IN hit pointer */
    struct seg *	pt_outseg;	/**< @brief OUT seg pointer */
    struct hit *	pt_outhit;	/**< @brief OUT hit ptr */
    struct region *	pt_regionp;	/**< @brief ptr to containing region */
    char		pt_inflip;	/**< @brief flip inhit->hit_normal */
    char		pt_outflip;	/**< @brief flip outhit->hit_normal */
    struct region **	pt_overlap_reg;	/**< @brief NULL-terminated array of overlapping regions.  NULL if no overlap. */
    struct bu_ptbl	pt_seglist;	/**< @brief all segs in this partition */
};
#define PT_NULL		((struct partition *)0)

#define RT_CHECK_PT(_p)	RT_CK_PT(_p)	/**< @brief compat */
#define RT_CK_PT(_p)	BU_CKMAG(_p, PT_MAGIC, "struct partition")
#define RT_CK_PARTITION(_p)	BU_CKMAG(_p, PT_MAGIC, "struct partition")
#define RT_CK_PT_HD(_p)	BU_CKMAG(_p, PT_HD_MAGIC, "struct partition list head")

/* Macros for copying only the essential "middle" part of a partition struct */
#define RT_PT_MIDDLE_START	pt_inseg		/**< @brief 1st elem to copy */
#define RT_PT_MIDDLE_END	pt_seglist.l.magic	/**< @brief copy up to this elem (non-inclusive) */
#define RT_PT_MIDDLE_LEN(p) \
	(((char *)&(p)->RT_PT_MIDDLE_END) - ((char *)&(p)->RT_PT_MIDDLE_START))

#define RT_DUP_PT(ip, new, old, res)	{ \
	GET_PT(ip, new, res); \
	memcpy((char *)(&(new)->RT_PT_MIDDLE_START), (char *)(&(old)->RT_PT_MIDDLE_START), RT_PT_MIDDLE_LEN(old)); \
	(new)->pt_overlap_reg = NULL; \
	bu_ptbl_cat( &(new)->pt_seglist, &(old)->pt_seglist );  }

/** Clear out the pointers, empty the hit list */
#define GET_PT_INIT(ip, p, res)	{\
	GET_PT(ip, p, res); \
	memset(((char *) &(p)->RT_PT_MIDDLE_START), 0, RT_PT_MIDDLE_LEN(p)); }

#define GET_PT(ip, p, res)   { \
	if ( BU_LIST_NON_EMPTY_P(p, partition, &res->re_parthead) )  { \
		BU_LIST_DEQUEUE((struct bu_list *)(p)); \
		bu_ptbl_reset( &(p)->pt_seglist ); \
	} else { \
		(p) = (struct partition *)bu_calloc(1, sizeof(struct partition), "struct partition"); \
		(p)->pt_magic = PT_MAGIC; \
		bu_ptbl_init( &(p)->pt_seglist, 42, "pt_seglist ptbl" ); \
		(res)->re_partlen++; \
	} \
	res->re_partget++; }

#define FREE_PT(p, res)  { \
	BU_LIST_APPEND( &(res->re_parthead), (struct bu_list *)(p) ); \
	if ( (p)->pt_overlap_reg )  { \
		bu_free( (genptr_t)((p)->pt_overlap_reg), "pt_overlap_reg" );\
		(p)->pt_overlap_reg = NULL; \
	} \
	res->re_partfree++; }

#define RT_FREE_PT_LIST( _headp, _res )		{ \
		register struct partition *_pp, *_zap; \
		for ( _pp = (_headp)->pt_forw; _pp != (_headp);  )  { \
			_zap = _pp; \
			_pp = _pp->pt_forw; \
			BU_LIST_DEQUEUE( (struct bu_list *)(_zap) ); \
			FREE_PT(_zap, _res); \
		} \
		(_headp)->pt_forw = (_headp)->pt_back = (_headp); \
	}

/** Insert "new" partition in front of "old" partition.  Note order change */
#define INSERT_PT(_new, _old)	BU_LIST_INSERT((struct bu_list *)_old, (struct bu_list *)_new)

/** Append "new" partition after "old" partition.  Note arg order change */
#define APPEND_PT(_new, _old)	BU_LIST_APPEND((struct bu_list *)_old, (struct bu_list *)_new)

/** Dequeue "cur" partition from doubly-linked list */
#define DEQUEUE_PT(_cur)	BU_LIST_DEQUEUE((struct bu_list *)_cur)

/**
 * C U T
 *
 * Structure for space subdivision.
 *
 * cut_type is an integer for efficiency of access in rt_shootray() on
 * non-word addressing machines.
 *
 * If a solid has 'pieces', it will be listed either in bn_list
 * (initially), or in bn_piecelist, but not both.
 */
union cutter  {
#define CUT_CUTNODE	1
#define CUT_BOXNODE	2
#define CUT_NUGRIDNODE	3
#define	CUT_MAXIMUM	3
    int	cut_type;
    union cutter *cut_forw;		/**< @brief Freelist forward link */
    struct cutnode  {
	int		cn_type;
	int		cn_axis;	/**< @brief 0, 1, 2 = cut along X, Y, Z */
	fastf_t		cn_point;	/**< @brief cut through axis==point */
	union cutter *	cn_l;		/**< @brief val < point */
	union cutter *	cn_r;		/**< @brief val >= point */
    } cn;
    struct boxnode  {
	int		bn_type;
	fastf_t		bn_min[3];
	fastf_t		bn_max[3];
	struct soltab **bn_list;	/**< @brief bn_list[bn_len] */
	int		bn_len;		/**< @brief # of solids in list */
	int		bn_maxlen;	/**< @brief # of ptrs allocated to list */
	struct rt_piecelist *bn_piecelist; /**< @brief [] solids with pieces */
	int		bn_piecelen;	/**< @brief # of piecelists used */
	int		bn_maxpiecelen; /**< @brief # of piecelists allocated */
    } bn;
    struct nugridnode {
	int nu_type;
	struct nu_axis {
	    fastf_t	nu_spos;	/**< @brief cell start position */
	    fastf_t	nu_epos;	/**< @brief cell end position */
	    fastf_t	nu_width;	/**< @brief voxel size (end - start) */
	} *nu_axis[3];
	int nu_cells_per_axis[3];	/**< @brief number of slabs */
	int nu_stepsize[3];		/**< @brief number of cells to jump for one step in each axis */
	union cutter *nu_grid;		/**< @brief 3-D array of boxnodes */
    } nugn;
};

#define CUTTER_NULL	((union cutter *)0)

/**
 * M E M _ M A P
 *
 * These structures are used to manage internal resource maps.
 * Typically these maps describe some kind of memory or file space.
 */
struct mem_map {
    struct mem_map *m_nxtp;	/**< @brief Linking pointer to next element */
    unsigned m_size;		/**< @brief Size of this free element */
    unsigned long m_addr;	/**< @brief Address of start of this element */
};
#define MAP_NULL	((struct mem_map *) 0)


/**
 * The directory is organized as forward linked lists hanging off of
 * one of RT_DBNHASH headers in the db_i structure.
 */
#define	RT_DBNHASH		1024	/**< @brief size of hash table */

#if	((RT_DBNHASH)&((RT_DBNHASH)-1)) != 0
#define	RT_DBHASH(sum)	((unsigned)(sum) % (RT_DBNHASH))
#else
#define	RT_DBHASH(sum)	((unsigned)(sum) & ((RT_DBNHASH)-1))
#endif

/**
 * D B _ I
 *
 * One of these structures is used to describe each separate instance
 * of a BRL-CAD model database ".g" file.
 *
 * dbi_filepath is a C-style argv array of places to search when
 * opening related files (such as data files for EBM solids or
 * texture-maps).  The array and strings are all dynamically
 * allocated.
 */
struct db_i  {
    unsigned long		dbi_magic;	/**< @brief magic number */
    /* THESE ELEMENTS ARE AVAILABLE FOR APPLICATIONS TO READ */
    char *			dbi_filename;	/**< @brief file name */
    int				dbi_read_only;	/**< @brief !0 => read only file */
    double			dbi_local2base;	/**< @brief local2mm */
    double			dbi_base2local;	/**< @brief unit conversion factors */
    char *			dbi_title;	/**< @brief title from IDENT rec */
    char *const*		dbi_filepath;	/**< @brief search path for aux file opens (convenience var) */
    /* THESE ELEMENTS ARE FOR LIBRT ONLY, AND MAY CHANGE */
    struct directory *		dbi_Head[RT_DBNHASH];
    FILE *			dbi_fp;		/**< @brief standard file pointer */
    long			dbi_eof;	/**< @brief End+1 pos after db_scan() */
    long			dbi_nrec;	/**< @brief # records after db_scan() */
    int				dbi_uses;	/**< @brief # of uses of this struct */
    struct mem_map *		dbi_freep;	/**< @brief map of free granules */
    genptr_t			dbi_inmem;	/**< @brief ptr to in-memory copy */
    struct animate *		dbi_anroot;	/**< @brief heads list of anim at root lvl */
    struct bu_mapped_file *	dbi_mf;		/**< @brief Only in read-only mode */
    struct bu_ptbl		dbi_clients;	/**< @brief List of rtip's using this db_i */
    int				dbi_version;	/**< @brief 4 or 5 */
    struct rt_wdb *		dbi_wdbp;	/**< @brief ptr back to containing rt_wdb */
};
#define DBI_NULL	((struct db_i *)0)

#define RT_CHECK_DBI(_p)		BU_CKMAG(_p, DBI_MAGIC, "struct db_i")
#define RT_CHECK_DBI_TCL(_interp, _p)	BU_CKMAG_TCL(_interp, _p, DBI_MAGIC, "struct db_i")
#define RT_CK_DBI(_p)			RT_CHECK_DBI(_p)
#define RT_CK_DBI_TCL(_interp, _p)	RT_CHECK_DBI_TCL(_interp, _p)

/**
 * D I R E C T O R Y
 *
 * One of these structures is allocated in memory to represent each
 * named object in the database.
 *
 * Note that a d_addr of RT_DIR_PHONY_ADDR (-1L) means that database
 * storage has not been allocated yet.
 *
 * Note that there is special handling for RT_DIR_INMEM "in memory"
 * overrides.
 *
 * Construction should be done only by using RT_GET_DIRECTORY()
 * Destruction should be done only by using db_dirdelete().
 *
 * Special note: In order to reduce the overhead of calling
 * bu_malloc() (really bu_strdup()) to stash the name in d_namep, we
 * carry along enough storage for small names right in the structure
 * itself (d_shortname).  Thus, d_namep should never be assigned to
 * directly, it should always be accessed using RT_DIR_SET_NAMEP() and
 * RT_DIR_FREE_NAMEP().
 *
 * The in-memory name of an object should only be changed using
 * db_rename(), so that it can be requeued on the correct linked list,
 * based on new hash.  This should be followed by rt_db_put_internal()
 * on the object to modify the on-disk name.
 */
struct directory  {
    unsigned long	d_magic;		/**< @brief Magic number */
    char *		d_namep;		/**< @brief pointer to name string */
    union {
	long		file_offset;		/**< @brief disk address in obj file */
	genptr_t	ptr;			/**< @brief ptr to in-memory-only obj */
    } d_un;
    struct directory *	d_forw;			/**< @brief link to next dir entry */
    struct animate *	d_animate;		/**< @brief link to animation */
    long		d_uses;			/**< @brief # uses, from instancing */
    long		d_len;			/**< @brief # of db granules used */
    long		d_nref;			/**< @brief # times ref'ed by COMBs */
    int			d_flags;		/**< @brief flags */
    unsigned char	d_major_type;		/**< @brief object major type */
    unsigned char 	d_minor_type;		/**< @brief object minor type */
    struct bu_list	d_use_hd;		/**< @brief heads list of uses (struct soltab l2) */
    char		d_shortname[16];	/**< @brief Stash short names locally */
};
#define DIR_NULL	((struct directory *)0)
#define RT_CK_DIR(_dp)	BU_CKMAG(_dp, RT_DIR_MAGIC, "(librt)directory")

#define d_addr	d_un.file_offset
#define RT_DIR_PHONY_ADDR	(-1L)	/**< @brief Special marker for d_addr field */

/* flags for db_diradd() and friends */
#define DIR_SOLID	0x1	/**< @brief this name is a solid */
#define DIR_COMB	0x2	/**< @brief combination */
#define DIR_REGION	0x4	/**< @brief region */
#define DIR_HIDDEN	0x8	/**< @brief object name is hidden */
#define	DIR_NON_GEOM	0x10	/**< @brief object is not geometry (e.g. binary object) */
#define DIR_USED	0x80	/**< @brief One bit, used similar to d_nref */
#define RT_DIR_INMEM	0x100	/**< @brief object is in memory (only) */

/**< @brief Args to db_lookup() */
#define LOOKUP_NOISY	1
#define LOOKUP_QUIET	0

#define FOR_ALL_DIRECTORY_START(_dp, _dbip)	{ int _i; \
	for ( _i = RT_DBNHASH-1; _i >= 0; _i-- )  { \
		for ( (_dp) = (_dbip)->dbi_Head[_i]; (_dp); (_dp) = (_dp)->d_forw )  {

#define FOR_ALL_DIRECTORY_END	}}}

#define RT_DIR_SET_NAMEP(_dp, _name)	{ \
	if ( strlen(_name) < sizeof((_dp)->d_shortname) )  {\
		bu_strlcpy( (_dp)->d_shortname, (_name), sizeof((_dp)->d_shortname) ); \
		(_dp)->d_namep = (_dp)->d_shortname; \
	} else { \
		(_dp)->d_namep = bu_strdup(_name); /* Calls bu_malloc() */ \
	} }

/** Use this macro to free the d_namep member, which is sometimes not
 * dynamic.
 */
#define RT_DIR_FREE_NAMEP(_dp)	{ \
	if ( (_dp)->d_namep != (_dp)->d_shortname )  \
		bu_free((_dp)->d_namep, "d_namep"); \
	(_dp)->d_namep = NULL; }


/**
 * allocate and link in a new directory entry to the resource
 * structure's freelist
 */
#define RT_GET_DIRECTORY(_p, _res)    { \
	while ( ((_p) = (_res)->re_directory_hd) == NULL ) \
		db_get_directory(_res); \
	(_res)->re_directory_hd = (_p)->d_forw; \
	(_p)->d_forw = NULL; }


/**
 * R T _ C O M B _ I N T E R N A L
 *
 * In-memory format for database "combination" record (non-leaf node).
 * (Regions and Groups are both a kind of Combination).  Perhaps move
 * to wdb.h or rtgeom.h?
 */
struct rt_comb_internal  {
    unsigned long	magic;
    union tree *	tree;		/**< @brief Leading to tree_db_leaf leaves */
    char		region_flag;	/**< @brief !0 ==> this COMB is a REGION */
    char		is_fastgen;	/**< @brief REGION_NON_FASTGEN/_PLATE/_VOLUME */
    /* Begin GIFT compatability */
    int			region_id;
    int			aircode;
    int			GIFTmater;
    int			los;
    /* End GIFT compatability */
    char		rgb_valid;	/**< @brief !0 ==> rgb[] has valid color */
    unsigned char	rgb[3];
    float		temperature;	/**< @brief > 0 ==> region temperature */
    struct bu_vls	shader;
    struct bu_vls	material;
    char		inherit;
};
#define RT_CHECK_COMB(_p)		BU_CKMAG( _p, RT_COMB_MAGIC, "rt_comb_internal" )
#define RT_CK_COMB(_p)			RT_CHECK_COMB(_p)
#define RT_CHECK_COMB_TCL(_interp, _p)	BU_CKMAG_TCL(interp, _p, RT_COMB_MAGIC, "rt_comb_internal" )
#define RT_CK_COMB_TCL(_interp, _p)	RT_CHECK_COMB_TCL(_interp, _p)

/**
 * R T _ B I N U N I F _ I N T E R N A L
 *
 * In-memory format for database uniform-array binary object.
 * Perhaps move to wdb.h or rtgeom.h?
 */
struct rt_binunif_internal {
    unsigned long	magic;
    int			type;
    long		count;
    union {
	float		*flt;
	double		*dbl;
	char		*int8;
	short		*int16;
	int	       	*int32;
	long		*int64;
	unsigned char	*uint8;
	unsigned short	*uint16;
	unsigned int	*uint32;
	unsigned long	*uint64;
    } u;
};
#define RT_CHECK_BINUNIF(_p)		BU_CKMAG( _p, RT_BINUNIF_INTERNAL_MAGIC, "rt_binunif_internal" )
#define RT_CK_BINUNIF(_p)		RT_CHECK_BINUNIF(_p)
#define RT_CHECK_BINUNIF_TCL(_interp, _p)	BU_CKMAG_TCL(interp, _p, RT_BINUNIF_MAGIC, "rt_binunif_internal" )
#define RT_CK_BINUNIF_TCL(_interp, _p)	RT_CHECK_BINUNIF_TCL(_interp, _p)

/**
 * D B _ T R E E _ S T A T E
 *
 * State for database tree walker db_walk_tree() and related
 * user-provided handler routines.
 */
struct db_tree_state {
    unsigned long	magic;
    struct db_i	*	ts_dbip;
    int			ts_sofar;		/**< @brief Flag bits */

    int			ts_regionid;	/**< @brief GIFT compat region ID code*/
    int			ts_aircode;	/**< @brief GIFT compat air code */
    int			ts_gmater;	/**< @brief GIFT compat material code */
    int			ts_los;		/**< @brief equivalent LOS estimate */
    struct mater_info	ts_mater;	/**< @brief material properties */

    /* XXX ts_mat should be a matrix pointer, not a matrix */
    mat_t		ts_mat;		/**< @brief transform matrix */
    int			ts_is_fastgen;	/**< @brief REGION_NON_FASTGEN/_PLATE/_VOLUME */
    struct bu_attribute_value_set	ts_attrs;	/**< @brief attribute/value structure */

    int			ts_stop_at_regions;	/**< @brief else stop at solids */
    int			(*ts_region_start_func) BU_ARGS((struct db_tree_state * /**< @brief tsp*/,
							 struct db_full_path * /**< @brief pathp*/,
							 const struct rt_comb_internal * /**< @brief combp */,
							 genptr_t client_data
							    ));
    union tree *	(*ts_region_end_func) BU_ARGS((struct db_tree_state * /**< @brief tsp*/,
						       struct db_full_path * /**< @brief pathp*/,
						       union tree * /**< @brief curtree*/,
						       genptr_t client_data
							  ));
    union tree *	(*ts_leaf_func) BU_ARGS((struct db_tree_state * /**< @brief tsp*/,
						 struct db_full_path * /**< @brief pathp*/,
						 struct rt_db_internal * /**< @brief ip*/,
						 genptr_t client_data
						    ));
    const struct rt_tess_tol *	ts_ttol;	/**< @brief  Tessellation tolerance */
    const struct bn_tol	*	ts_tol;		/**< @brief  Math tolerance */
    struct model **		ts_m;		/**< @brief  ptr to ptr to NMG "model" */
    struct rt_i *		ts_rtip;	/**< @brief  Helper for rt_gettrees() */
    struct resource *		ts_resp;	/**< @brief  Per-CPU data */
};
#define TS_SOFAR_MINUS	1	/**< @brief  Subtraction encountered above */
#define TS_SOFAR_INTER	2	/**< @brief  Intersection encountered above */
#define TS_SOFAR_REGION	4	/**< @brief  Region encountered above */

#define RT_CK_DBTS(_p)	BU_CKMAG(_p, RT_DBTS_MAGIC, "db_tree_state")

/**
 * D B _ T R A V E R S E
 *
 * State for database traversal functions.
 */
struct db_traverse
{
    unsigned long magic;
    struct db_i *dbip;
    void (*comb_enter_func) (
	struct db_i *,
	struct directory *,
	genptr_t);
    void (*comb_exit_func) (
	struct db_i *,
	struct directory *,
	genptr_t);
    void (*leaf_func) (
	struct db_i *,
	struct directory *,
	genptr_t);
    struct resource *resp;
    genptr_t client_data;
};
#define RT_INIT_DBTR(_p) {(_p)->magic = RT_DBTR_MAGIC; \
	(_p)->dbip = GENPTR_NULL; (_p)->comb_enter_func = GENPTR_NULL; \
	(_p)->comb_exit_func = GENPTR_NULL; (_p)->leaf_func = GENPTR_NULL; \
	(_p)->resp = GENPTR_NULL; (_p)->client_data = GENPTR_NULL;}
#define RT_CK_DBTR(_p) BU_CKMAG(_p, RT_DBTR_MAGIC, "db_traverse")

/**
 * C O M B I N E D _ T R E E _ S T A T E
 */
struct combined_tree_state {
    unsigned long		magic;
    struct db_tree_state	cts_s;
    struct db_full_path		cts_p;
};
#define RT_CK_CTS(_p)	BU_CKMAG(_p, RT_CTS_MAGIC, "combined_tree_state")

/**
 * T R E E
 *
 * Binary trees representing the Boolean operations between solids.
 */
#define MKOP(x)		(x)

#define OP_SOLID	MKOP(1)		/**< @brief  Leaf:  tr_stp -> solid */
#define OP_UNION	MKOP(2)		/**< @brief  Binary: L union R */
#define OP_INTERSECT	MKOP(3)		/**< @brief  Binary: L intersect R */
#define OP_SUBTRACT	MKOP(4)		/**< @brief  Binary: L subtract R */
#define OP_XOR		MKOP(5)		/**< @brief  Binary: L xor R, not both*/
#define OP_REGION	MKOP(6)		/**< @brief  Leaf: tr_stp -> combined_tree_state */
#define OP_NOP		MKOP(7)		/**< @brief  Leaf with no effect */
/* Internal to library routines */
#define OP_NOT		MKOP(8)		/**< @brief  Unary:  not L */
#define OP_GUARD	MKOP(9)		/**< @brief  Unary:  not L, or else! */
#define OP_XNOP		MKOP(10)	/**< @brief  Unary:  L, mark region */
#define OP_NMG_TESS	MKOP(11)	/**< @brief  Leaf: tr_stp -> nmgregion */
/* LIBWDB import/export interface to combinations */
#define OP_DB_LEAF	MKOP(12)	/**< @brief  Leaf of combination, db fmt */
#define OP_FREE		MKOP(13)	/**< @brief  Unary:  L has free chain */

union tree {
    unsigned long magic;				/**< @brief  First word: magic number */
    /* Second word is always OP code */
    struct tree_node {
	unsigned long	magic;
	int		tb_op;		/**< @brief  non-leaf */
	struct region	*tb_regionp;	/**< @brief  ptr to containing region */
	union tree	*tb_left;
	union tree	*tb_right;
    } tr_b;
    struct tree_leaf {
	unsigned long	magic;
	int		tu_op;		/**< @brief  leaf, OP_SOLID */
	struct region	*tu_regionp;	/**< @brief  ptr to containing region */
	struct soltab	*tu_stp;
    } tr_a;
    struct tree_cts {
	unsigned long	magic;
	int		tc_op;		/**< @brief  leaf, OP_REGION */
	struct region	*tc_pad;	/**< @brief  unused */
	struct combined_tree_state	*tc_ctsp;
    } tr_c;
    struct tree_nmgregion {
	unsigned long	magic;
	int		td_op;		/**< @brief  leaf, OP_NMG_TESS */
	const char	*td_name;	/**< @brief  If non-null, dynamic string describing heritage of this region */
	struct nmgregion *td_r;		/**< @brief  ptr to NMG region */
    } tr_d;
    struct tree_db_leaf  {
	unsigned long	magic;
	int		tl_op;		/**< @brief  leaf, OP_DB_LEAF */
	matp_t		tl_mat;		/**< @brief  xform matp, NULL ==> identity */
	char		*tl_name;	/**< @brief  Name of this leaf (bu_strdup'ed) */
    } tr_l;
};
/* Things which are in the same place in both A & B structures */
#define tr_op		tr_a.tu_op
#define tr_regionp	tr_a.tu_regionp

#define TREE_NULL	((union tree *)0)
#define RT_CK_TREE(_p)	BU_CKMAG(_p, RT_TREE_MAGIC, "union tree")


/**
 * R T _ T R E E _ A R R A Y
 *
 * flattened version of the union tree
 */
struct rt_tree_array
{
    union tree *tl_tree;
    int		tl_op;
};

#define TREE_LIST_NULL	((struct tree_list *)0)

/* Some dubious defines, to support the wdb_obj.c evolution */
#define RT_MAXARGS		9000
#define RT_MAXLINE		10240

/**
 * R T _ W D B
 *
 * This data structure is at the core of the "LIBWDB" support for
 * allowing application programs to read and write BRL-CAD databases.
 * Many different access styles are supported.
 */

struct rt_wdb  {
    struct bu_list	l;
    int			type;
    struct db_i	*	dbip;
    struct bu_vls	wdb_name;	/**< @brief  database object name */
    struct db_tree_state	wdb_initial_tree_state;
    struct rt_tess_tol	wdb_ttol;
    struct bn_tol	wdb_tol;
    struct resource*	wdb_resp;

    /* for catching log messages */
    struct bu_vls	wdb_log;

    void		*wdb_result;
    struct bu_vls	wdb_result_str;
    unsigned int	wdb_result_flags;

    /* variables for name prefixing */
    struct bu_vls	wdb_prestr;
    int			wdb_ncharadd;
    int			wdb_num_dups;

    /* default region ident codes for this particular database. */
    int			wdb_item_default;/**< @brief  GIFT region ID */
    int			wdb_air_default;
    int			wdb_mat_default;/**< @brief  GIFT material code */
    int			wdb_los_default;/**< @brief  Line-of-sight estimate */
    struct bu_observer	wdb_observers;
    Tcl_Interp *	wdb_interp;
};

#define RT_CHECK_WDB(_p)		BU_CKMAG(_p, RT_WDB_MAGIC, "rt_wdb")
#define RT_CHECK_WDB_TCL(_interp, _p)	BU_CKMAG_TCL(_interp, _p, RT_WDB_MAGIC, "rt_wdb")
#define RT_CK_WDB(_p)			RT_CHECK_WDB(_p)
#define RT_CK_WDB_TCL(_interp, _p)	RT_CHECK_WDB_TCL(_interp, _p)
#define RT_WDB_NULL		((struct rt_wdb *)NULL)
#define RT_WDB_TYPE_DB_DISK			2
#define RT_WDB_TYPE_DB_DISK_APPEND_ONLY		3
#define RT_WDB_TYPE_DB_INMEM			4
#define RT_WDB_TYPE_DB_INMEM_APPEND_ONLY	5


#define RT_MINVIEWSIZE 0.0001
#define RT_MINVIEWSCALE 0.00005

/**
 * A N I M A T E
 *
 * Each one of these structures specifies an arc in the tree that is
 * to be operated on for animation purposes.  More than one animation
 * operation may be applied at any given arc.  The directory structure
 * points to a linked list of animate structures (built by
 * rt_anim_add()), and the operations are processed in the order
 * given.
 */
struct anim_mat {
    int		anm_op;			/**< @brief  ANM_RSTACK, ANM_RARC... */
    mat_t	anm_mat;		/**< @brief  Matrix */
};
#define ANM_RSTACK	1		/**< @brief  Replace stacked matrix */
#define ANM_RARC	2		/**< @brief  Replace arc matrix */
#define ANM_LMUL	3		/**< @brief  Left (root side) mul */
#define ANM_RMUL	4		/**< @brief  Right (leaf side) mul */
#define ANM_RBOTH	5		/**< @brief  Replace stack, arc=Idn */

struct rt_anim_property {
    unsigned long	magic;
    int			anp_op;		/**< @brief  RT_ANP_REPLACE, etc */
    struct bu_vls	anp_shader;	/**< @brief  Update string */
};
#define RT_ANP_REPLACE	1		/**< @brief  Replace shader string */
#define RT_ANP_APPEND	2		/**< @brief  Append to shader string */
#define RT_CK_ANP(_p)	BU_CKMAG((_p), RT_ANP_MAGIC, "rt_anim_property")

struct rt_anim_color {
    int anc_rgb[3];			/**< @brief  New color */
};

struct animate {
    unsigned long	magic;		/**< @brief  magic number */
    struct animate *	an_forw;	/**< @brief  forward link */
    struct db_full_path an_path;	/**< @brief  (sub)-path pattern */
    int			an_type;	/**< @brief  AN_MATRIX, AN_COLOR... */
    union animate_specific {
	struct anim_mat		anu_m;
	struct rt_anim_property	anu_p;
	struct rt_anim_color	anu_c;
	float			anu_t;
    } an_u;
};
#define RT_AN_MATRIX      1		/**< @brief  Matrix animation */
#define RT_AN_MATERIAL    2		/**< @brief  Material property anim */
#define RT_AN_COLOR       3		/**< @brief  Material color anim */
#define RT_AN_SOLID       4		/**< @brief  Solid parameter anim */
#define RT_AN_TEMPERATURE 5		/**< @brief  Region temperature */

#define ANIM_NULL	((struct animate *)0)
#define RT_CK_ANIMATE(_p)	BU_CKMAG((_p), ANIMATE_MAGIC, "animate")

/**
 * R T _ H T B L
 *
 * Support for variable length arrays of "struct hit".
 * Patterned after the libbu/ptbl.c idea.
 */
struct rt_htbl {
    struct bu_list	l;	/**< @brief  linked list for caller's use */
    int			end;	/**< @brief  index of first available location */
    int			blen;	/**< @brief  # of struct's of storage at *hits */
    struct hit *	hits;	/**< @brief  hits[blen] data storage area */
};
#define RT_CK_HTBL(_p)	BU_CKMAG(_p, RT_HTBL_MAGIC, "rt_htbl")

/**
 * R T _ P I E C E S T A T E
 *
 * Holds onto memory re-used by rt_shootray() from shot to shot.
 * One of these for each solid which uses pieces.
 * There is a separate array of these for each cpu.
 * Storage for the bit vectors is pre-allocated at prep time.
 * The array is subscripted by st_piecestate_num.
 * The bit vector is subscripted by values found in rt_piecelist pieces[].
 */
struct rt_piecestate  {
    unsigned long	magic;
    long		ray_seqno;	/**< @brief  res_nshootray */
    struct soltab *	stp;
    struct bu_bitv *	shot;
    fastf_t		mindist;	/**< @brief  dist ray enters solids bounding volume */
    fastf_t		maxdist;	/**< @brief  dist ray leaves solids bounding volume */
    struct rt_htbl	htab;		/**< @brief  accumulating hits here */
    const union cutter *cutp;		/**< @brief  current bounding volume */
};
#define RT_CK_PIECESTATE(_p)	BU_CKMAG(_p, RT_PIECESTATE_MAGIC, "struct rt_piecestate")

/**
 * R T _ P I E C E L I S T
 *
 * For each space partitioning cell, there is one of these for each
 * solid in that cell which uses pieces.  Storage for the array is
 * allocated at cut time, and never changes.
 *
 * It is expected that the indices allocated by any solid range from
 * 0..(npieces-1).
 *
 * The piece indices are used as a subscript into a solid-specific
 * table, and also into the 'shot' bitv of the corresponding
 * rt_piecestate.
 *
 * The values (subscripts) in pieces[] are specific to a single solid
 * (stp).
 */
struct rt_piecelist  {
    unsigned long	magic;
    long		npieces;	/**< @brief  number of pieces in pieces[] array */
    long		*pieces;	/**< @brief  pieces[npieces], piece indices */
    struct soltab	*stp;		/**< @brief  ref back to solid */
};
#define RT_CK_PIECELIST(_p)	BU_CKMAG(_p, RT_PIECELIST_MAGIC, "struct rt_piecelist")

/* Used to set globals declared in g_bot.c */
#define RT_DEFAULT_MINPIECES		32
#define RT_DEFAULT_TRIS_PER_PIECE	4

/**
 * R E S O U R C E
 *
 * Per-CPU statistics and resources.
 *
 * One of these structures is allocated per processor.  To prevent
 * excessive competition for free structures, memory is now allocated
 * on a per-processor basis.  The application structure a_resource
 * element specifies the resource structure to be used; if
 * uniprocessing, a null a_resource pointer results in using the
 * internal global structure (&rt_uniresource), making initial
 * application development simpler.
 *
 * Applications are responsible for calling rt_init_resource() for
 * each resource structure before letting LIBRT use them.
 *
 * Note that if multiple models are being used, the partition and bitv
 * structures (which are variable length) will require there to be
 * ncpus * nmodels resource structures, the selection of which will be
 * the responsibility of the application.
 *
 * Per-processor statistics are initially collected in here, and then
 * posted to rt_i by rt_add_res_stats().
 */
struct resource {
    unsigned long	re_magic;	/**< @brief  Magic number */
    int			re_cpu;		/**< @brief  processor number, for ID */
    struct bu_list 	re_seg;		/**< @brief  Head of segment freelist */
    struct bu_ptbl	re_seg_blocks;	/**< @brief  Table of malloc'ed blocks of segs */
    long		re_seglen;
    long		re_segget;
    long		re_segfree;
    struct bu_list	re_parthead;	/**< @brief  Head of freelist */
    long		re_partlen;
    long		re_partget;
    long		re_partfree;
    struct bu_list	re_solid_bitv;	/**< @brief  head of freelist */
    struct bu_list	re_region_ptbl;	/**< @brief  head of freelist */
    struct bu_list	re_nmgfree;	/**< @brief  head of NMG hitmiss freelist */
    union tree **	re_boolstack;	/**< @brief  Stack for rt_booleval() */
    long		re_boolslen;	/**< @brief  # elements in re_boolstack[] */
    float *		re_randptr;	/**< @brief  ptr into random number table */
    /* Statistics.  Only for examination by rt_add_res_stats() */
    long		re_nshootray;	/**< @brief  Calls to rt_shootray() */
    long		re_nmiss_model;	/**< @brief  Rays pruned by model RPP */
    /* Solid nshots = shot_hit + shot_miss */
    long		re_shots;	/**< @brief  # calls to ft_shot() */
    long		re_shot_hit;	/**< @brief  ft_shot() returned a miss */
    long		re_shot_miss;	/**< @brief  ft_shot() returned a hit */
    /* Optimizations.  Rays not shot at solids */
    long		re_prune_solrpp;/**< @brief  shot missed solid RPP, ft_shot skipped */
    long		re_ndup;	/**< @brief  ft_shot() calls skipped for already-ft_shot() solids */
    long		re_nempty_cells;	/**< @brief  number of empty NUgrid cells passed through */
    /* Data for accelerating "pieces" of solids */
    struct rt_piecestate *re_pieces;	/**< @brief  array [rti_nsolids_with_pieces] */
    long		re_piece_ndup;	/**< @brief  ft_piece_shot() calls skipped for already-ft_shot() solids */
    long		re_piece_shots;	/**< @brief  # calls to ft_piece_shot() */
    long		re_piece_shot_hit;	/**< @brief  ft_piece_shot() returned a miss */
    long		re_piece_shot_miss;	/**< @brief  ft_piece_shot() returned a hit */
    struct bu_ptbl	re_pieces_pending;	/**< @brief  pieces with an odd hit pending */
    /* Per-processor cache of tree unions, to accelerate "tops" and treewalk */
    union tree *	re_tree_hd;	/**< @brief  Head of free trees */
    long		re_tree_get;
    long		re_tree_malloc;
    long		re_tree_free;
    struct directory *	re_directory_hd;
    struct bu_ptbl	re_directory_blocks;	/**< @brief  Table of malloc'ed blocks */
};
RT_EXPORT extern struct resource rt_uniresource;	/**< @brief  default.  Defined in librt/shoot.c */
#define RESOURCE_NULL	((struct resource *)0)
#define RT_CK_RESOURCE(_p)	BU_CKMAG(_p, RESOURCE_MAGIC, "struct resource")

/** More malloc-efficient replacement for BU_GETUNION(tp, tree) */
#define RT_GET_TREE(_tp, _res)	{ \
	if ( ((_tp) = (_res)->re_tree_hd) != TREE_NULL )  { \
		(_res)->re_tree_hd = (_tp)->tr_b.tb_left; \
		(_tp)->tr_b.tb_left = TREE_NULL; \
		(_res)->re_tree_get++; \
	} else { \
		BU_GETUNION( _tp, tree ); \
		(_res)->re_tree_malloc++; \
	}\
	}
#define RT_FREE_TREE(_tp, _res)  { \
		(_tp)->tr_b.tb_left = (_res)->re_tree_hd; \
		(_tp)->tr_b.tb_right = TREE_NULL; \
		(_res)->re_tree_hd = (_tp); \
		(_tp)->tr_b.tb_op = OP_FREE; \
		(_res)->re_tree_free++; \
	}


/**
 * R T _ R E P R E P _ O B J _ L I S T
 *
 * Structure used by the "reprep" routines
 */
struct rt_reprep_obj_list {
    int ntopobjs;		/**< @brief  number of objects in the original call to gettrees */
    char **topobjs;		/**< @brief  list of the above object names */
    int nunprepped;		/**< @brief  number of objects to be unprepped and re-prepped */
    char **unprepped;		/**< @brief  list of the above objects */
    /* Above here must be filled in by application */
    /* Below here is used by dynamic geometry routines, should be zeroed by application before use */
    struct bu_ptbl paths;	/**< @brief  list of all paths from topobjs to unprepped objects */
    struct db_tree_state **tsp;	/**< @brief  tree state used by tree walker in "reprep" routines */
    struct bu_ptbl unprep_regions;	/**< @brief  list of region structures that will be "unprepped" */
    long old_nsolids;		/**< @brief  rtip->nsolids before unprep */
    long old_nregions;		/**< @brief  rtip->nregions before unprep */
    long nsolids_unprepped;	/**< @brief  number of soltab structures eliminated by unprep */
    long nregions_unprepped;	/**< @brief  number of region structures eliminated by unprep */
};


/**
 * P I X E L _ E X T
 *
 * This structure is intended to descrbe the area and/or volume
 * represented by a ray.  In the case of the "rt" program it
 * represents the extent in model coordinates of the prism behind the
 * pixel being rendered.
 *
 * The r_pt values of the rays indicate the dimensions and location in
 * model space of the ray origin (usually the pixel to be rendered).
 * The r_dir vectors indicate the edges (and thus the shape) of the
 * prism which is formed from the projection of the pixel into space.
 */
#define CORNER_PTS 4
struct pixel_ext {
    unsigned long	magic;
    struct xray	corner[CORNER_PTS];
};
/* This should have had an RT_ prefix */
#define BU_CK_PIXEL_EXT(_p)	BU_CKMAG(_p, PIXEL_EXT_MAGIC, "struct pixel_ext")

/**
 * A P P L I C A T I O N
 *
 * This structure is the only parameter to rt_shootray().  The entire
 * structure should be zeroed (e.g. by memset) before it is used the
 * first time.
 *
 * When calling rt_shootray(), these fields are mandatory:
 *
 *	- a_ray.r_pt	Starting point of ray to be fired
 *	- a_ray.r_dir	UNIT VECTOR with direction to fire in (dir cosines)
 *	- a_hit()		Routine to call when something is hit
 *	- a_miss()	Routine to call when ray misses everything
 *	- a_rt_i		Must be set to the value returned by rt_dirbuild().
 *
 * In addition, these fields are used by the library.  If they are set
 * to zero, default behavior will be used.
 *
 *	- a_resource	Pointer to CPU-specific resources.  Multi-CPU only.
 *	- a_overlap()	DEPRECATED, set a_multioverlap() instead.
 *			If non-null, this routine will be called to
 *			handle overlap conditions.  See librt/bool.c
 *			for calling sequence.
 *			Return of 0 eliminates partition with overlap entirely
 *			Return of !0 retains one partition in output
 *	- a_multioverlap() Called when two or more regions overlap in a partition.
 *			Default behavior used if pointer not set.
 *			See librt/bool.c for calling sequence.
 *	- a_level		Printed by librt on errors, but otherwise not used.
 *	- a_x		Printed by librt on errors, but otherwise not used.
 *	- a_y		Printed by librt on errors, but otherwise not used.
 *	- a_purpose	Printed by librt on errors, but otherwise not used.
 *	- a_rbeam		Used to compute beam coverage on geometry,
 *	- a_diverge	for spline subdivision & many UV mappings.
 *
 *  Note that rt_shootray() returns the (int) return of the
 *  a_hit()/a_miss() function called, as well as placing it in
 *  a_return.  A future "multiple rays at a time" interface will only
 *  provide a_return.
 *
 *  Note that the organization of this structure, and the details of
 *  the non-mandatory elements are subject to change in every release.
 *  Therefore, rather than using compile-time structure
 *  initialization, you should create a zeroed-out structure, and then
 *  assign the intended values at runtime.  A zeroed structure can be
 *  obtained at compile time with "static struct application
 *  zero_ap;", or at run time by using "memset( (char *)ap, 0,
 *  sizeof(struct application) );" or bu_calloc( 1, sizeof(struct
 *  application), "application" ); While this practice may not work on
 *  machines where "all bits off" does not signify a floating point
 *  zero, BRL-CAD does not support any such machines, so this is a
 *  moot issue.
 */
struct application  {
    unsigned long	a_magic;
    /* THESE ELEMENTS ARE MANDATORY */
    struct xray		a_ray;		/**< @brief  Actual ray to be shot */
    int			(*a_hit)BU_ARGS( (struct application *, struct partition *, struct seg *));	/**< @brief  called when shot hits model */
    int			(*a_miss)BU_ARGS( (struct application *));	/**< @brief  called when shot misses */
    int			a_onehit;	/**< @brief  flag to stop on first hit */
    fastf_t		a_ray_length;	/**< @brief  distance from ray start to end intersections */
    struct rt_i	*	a_rt_i;		/**< @brief  this librt instance */
    int			a_zero1;	/**< @brief  must be zero (sanity check) */
    /* THESE ELEMENTS ARE USED BY THE LIBRARY, BUT MAY BE LEFT ZERO */
    struct resource *	a_resource;	/**< @brief  dynamic memory resources */
    int			(*a_overlap)BU_ARGS( (struct application *, struct partition *, struct region *, struct region *, struct partition *) );	/**< @brief  DEPRECATED */
    void		(*a_multioverlap)BU_ARGS( (struct application *, struct partition *, struct bu_ptbl *, struct partition *) );	/**< @brief  called to resolve overlaps */
    void		(*a_logoverlap)BU_ARGS( (struct application *, const struct partition *, const struct bu_ptbl *, const struct partition *) );	/**< @brief  called to log overlaps */
    int			a_level;	/**< @brief  recursion level (for printing) */
    int			a_x;		/**< @brief  Screen X of ray, if applicable */
    int			a_y;		/**< @brief  Screen Y of ray, if applicable */
    char *		a_purpose;	/**< @brief  Debug string:  purpose of ray */
    fastf_t		a_rbeam;	/**< @brief  initial beam radius (mm) */
    fastf_t		a_diverge;	/**< @brief  slope of beam divergance/mm */
    int			a_return;	/**< @brief  Return of a_hit()/a_miss() */
    int			a_no_booleans;	/**< @brief  1= partitions==segs, no booleans */
    char **		attrs;		/**< @brief  null terminated list of attributes
					 * This list should be the same as passed to
					 * rt_gettrees_and_attrs() */
    /* THESE ELEMENTS ARE USED BY THE PROGRAM "rt" AND MAY BE USED BY */
    /* THE LIBRARY AT SOME FUTURE DATE */
    /* AT THIS TIME THEY MAY BE LEFT ZERO */
    struct pixel_ext *	a_pixelext;	/**< @brief  locations of pixel corners */
    /* THESE ELEMENTS ARE WRITTEN BY THE LIBRARY, AND MAY BE READ IN a_hit() */
    struct seg *	a_finished_segs_hdp;
    struct partition *	a_Final_Part_hdp;
    vect_t		a_inv_dir;	/**< @brief  filled in by rt_shootray(), inverse of ray direction cosines */
    /* THE FOLLOWING ELEMENTS ARE MAINLINE & APPLICATION SPECIFIC. */
    /* THEY ARE NEVER EXAMINED BY THE LIBRARY. */
    int			a_user;		/**< @brief  application-specific value */
    genptr_t		a_uptr;		/**< @brief  application-specific pointer */
    struct bn_tabdata *	a_spectrum;	/**< @brief  application-specific bn_tabdata prointer */
    fastf_t		a_color[3];	/**< @brief  application-specific color */
    fastf_t		a_dist;		/**< @brief  application-specific distance */
    vect_t		a_uvec;		/**< @brief  application-specific vector */
    vect_t		a_vvec;		/**< @brief  application-specific vector */
    fastf_t		a_refrac_index;	/**< @brief  current index of refraction */
    fastf_t		a_cumlen;	/**< @brief  cumulative length of ray */
    int			a_flag;		/**< @brief  application-specific flag */
    int			a_zero2;	/**< @brief  must be zero (sanity check) */
};
#define RT_AFN_NULL	((int (*)())0)
#define RT_CK_AP(_p)	BU_CKMAG(_p, RT_AP_MAGIC, "struct application")
#define RT_CK_APPLICATION(_p)	BU_CKMAG(_p, RT_AP_MAGIC, "struct application")
#define RT_CK_AP_TCL(_interp, _p)	BU_CKMAG_TCL(_interp, _p, RT_AP_MAGIC, "struct application")
#define RT_APPLICATION_INIT(_p)	{ \
		memset((char *)(_p), 0, sizeof(struct application)); \
		(_p)->a_magic = RT_AP_MAGIC; \
	}


#ifdef NO_BOMBING_MACROS
#  define RT_AP_CHECK(_ap)
#else
#  define RT_AP_CHECK(_ap)	\
	{if((_ap)->a_zero1||(_ap)->a_zero2) \
		bu_bomb("corrupt application struct"); }
#endif

/**
 * R T _ G
 *
 * Definitions for librt.a which are global to the library regardless
 * of how many different models are being worked on
 */
struct rt_g {
    int			debug;		/**< @brief  !0 for debug, see librt/debug.h */
    /* XXX rtg_parallel is not used by LIBRT any longer */
    int			rtg_parallel;	/**< @brief  !0 = trying to use multi CPUs */
    struct bu_list	rtg_vlfree;	/**< @brief  head of bn_vlist freelist */
    int			NMG_debug;	/**< @brief  debug bits for NMG's see nmg.h */
    struct rt_wdb	rtg_headwdb;	/**< @brief  head of database object list */
};
RT_EXPORT extern struct rt_g rt_g;

/* Normally set when in production mode, setting the RT_G_DEBUG define
 * to 0 will allow chucks of code to poof away at compile time (since
 * they are truth-functionally constant (false)) This can boost
 * raytrace performance considerably (~10%).
 */
#ifdef NO_DEBUG_CHECKING
#  define RT_G_DEBUG 0
#else
#  define RT_G_DEBUG rt_g.debug
#endif

/**
 * S E M A P H O R E S
 *
 * Definition of global parallel-processing semaphores.
 *
 * res_syscall is now	BU_SEM_SYSCALL
 */
#define RT_SEM_TREE0	(BU_SEM_LAST)
#define RT_SEM_TREE1	(RT_SEM_TREE0+1)
#define RT_SEM_TREE2	(RT_SEM_TREE1+1)
#define RT_SEM_TREE3	(RT_SEM_TREE2+1)
#define RT_SEM_WORKER	(RT_SEM_TREE3+1)
#define RT_SEM_STATS	(RT_SEM_WORKER+1)
#define RT_SEM_RESULTS	(RT_SEM_STATS+1)
#define RT_SEM_MODEL	(RT_SEM_RESULTS+1)

#define RT_SEM_LAST	(RT_SEM_MODEL+1)	/**< @brief  Call bu_semaphore_init( RT_SEM_LAST ); */


/**
 * R T _ I
 *
 * @brief
 * This structure keeps track of almost everything for ray-tracing
 * support: Regions, primitives, model bounding box, statistics.
 *
 * Definitions for librt which are specific to the particular model
 * being processed, one copy for each model.  Initially, a pointer to
 * this is returned from rt_dirbuild().
 *
 * During gettree processing, the most time consuming step is
 * searching the list of existing solids to see if a new solid is
 * actually an identical instance of a previous solid.  Therefore, the
 * list has been divided into several lists.  The same macros & hash
 * value that accesses the dbi_Head[] array are used here.  The hash
 * value is computed by db_dirhash().
 */
struct rt_i {
    unsigned long	rti_magic;	/**< @brief  magic # for integrity check */
    /* THESE ITEMS ARE AVAILABLE FOR APPLICATIONS TO READ & MODIFY */
    int			useair;		/**< @brief  1="air" regions are retained while prepping */
    int			rti_save_overlaps; /**< @brief  1=fill in pt_overlap_reg, change boolweave behavior */
    int			rti_dont_instance; /**< @brief  1=Don't compress instances of solids into 1 while prepping */
    int			rti_hasty_prep;	/**< @brief  1=hasty prep, slower ray-trace */
    int			rti_nlights;	/**< @brief  number of light sources */
    int			rti_prismtrace; /**< @brief  add support for pixel prism trace */
    char *		rti_region_fix_file; /**< @brief  rt_regionfix() file or NULL */
    int			rti_space_partition;  /**< @brief  space partitioning method */
    int			rti_nugrid_dimlimit;  /**< @brief  limit on nugrid dimensions */
    struct bn_tol	rti_tol;	/**< @brief  Math tolerances for this model */
    struct rt_tess_tol	rti_ttol;	/**< @brief  Tessellation tolerance defaults */
    fastf_t		rti_max_beam_radius; /**< @brief  Max threat radius for FASTGEN cline solid */
    /* THESE ITEMS ARE AVAILABLE FOR APPLICATIONS TO READ */
    point_t		mdl_min;	/**< @brief  min corner of model bounding RPP */
    point_t		mdl_max;	/**< @brief  max corner of model bounding RPP */
    point_t		rti_pmin;	/**< @brief  for plotting, min RPP */
    point_t		rti_pmax;	/**< @brief  for plotting, max RPP */
    double		rti_radius;	/**< @brief  radius of model bounding sphere */
    struct db_i	*	rti_dbip;	/**< @brief  prt to Database instance struct */
    /* THESE ITEMS SHOULD BE CONSIDERED OPAQUE, AND SUBJECT TO CHANGE */
    int			needprep;	/**< @brief  needs rt_prep */
    struct region **	Regions;	/**< @brief  ptrs to regions [reg_bit] */
    struct bu_list	HeadRegion;	/**< @brief  ptr of list of regions in model */
    genptr_t		Orca_hash_tbl;	/**< @brief  Hash table in matrices for ORCA */
    struct bu_ptbl	delete_regs;	/**< @brief  list of region pointers to delete after light_init() */
    /* Ray-tracing statistics */
    long		nregions;	/**< @brief  total # of regions participating */
    long		nsolids;	/**< @brief  total # of solids participating */
    long		rti_nrays;	/**< @brief  # calls to rt_shootray() */
    long		nmiss_model;	/**< @brief  rays missed model RPP */
    long		nshots;		/**< @brief  # of calls to ft_shot() */
    long		nmiss;		/**< @brief  solid ft_shot() returned a miss */
    long		nhits;		/**< @brief  solid ft_shot() returned a hit */
    long		nmiss_tree;	/**< @brief  shots missed sub-tree RPP */
    long		nmiss_solid;	/**< @brief  shots missed solid RPP */
    long		ndup;		/**< @brief  duplicate shots at a given solid */
    long		nempty_cells;	/**< @brief  number of empty NUgrid cells */
    union cutter	rti_CutHead;	/**< @brief  Head of cut tree */
    union cutter	rti_inf_box;	/**< @brief  List of infinite solids */
    union cutter *	rti_CutFree;	/**< @brief  cut Freelist */
    struct bu_ptbl	rti_busy_cutter_nodes; /**< @brief  List of "cutter" mallocs */
    struct bu_ptbl	rti_cuts_waiting;
    int			rti_cut_maxlen;	/**< @brief  max len RPP list in 1 cut bin */
    int			rti_ncut_by_type[CUT_MAXIMUM+1];	/**< @brief  number of cuts by type */
    int			rti_cut_totobj;	/**< @brief  # objs in all bins, total */
    int			rti_cut_maxdepth;/**< @brief  max depth of cut tree */
    struct soltab **	rti_sol_by_type[ID_MAX_SOLID+1];
    int			rti_nsol_by_type[ID_MAX_SOLID+1];
    int			rti_maxsol_by_type;
    int			rti_air_discards;/**< @brief  # of air regions discarded */
    struct bu_hist	rti_hist_cellsize; /**< @brief  occupancy of cut cells */
    struct bu_hist	rti_hist_cell_pieces; /**< @brief  solid pieces per cell */
    struct bu_hist	rti_hist_cutdepth; /**< @brief  depth of cut tree */
    struct soltab **	rti_Solids;	/**< @brief  ptrs to soltab [st_bit] */
    struct bu_list	rti_solidheads[RT_DBNHASH]; /**< @brief  active solid lists */
    struct bu_ptbl	rti_resources;	/**< @brief  list of 'struct resource'es encountered */
    double		rti_nu_gfactor;	/**< @brief  constant in numcells computation */
    int			rti_cutlen;	/**< @brief  goal for # solids per boxnode */
    int			rti_cutdepth;	/**< @brief  goal for depth of NUBSPT cut tree */
    /* Parameters required for rt_submodel */
    char *		rti_treetop;	/**< @brief  bu_strduped, for rt_submodel rti's only */
    int			rti_uses;	/**< @brief  for rt_submodel */
    /* Parameters for accelerating "pieces" of solids */
    int			rti_nsolids_with_pieces; /**< @brief  # solids using pieces */
    /* Parameters for dynamic geometry */
    int			rti_add_to_new_solids_list;
    struct bu_ptbl	rti_new_solids;
};

#define RT_NU_GFACTOR_DEFAULT	1.5	 /**< @brief  see rt_cut_it() for a description
					    of this */

#define RTI_NULL	((struct rt_i *)0)

#define RT_CHECK_RTI(_p)		BU_CKMAG(_p, RTI_MAGIC, "struct rt_i")
#define RT_CHECK_RTI_TCL(_interp, _p)	BU_CKMAG_TCL(_interp, _p, RTI_MAGIC, "struct rt_i")
#define RT_CK_RTI(_p)			RT_CHECK_RTI(_p)
#define RT_CK_RTI_TCL(_interp, _p)	RT_CHECK_RTI_TCL(_interp, _p)

#define	RT_PART_NUBSPT	0
#define RT_PART_NUGRID	1

/**
 * Macros to painlessly visit all the active solids.  Serving suggestion:
 *
 * RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
 *	rt_pr_soltab( stp );
 * } RT_VISIT_ALL_SOLTABS_END
 */
#define RT_VISIT_ALL_SOLTABS_START(_s, _rti)	{ \
	register struct bu_list	*_head = &((_rti)->rti_solidheads[0]); \
	for (; _head < &((_rti)->rti_solidheads[RT_DBNHASH]); _head++ ) \
		for ( BU_LIST_FOR( _s, soltab, _head ) )  {

#define RT_VISIT_ALL_SOLTABS_END	} }

/**
 * Applications that are going to use RT_ADD_VLIST and RT_GET_VLIST
 * are required to execute this macro once, first:
 *
 * BU_LIST_INIT( &rt_g.rtg_vlfree );
 *
 * Note that RT_GET_VLIST and RT_FREE_VLIST are non-PARALLEL.
 */
#define RT_GET_VLIST(p)		BN_GET_VLIST(&rt_g.rtg_vlfree, p)

/** Place an entire chain of bn_vlist structs on the freelist */
#define RT_FREE_VLIST(hd)	BN_FREE_VLIST(&rt_g.rtg_vlfree, hd)

#define RT_ADD_VLIST(hd, pnt, draw)  BN_ADD_VLIST(&rt_g.rtg_vlfree, hd, pnt, draw)


/*
 * Replacements for definitions from vmath.h
 */
#undef V2PRINT
#undef VPRINT
#undef HPRINT
#define V2PRINT(a, b)	bu_log("%s (%g, %g)\n", a, (b)[0], (b)[1] );
#define VPRINT(a, b)	bu_log("%s (%g, %g, %g)\n", a, (b)[0], (b)[1], (b)[2])
#define HPRINT(a, b)	bu_log("%s (%g, %g, %g, %g)\n", a, (b)[0], (b)[1], (b)[2], (b)[3])

/**
 * C O M M A N D _ T A B
 *
 * Table for driving generic command-parsing routines
 */
struct command_tab {
    char *ct_cmd;
    char *ct_parms;
    char *ct_comment;
    int	(*ct_func)();
    int	ct_min;		/**< @brief  min number of words in cmd */
    int	ct_max;		/**< @brief  max number of words in cmd */
};

/**
 * R T _ P O I N T _ L A B E L S
 *
 * Used by MGED for labeling vertices of a solid.
 */
struct rt_point_labels {
    char str[8];
    point_t pt;
};

/**
 * R T _ P T _ N O D E
 *
 * Used by g_rpc.c and others to contain forward-linked lists of points.
 */
struct rt_pt_node {
    point_t p;			/**< @brief  a point */
    struct rt_pt_node *next;	/**< @brief  ptr to next pt */
};


/**
 * L I N E _ S E G,  C A R C _ S E G,  N U R B _ S E G
 *
 * used by the sketch and solid of extrusion
 */
struct line_seg		/**< @brief  line segment */
{
    unsigned long	magic;
    int			start, end;	/**< @brief  indices into sketch's array of vertices */
};

struct carc_seg		/**< @brief  circular arc segment */
{
    unsigned long	magic;
    int			start, end;	/**< @brief  indices */
    fastf_t		radius;		/**< @brief  radius < 0.0 -> full circle with start point on
						 * circle and "end" at center */
    int			center_is_left;	/**< @brief  flag indicating where center of curvature is.
					 * If non-zero, then center is to left of vector
					 * from start to end */
    int			orientation;	/**< @brief  0 -> ccw, !0 -> cw */
    int			center;		/**< @brief  index of vertex at center of arc (only used by rt_extrude_prep and rt_extrude_shot) */
};

struct nurb_seg		/**< @brief  NURB curve segment */
{
    unsigned long	magic;
    int			order;		/**< @brief  order of NURB curve (degree - 1) */
    int			pt_type;	/**< @brief  type of NURB curve */
    struct knot_vector	k;		/**< @brief  knot vector for NURB curve */
    int			c_size;		/**< @brief  number of control points */
    int			*ctl_points;	/**< @brief  array of indicies for control points */
    fastf_t		*weights;	/**< @brief  array of weights for control points (NULL if non_rational) */
};

struct bezier_seg	/**< @brief  Bezier curve segment */
{
    unsigned long	magic;
    int			degree;		/**< @brief  degree of curve (number of control points - 1) */
    int			*ctl_points;	/**< @brief  array of indices for control points */
};

/**
 * R T _ F U N C T A B
 *
 * Object-oriented interface to BRL-CAD geometry.
 *
 * These are the methods for a notional object class "brlcad_solid".
 * The data for each instance is found separately in struct soltab.
 * This table is indexed by ID_xxx value of particular solid found in
 * st_id, or directly pointed at by st_meth.
 *
 * This needs to be at the end of the raytrace.h header file, so that
 * all the structure names are known.  The "union record" and "struct
 * nmgregion" pointers are problematic, so generic pointers are used
 * when those header files have not yet been seen.
 *
 * XXX On SGI, can not use identifiers in prototypes inside structure!
 *
 * DEPRECATED: the size of this structure will likely change with new
 * size for ft_label and new object callbacks.
 */
struct rt_functab {
    unsigned long magic;
    char ft_name[16];
    char ft_label[8];
    int ft_use_rpp;
    int (*ft_prep) BU_ARGS((struct soltab * /**< @brief stp*/,
			    struct rt_db_internal * /**< @brief ip*/,
			    struct rt_i * /**< @brief rtip*/ ));
    int (*ft_shot) BU_ARGS((struct soltab * /**< @brief stp*/,
			    struct xray * /**< @brief rp*/,
			    struct application * /**< @brief ap*/,	/**< @brief  has resource */
			    struct seg * /**< @brief seghead*/ ));
    void (*ft_print) BU_ARGS((const struct soltab * /**< @brief stp*/));
    void (*ft_norm) BU_ARGS((struct hit * /**< @brief hitp*/,
			     struct soltab * /**< @brief stp*/,
			     struct xray * /**< @brief rp*/));
    int (*ft_piece_shot) BU_ARGS((struct rt_piecestate * /**< @brief psp*/,
				  struct rt_piecelist * /**< @brief plp*/,
				  double /**< @brief  dist_correction to apply to hit distances */,
				  struct xray * /**< @brief  ray transformed to be near cut cell */,
				  struct application * /**< @brief ap*/,	/**< @brief  has resource */
				  struct seg * /**< @brief seghead*/));	/**< @brief  used only for PLATE mode hits */
    void (*ft_piece_hitsegs) BU_ARGS((struct rt_piecestate * /**< @brief psp*/,
				      struct seg * /**< @brief seghead*/,
				      struct application * /**< @brief ap*/));	/**< @brief  has resource */
    void (*ft_uv) BU_ARGS((struct application * /**< @brief ap*/,	/**< @brief  has resource */
			   struct soltab * /**< @brief stp*/,
			   struct hit * /**< @brief hitp*/,
			   struct uvcoord * /**< @brief uvp*/));
    void (*ft_curve) BU_ARGS((struct curvature * /**< @brief cvp*/,
			      struct hit * /**< @brief hitp*/,
			      struct soltab * /**< @brief stp*/));
    int (*ft_classify) BU_ARGS((const struct soltab * /*stp*/,
				const vect_t /*min*/,
				const vect_t /*max*/,
				const struct bn_tol * /*tol*/));
    void (*ft_free) BU_ARGS((struct soltab * /*stp*/));
    int (*ft_plot) BU_ARGS((struct bu_list * /*vhead*/,
			    struct rt_db_internal * /*ip*/,
			    const struct rt_tess_tol * /*ttol*/,
			    const struct bn_tol * /*tol*/));
    void (*ft_vshot) BU_ARGS((struct soltab * /*stp*/[],
			      struct xray *[] /*rp*/,
			      struct seg [] /*segp*/, int /*n*/,
			      struct application * /*ap*/ ));
    int (*ft_tessellate) BU_ARGS((struct nmgregion ** /*r*/,
				  struct model * /*m*/,
				  struct rt_db_internal * /*ip*/,
				  const struct rt_tess_tol * /*ttol*/,
				  const struct bn_tol * /*tol*/));
    int (*ft_tnurb) BU_ARGS((struct nmgregion ** /*r*/,
			     struct model * /*m*/,
			     struct rt_db_internal * /*ip*/,
			     const struct bn_tol * /*tol*/));
    int (*ft_import5) BU_ARGS((struct rt_db_internal * /*ip*/,
			       const struct bu_external * /*ep*/,
			       const mat_t /*mat*/,
			       const struct db_i * /*dbip*/,
			       struct resource * /*resp*/,
			       const int minor_type));
    int (*ft_export5) BU_ARGS((struct bu_external * /*ep*/,
			       const struct rt_db_internal * /*ip*/,
			       double /*local2mm*/,
			       const struct db_i * /*dbip*/,
			       struct resource * /*resp*/,
			       const int minor_type));
    int (*ft_import) BU_ARGS((struct rt_db_internal * /*ip*/,
			      const struct bu_external * /*ep*/,
			      const mat_t /*mat*/,
			      const struct db_i * /*dbip*/,
			      struct resource * /*resp*/));
    int	(*ft_export) BU_ARGS((struct bu_external * /*ep*/,
			      const struct rt_db_internal * /*ip*/,
			      double /*local2mm*/,
			      const struct db_i * /*dbip*/,
			      struct resource * /*resp*/));
    void (*ft_ifree) BU_ARGS((struct rt_db_internal * /*ip*/,
			      struct resource * /*resp*/));
    int	(*ft_describe) BU_ARGS((struct bu_vls * /*str*/,
				const struct rt_db_internal * /*ip*/,
				int /*verbose*/,
				double /*mm2local*/,
				struct resource * /*resp*/,
				struct db_i *));
    int	(*ft_xform) BU_ARGS((struct rt_db_internal * /*op*/,
			     const mat_t /*mat*/, struct rt_db_internal * /*ip*/,
			     int /*free*/, struct db_i * /*dbip*/,
			     struct resource * /*resp*/));
    const struct bu_structparse *ft_parsetab;	/**< @brief  rt_xxx_parse */
    size_t ft_internal_size;	/**< @brief  sizeof(struct rt_xxx_internal) */
    unsigned long ft_internal_magic;	/**< @brief  RT_XXX_INTERNAL_MAGIC */
#if defined(TCL_OK)
    int	(*ft_tclget) BU_ARGS((Tcl_Interp *,
			      const struct rt_db_internal *, const char *item));
    int	(*ft_tcladjust) BU_ARGS((Tcl_Interp *,
				 struct rt_db_internal *,
				 int /*argc*/, char ** /*argv*/,
				 struct resource * /*resp*/));
    int	(*ft_tclform) BU_ARGS((const struct rt_functab *,
			       Tcl_Interp *));
#else
    int	(*ft_tclget) BU_ARGS((genptr_t /*interp*/,
			      const struct rt_db_internal *, const char *item));
    int	(*ft_tcladjust) BU_ARGS((genptr_t /*interp*/,
				 struct rt_db_internal *,
				 int /*argc*/, char ** /*argv*/,
				 struct resource * /*resp*/));
    int	(*ft_tclform) BU_ARGS((const struct rt_functab *,
			       genptr_t /*interp*/));
#endif
    void (*ft_make) BU_ARGS((const struct rt_functab *,
			     struct rt_db_internal *, double /*diameter*/));
};

RT_EXPORT extern const struct rt_functab rt_functab[];

#define RT_CK_FUNCTAB(_p)	BU_CKMAG(_p, RT_FUNCTAB_MAGIC, "functab" );

#define RT_CLASSIFY_UNIMPLEMENTED	BN_CLASSIFY_UNIMPLEMENTED
#define RT_CLASSIFY_INSIDE		BN_CLASSIFY_INSIDE
#define RT_CLASSIFY_OVERLAPPING		BN_CLASSIFY_OVERLAPPING
#define RT_CLASSIFY_OUTSIDE		BN_CLASSIFY_OUTSIDE

/**
 * R T _ S H O O T R A Y _ S T A T U S
 *
 * Internal to shoot.c and bundle.c
 */
struct rt_shootray_status {
    fastf_t		dist_corr;	/**< @brief  correction distance */
    fastf_t		odist_corr;
    fastf_t		box_start;
    fastf_t		obox_start;
    fastf_t		box_end;
    fastf_t		obox_end;
    fastf_t		model_start;
    fastf_t		model_end;
    struct xray		newray;		/**< @brief  closer ray start */
    struct application *ap;
    struct resource *	resp;
    vect_t		inv_dir;      /**< @brief  inverses of ap->a_ray.r_dir */
    vect_t		abs_inv_dir;  /**< @brief  absolute values of inv_dir */
    int			rstep[3];     /**< @brief  -/0/+ dir of ray in axis */
    const union cutter *lastcut, *lastcell;
    const union cutter *curcut;
    point_t		curmin, curmax;
    int			igrid[3];     /**< @brief  integer cell coordinates */
    vect_t		tv;	      /**< @brief  next t intercept values */
    int			out_axis;     /**< @brief  axis ray will leave through */
    struct rt_shootray_status *old_status;
    int			box_num;	/**< @brief  which cell along ray */
};

#define NUGRID_T_SETUP(_ax, _cval, _cno) \
	if ( ssp->rstep[_ax] > 0 ) { \
		ssp->tv[_ax] = t0 + (nu_axis[_ax][_cno].nu_epos - _cval) * \
					    ssp->inv_dir[_ax]; \
	} else if ( ssp->rstep[_ax] < 0 ) { \
		ssp->tv[_ax] = t0 + (nu_axis[_ax][_cno].nu_spos - _cval) * \
					    ssp->inv_dir[_ax]; \
	} else { \
		ssp->tv[_ax] = INFINITY; \
	}
#define NUGRID_T_ADV(_ax, _cno) \
	if ( ssp->rstep[_ax] != 0 )  { \
		ssp->tv[_ax] += nu_axis[_ax][_cno].nu_width * \
			ssp->abs_inv_dir[_ax]; \
	}

#define BACKING_DIST	(-2.0)		/**< @brief  mm to look behind start point */
#define OFFSET_DIST	0.01		/**< @brief  mm to advance point into box */

/*********************************************************************************
 *	The following section is an exact copy of what was previously "nmg_rt.h" *
 *      (with minor changes to GET_HITMISS and NMG_FREE_HITLIST                  *
 *	moved here to use rt_g.rtg_nmgfree freelist for hitmiss structs.         *
 ******************************************************************************* */

#define NMG_HIT_LIST	0
#define NMG_MISS_LIST	1


/* These values are for the hitmiss "in_out" variable and indicate the
 * nature of the hit when known
 */
#define HMG_INBOUND_STATE(_hm) (((_hm)->in_out & 0x0f0) >> 4)
#define HMG_OUTBOUND_STATE(_hm) ((_hm)->in_out & 0x0f)


#define NMG_RAY_STATE_INSIDE	1
#define NMG_RAY_STATE_ON	2
#define NMG_RAY_STATE_OUTSIDE	4
#define NMG_RAY_STATE_ANY	8

#define HMG_HIT_IN_IN	0x11	/**< @brief  hit internal structure */
#define HMG_HIT_IN_OUT	0x14	/**< @brief  breaking out */
#define HMG_HIT_OUT_IN	0x41	/**< @brief  breaking in */
#define HMG_HIT_OUT_OUT 0x44	/**< @brief  edge/vertex graze */
#define HMG_HIT_IN_ON	0x12
#define HMG_HIT_ON_IN	0x21
#define HMG_HIT_ON_ON	0x22
#define HMG_HIT_OUT_ON	0x42
#define HMG_HIT_ON_OUT	0x24
#define HMG_HIT_ANY_ANY	0x88	/**< @brief  hit on non-3-mainifold */

#define	NMG_VERT_ENTER 1
#define NMG_VERT_ENTER_LEAVE 0
#define NMG_VERT_LEAVE -1
#define NMG_VERT_UNKNOWN -2

#define NMG_HITMISS_SEG_IN 0x696e00	/**< @brief  "in" */
#define NMG_HITMISS_SEG_OUT 0x6f757400	/**< @brief  "out" */

struct hitmiss {
    struct bu_list	l;
    struct hit		hit;
    fastf_t		dist_in_plane;	/**< @brief  distance from plane intersect */
    int			in_out;		/**< @brief  status of ray as it transitions
					 * this hit point.
					 */
    long		*inbound_use;
    vect_t		inbound_norm;
    long		*outbound_use;
    vect_t		outbound_norm;
    int			start_stop;	/**< @brief  is this a seg_in or seg_out */
    struct hitmiss	*other;		/**< @brief  for keeping track of the other
					 * end of the segment when we know
					 * it
					 */
};

#ifdef NO_BOMBING_MACROS
#  define NMG_CK_HITMISS(hm)
#else
#  define NMG_CK_HITMISS(hm) \
    {\
	switch (hm->l.magic) { \
	case NMG_RT_HIT_MAGIC: \
	case NMG_RT_HIT_SUB_MAGIC: \
	case NMG_RT_MISS_MAGIC: \
		break; \
	case NMG_MISS_LIST: \
		bu_log(BU_FLSTR ": struct hitmiss has NMG_MISS_LIST magic #\n"); \
		bu_bomb("NMG_CK_HITMISS: going down in flames\n"); \
	case NMG_HIT_LIST: \
		bu_log(BU_FLSTR ": struct hitmiss has NMG_MISS_LIST magic #\n"); \
		bu_bomb("NMG_CK_HITMISS: going down in flames\n"); \
	default: \
		bu_log(BU_FLSTR ": bad struct hitmiss magic: %u:(0x%08x)\n", \
			hm->l.magic, hm->l.magic); \
		bu_bomb("NMG_CK_HITMISS: going down in flames\n"); \
	}\
	if (!hm->hit.hit_private) { \
		bu_log(BU_FLSTR ": NULL hit_private in hitmiss struct\n"); \
		bu_bomb("NMG_CK_HITMISS: going down in flames\n"); \
	} \
    }
#endif

#ifdef NO_BOMBING_MACROS
#  define NMG_CK_HITMISS_LISTS(rd)
#else
#  define NMG_CK_HITMISS_LISTS(rd) \
    { \
        struct hitmiss *_a_hit; \
	for (BU_LIST_FOR(_a_hit, hitmiss, &rd->rd_hit)) {NMG_CK_HITMISS(_a_hit);} \
	for (BU_LIST_FOR(_a_hit, hitmiss, &rd->rd_miss)) {NMG_CK_HITMISS(_a_hit);} \
    }
#endif


/**
 * Ray Data structure
 *
 * A) the hitmiss table has one element for each nmg structure in the
 * nmgmodel.  The table keeps track of which elements have been
 * processed before and which haven't.  Elements in this table will
 * either be: (NULL) item not previously processed hitmiss ptr item
 * previously processed
 *
 * the 0th item in the array is a pointer to the head of the "hit"
 * list.  The 1th item in the array is a pointer to the head of the
 * "miss" list.
 *
 * B) If plane_pt is non-null then we are currently processing a face
 * intersection.  The plane_dist and ray_dist_to_plane are valid.  The
 * ray/edge intersector should check the distance from the plane
 * intercept to the edge and update "plane_closest" if the current
 * edge is closer to the intercept than the previous closest object.
 */
struct ray_data {
    unsigned long	magic;
    struct model	*rd_m;
    char		*manifolds; /**< @brief   structure 1-3manifold table */
    vect_t		rd_invdir;
    struct xray		*rp;
    struct application	*ap;
    struct seg		*seghead;
    struct soltab 	*stp;
    const struct bn_tol	*tol;
    struct hitmiss	**hitmiss;	/**< @brief  1 struct hitmiss ptr per elem. */
    struct bu_list	rd_hit;		/**< @brief  list of hit elements */
    struct bu_list	rd_miss;	/**< @brief  list of missed/sub-hit elements */

/* The following are to support isect_ray_face() */

    /**
     * plane_pt is the intercept point of the ray with the plane of
     * the face.
     */
    point_t		plane_pt;	/**< @brief  ray/plane(face) intercept point */

    /**
     * ray_dist_to_plane is the parametric distance along the ray from
     * the ray origin (rd->rp->r_pt) to the ray/plane intercept point
     */
    fastf_t		ray_dist_to_plane; /**< @brief  ray parametric dist to plane */

    /**
     * the "face_subhit" element is a boolean used by isect_ray_face
     * and [e|v]u_touch_func to record the fact that the
     * ray/(plane/face) intercept point was within tolerance of an
     * edge/vertex of the face.  In such instances, isect_ray_face
     * does NOT need to generate a hit point for the face, as the hit
     * point for the edge/vertex will suffice.
     */
    int			face_subhit;

    /**
     * the "classifying_ray" flag indicates that this ray is being
     * used to classify a point, so that the "eu_touch" and "vu_touch"
     * functions should not be called.
     */
    int			classifying_ray;
};

#define NMG_PCA_EDGE	1
#define NMG_PCA_EDGE_VERTEX 2
#define NMG_PCA_VERTEX 3
#define NMG_CK_RD(_rd) NMG_CKMAG(_rd, NMG_RAY_DATA_MAGIC, "ray data");


#define GET_HITMISS(_p, _ap) { \
	(_p) = BU_LIST_FIRST( hitmiss, &((_ap)->a_resource->re_nmgfree) ); \
	if ( BU_LIST_IS_HEAD( (_p), &((_ap)->a_resource->re_nmgfree ) ) ) \
		(_p) = (struct hitmiss *)bu_calloc(1, sizeof( struct hitmiss ), "hitmiss "BU_FLSTR ); \
	else \
		BU_LIST_DEQUEUE( &((_p)->l) ); \
	}

#define NMG_FREE_HITLIST(_p, _ap) { \
	BU_CK_LIST_HEAD( (_p) ); \
	BU_LIST_APPEND_LIST( &((_ap)->a_resource->re_nmgfree), (_p) ); \
	}

#define HIT 1	/**< @brief  a hit on a face */
#define MISS 0	/**< @brief  a miss on the face */


#ifdef NO_BOMBING_MACROS
#  define nmg_bu_bomb(rd, str)
#else
#  define nmg_bu_bomb(rd, str) { \
	bu_log("%s", str); \
	if (rt_g.NMG_debug & DEBUG_NMGRT) bu_bomb("End of diagnostics"); \
	BU_LIST_INIT(&rd->rd_hit); \
	BU_LIST_INIT(&rd->rd_miss); \
	rt_g.NMG_debug |= DEBUG_NMGRT; \
	nmg_isect_ray_model(rd); \
	(void) nmg_ray_segs(rd); \
	bu_bomb("Should have bombed before this\n"); }
#endif


struct nmg_radial {
    struct bu_list	l;
    struct edgeuse	*eu;
    struct faceuse	*fu;		/**< @brief  Derrived from eu */
    struct shell	*s;		/**< @brief  Derrived from eu */
    int			existing_flag;	/**< @brief  !0 if this eu exists on dest edge */
    int			is_crack;	/**< @brief  This eu is part of a crack. */
    int			is_outie;	/**< @brief  This crack is an "outie" */
    int			needs_flip;	/**< @brief  Insert eumate, not eu */
    fastf_t		ang;		/**< @brief  angle, in radians.  0 to 2pi */
};
#define NMG_CK_RADIAL(_p)	NMG_CKMAG(_p, NMG_RADIAL_MAGIC, "nmg_radial")

struct nmg_inter_struct {
    unsigned long	magic;
    struct bu_ptbl	*l1;		/**< @brief  vertexuses on the line of */
    struct bu_ptbl	*l2;		/**< @brief  intersection between planes */
    fastf_t		*mag1;		/**< @brief  Distances along intersection line */
    fastf_t		*mag2;		/**< @brief  for each vertexuse in l1 and l2. */
    int			mag_len;	/**< @brief  Array size of mag1 and mag2 */
    struct shell	*s1;
    struct shell	*s2;
    struct faceuse	*fu1;		/**< @brief  null if l1 comes from a wire */
    struct faceuse	*fu2;		/**< @brief  null if l2 comes from a wire */
    struct bn_tol	tol;
    int			coplanar;	/**< @brief  a flag */
    struct edge_g_lseg	*on_eg;		/**< @brief  edge_g for line of intersection */
    point_t		pt;		/**< @brief  3D line of intersection */
    vect_t		dir;
    point_t		pt2d;		/**< @brief  2D projection of isect line */
    vect_t		dir2d;
    fastf_t		*vert2d;	/**< @brief  Array of 2d vertex projections [index] */
    int			maxindex;	/**< @brief  size of vert2d[] */
    mat_t		proj;		/**< @brief  Matrix to project onto XY plane */
    const long 		*twod;		/**< @brief  ptr to face/edge of 2d projection */
};
#define NMG_CK_INTER_STRUCT(_p)	NMG_CKMAG(_p, NMG_INTER_STRUCT_MAGIC, "nmg_inter_struct")

/*****************************************************************
 *                                                               *
 *          Applications interface to the RT library             *
 *                                                               *
 *****************************************************************/
/* Read named MGED db, build toc */
RT_EXPORT BU_EXTERN(struct rt_i *rt_dirbuild,
		    (const char *filename,
		     char *buf,
		     int len));
/* Prepare for raytracing */
RT_EXPORT BU_EXTERN(struct rt_i *rt_new_rti,
		    (struct db_i *dbip));
RT_EXPORT BU_EXTERN(void rt_free_rti,
		    (struct rt_i *rtip));
RT_EXPORT BU_EXTERN(void rt_prep,
		    (struct rt_i *rtip));
RT_EXPORT BU_EXTERN(void rt_prep_parallel,
		    (struct rt_i *rtip,
		     int ncpu));
RT_EXPORT BU_EXTERN(void rt_default_multioverlap,
		    (struct application *ap,
		     struct partition *pp,
		     struct bu_ptbl *regiontable,
		     struct partition *InputHdp));
RT_EXPORT BU_EXTERN(void rt_silent_logoverlap,
		    (struct application *ap,
		     const struct partition *pp,
		     const struct bu_ptbl *regiontable,
		     const struct partition *InputHdp));
RT_EXPORT BU_EXTERN(void rt_default_logoverlap,
		    (struct application *ap,
		     const struct partition *pp,
		     const struct bu_ptbl *regiontable,
		     const struct partition *InputHdp));
/* Shoot a ray */
RT_EXPORT BU_EXTERN(int rt_shootray,
		    (struct application *ap));
/* Get expr tree for object */
RT_EXPORT BU_EXTERN(void rt_free_soltab,
		    (struct soltab   *stp));
RT_EXPORT BU_EXTERN(int rt_gettree,
		    (struct rt_i *rtip,
		     const char *node));
RT_EXPORT BU_EXTERN(int rt_gettrees,
		    (struct rt_i *rtip,
		     int argc,
		     const char **argv, int ncpus));
RT_EXPORT BU_EXTERN(int rt_gettrees_and_attrs,
		    (struct rt_i *rtip,
		     const char **attrs,
		     int argc,
		     const char **argv, int ncpus));
RT_EXPORT BU_EXTERN(int rt_gettrees_muves,
		    (struct rt_i *rtip,
		     const char **attrs,
		     int argc,
		     const char **argv,
		     int ncpus));
RT_EXPORT BU_EXTERN(int rt_load_attrs,
		    (struct rt_i *rtip,
		     char **attrs));
/* Print seg struct */
RT_EXPORT BU_EXTERN(void rt_pr_seg,
		    (const struct seg *segp));
/* Print the partitions */
RT_EXPORT BU_EXTERN(void rt_pr_partitions,
		    (const struct rt_i *rtip,
		     const struct partition *phead,
		     const char *title));
/* Find solid by leaf name */
RT_EXPORT BU_EXTERN(struct soltab *rt_find_solid,
		    (const struct rt_i *rtip,
		     const char *name));
/* Start the timer */
RT_EXPORT BU_EXTERN(void rt_prep_timer,
		    (void));
/* Read timer, return time + str */
RT_EXPORT BU_EXTERN(double rt_get_timer,
		    (struct bu_vls *vp,
		     double *elapsed));
/* Return CPU time, text, & wall clock time */
RT_EXPORT BU_EXTERN(double rt_read_timer,
		    (char *str, int len));
/* Plot a solid */
int rt_plot_solid(
    FILE			*fp,
    struct rt_i		*rtip,
    const struct soltab	*stp,
    struct resource		*resp);
/* Release storage assoc with rt_i */
RT_EXPORT BU_EXTERN(void rt_clean,
		    (struct rt_i *rtip));
RT_EXPORT BU_EXTERN(int rt_del_regtree,
		    (struct rt_i *rtip,
		     struct region *delregp,
		     struct resource *resp));
/* Check in-memory data structures */
RT_EXPORT BU_EXTERN(void rt_ck,
		    (struct rt_i *rtip));
/* apply a matrix transformation */
RT_EXPORT BU_EXTERN(int rt_matrix_transform,
		    (struct rt_db_internal *output, const mat_t matrix, struct rt_db_internal *input, int free_input, struct db_i *dbip, struct resource *resource));


/*****************************************************************
 *                                                               *
 *  Internal routines in the RT library.			 *
 *  These routines are *not* intended for Applications to use.	 *
 *  The interface to these routines may change significantly	 *
 *  from release to release of this software.			 *
 *                                                               *
 *****************************************************************/

/* Weave segs into partitions */
RT_EXPORT BU_EXTERN(void rt_boolweave,
		    (struct seg *out_hd,
		     struct seg *in_hd,
		     struct partition *PartHeadp,
		     struct application *ap));
/* Eval booleans over partitions */
RT_EXPORT BU_EXTERN(int rt_boolfinal,
		    (struct partition *InputHdp,
		     struct partition *FinalHdp,
		     fastf_t startdist,
		     fastf_t enddist,
		     struct bu_ptbl *regionbits,
		     struct application *ap,
		     const struct bu_bitv *solidbits));

RT_EXPORT BU_EXTERN(void rt_grow_boolstack,
		    (struct resource *res));
/* Approx Floating compare */
RT_EXPORT BU_EXTERN(int rt_fdiff,
		    (double a, double b));
/* Relative Difference */
RT_EXPORT BU_EXTERN(double rt_reldiff,
		    (double a, double b));
/* Print a soltab */
RT_EXPORT BU_EXTERN(void rt_pr_soltab,
		    (const struct soltab *stp));
/* Print a region */
RT_EXPORT BU_EXTERN(void rt_pr_region,
		    (const struct region *rp));
/* Print an expr tree */
RT_EXPORT BU_EXTERN(void rt_pr_tree,
		    (const union tree *tp,
		     int lvl));
/* Print value of tree for a partition */
RT_EXPORT BU_EXTERN(void rt_pr_tree_val,
		    (const union tree *tp,
		     const struct partition *partp,
		     int pr_name, int lvl));
/* Print a partition */
RT_EXPORT BU_EXTERN(void rt_pr_pt,
		    (const struct rt_i *rtip,
		     const struct partition *pp));
/* Print a bit vector */
RT_EXPORT BU_EXTERN(void rt_pr_hit,
		    (const char *str,
		     const struct hit *hitp));

/* rt_fastf_float, rt_mat_dbmat, rt_dbmat_mat
 * declarations moved to db.h */

/* storage obtainers */
RT_EXPORT BU_EXTERN(void rt_get_seg,
		    (struct resource *res));
RT_EXPORT BU_EXTERN(void rt_cut_it,
		    (struct rt_i *rtip,
		     int ncpu));
/* print cut node */
RT_EXPORT BU_EXTERN(void rt_pr_cut,
		    (const union cutter *cutp,
		     int lvl));
/* free a cut tree */
RT_EXPORT BU_EXTERN(void rt_fr_cut,
		    (struct rt_i *rtip,
		     union cutter *cutp));

/* regionid-driven color override */

/* bool.c */
RT_EXPORT BU_EXTERN(void rt_rebuild_overlaps,
		    (struct partition	*PartHdp,
		     struct application	*ap,
		     int		rebuild_fastgen_plates_only));
RT_EXPORT BU_EXTERN(int rt_partition_len,
		    (const struct partition *partheadp));
RT_EXPORT BU_EXTERN(int	rt_defoverlap,
		    (struct application *ap,
		     struct partition *pp,
		     struct region *reg1,
		     struct region *reg2,
		     struct partition *pheadp));

/* extend a cut box */

/* cut.c */
RT_EXPORT BU_EXTERN(void rt_pr_cut_info,
		    (const struct rt_i	*rtip,
		     const char		*str));
RT_EXPORT BU_EXTERN(void remove_from_bsp,
		    (struct soltab *stp,
		     union cutter *cutp,
		     struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void insert_in_bsp,
		    (struct soltab *stp,
		     union cutter *cutp));
RT_EXPORT BU_EXTERN(void fill_out_bsp,
		    (struct rt_i *rtip,
		     union cutter *cutp,
		     struct resource *resp,
		     fastf_t bb[6]));
RT_EXPORT BU_EXTERN(void rt_cut_extend,
		    (union cutter *cutp,
		     struct soltab *stp,
		     const struct rt_i *rtip));
/* find RPP of one region */
RT_EXPORT BU_EXTERN(int rt_rpp_region,
		    (struct rt_i *rtip,
		     const char *reg_name,
		     fastf_t *min_rpp,
		     fastf_t *max_rpp));
RT_EXPORT BU_EXTERN(int rt_in_rpp,
		    (struct xray *rp,
		     const fastf_t *invdir,
		     const fastf_t *min,
		     const fastf_t *max));
RT_EXPORT BU_EXTERN(const union cutter *rt_cell_n_on_ray,
		    (struct application *ap,
		     int n));
RT_EXPORT BU_EXTERN(void rt_cut_clean,
		    (struct rt_i *rtip));

/* cmd.c */
/* Read semi-colon terminated line */
RT_EXPORT BU_EXTERN(char *rt_read_cmd,
		    (FILE *fp));
/* do cmd from string via cmd table */
RT_EXPORT BU_EXTERN(int rt_do_cmd,
		    (struct rt_i *rtip,
		     const char *ilp,
		     const struct command_tab *tp));

/* rt_split_cmd is DEPRECATED, use bu_argv_from_string */
RT_EXPORT BU_EXTERN(int rt_split_cmd, (char **argv, int lim, char *lp));


/* The database library */

/* wdb.c */
RT_EXPORT BU_EXTERN(struct rt_wdb *wdb_fopen,
		    (const char *filename));
RT_EXPORT BU_EXTERN(struct rt_wdb *wdb_fopen_v,
		    (const char *filename,
		     int version));
RT_EXPORT BU_EXTERN(struct rt_wdb *wdb_dbopen,
		    (struct db_i *dbip,
		     int mode));
RT_EXPORT BU_EXTERN(int wdb_import,
		    (struct rt_wdb *wdbp,
		     struct rt_db_internal *internp,
		     const char *name,
		     const mat_t mat));
RT_EXPORT BU_EXTERN(int wdb_export_external,
		    (struct rt_wdb *wdbp,
		     struct bu_external *ep,
		     const char *name,
		     int flags,
		     unsigned char minor_type));
RT_EXPORT BU_EXTERN(int wdb_put_internal,
		    (struct rt_wdb *wdbp,
		     const char *name,
		     struct rt_db_internal *ip,
		     double local2mm));
RT_EXPORT BU_EXTERN(int wdb_export,
		    (struct rt_wdb *wdbp,
		     const char *name,
		     genptr_t gp,
		     int id,
		     double local2mm));
RT_EXPORT BU_EXTERN(void wdb_close,
		    (struct rt_wdb *wdbp));

/* db_anim.c */
RT_EXPORT BU_EXTERN(struct animate *db_parse_1anim,
		    (struct db_i     *dbip,
		     int             argc,
		     const char      **argv));

RT_EXPORT BU_EXTERN(int db_parse_anim,
		    (struct db_i     *dbip,
		     int             argc,
		     const char      **argv));


RT_EXPORT BU_EXTERN(int db_add_anim,
		    (struct db_i *dbip,
		     struct animate *anp,
		     int root));
RT_EXPORT BU_EXTERN(int db_do_anim,
		    (struct animate *anp,
		     mat_t stack,
		     mat_t arc,
		     struct mater_info *materp));
RT_EXPORT BU_EXTERN(void db_free_anim,
		    (struct db_i *dbip));
RT_EXPORT BU_EXTERN(void db_write_anim,
		    (FILE *fop,
		     struct animate *anp));
RT_EXPORT BU_EXTERN(struct animate *db_parse_1anim,
		    (struct db_i *dbip,
		     int argc,
		     const char **argv));
RT_EXPORT BU_EXTERN(void db_free_1anim,
		    (struct animate *anp));

/* db_path.c */
RT_EXPORT BU_EXTERN(void db_full_path_init,
		    (struct db_full_path *pathp));
RT_EXPORT BU_EXTERN(void db_add_node_to_full_path,
		    (struct db_full_path *pp,
		     struct directory *dp));
RT_EXPORT BU_EXTERN(void db_dup_full_path,
		    (struct db_full_path *newp,
		     const struct db_full_path *oldp));
RT_EXPORT BU_EXTERN(void db_extend_full_path,
		    (struct db_full_path *pathp,
		     int incr));
RT_EXPORT BU_EXTERN(void db_append_full_path,
		    (struct db_full_path *dest,
		     const struct db_full_path *src));
RT_EXPORT BU_EXTERN(void db_dup_path_tail,
		    (struct db_full_path	*newp,
		     const struct db_full_path	*oldp,
		     int			start));
RT_EXPORT BU_EXTERN(char *db_path_to_string,
		    (const struct db_full_path *pp));
RT_EXPORT BU_EXTERN(void db_path_to_vls,
		    (struct bu_vls *str,
		     const struct db_full_path *pp));
RT_EXPORT BU_EXTERN(void db_pr_full_path,
		    (const char *msg,
		     const struct db_full_path *pathp));
RT_EXPORT BU_EXTERN(int db_string_to_path,
		    (struct db_full_path *pp,
		     const struct db_i *dbip,
		     const char *str));
RT_EXPORT BU_EXTERN(int db_argv_to_path,
		    (register struct db_full_path	*pp,
		     struct db_i			*dbip,
		     int				argc,
		     const char			*const*argv));
RT_EXPORT BU_EXTERN(void db_free_full_path,
		    (struct db_full_path *pp));
RT_EXPORT BU_EXTERN(int db_identical_full_paths,
		    ( const struct db_full_path *a,
		      const struct db_full_path *b));
RT_EXPORT BU_EXTERN(int db_full_path_subset,
		    (const struct db_full_path *a,
		     const struct db_full_path *b));
RT_EXPORT BU_EXTERN(int db_full_path_search,
		    (const struct db_full_path *a,
		     const struct directory *dp));


/* db_open.c */
RT_EXPORT BU_EXTERN(void db_sync,
		    (struct db_i	*dbip));

/* open an existing model database */
RT_EXPORT BU_EXTERN(struct db_i *db_open,
		    (const char *name,
		     const char *mode));
/* create a new model database */
RT_EXPORT BU_EXTERN(struct db_i *db_create,
		    (const char *name,
		     int version));
/* close a model database */
RT_EXPORT BU_EXTERN(void db_close_client,
		    (struct db_i *dbip,
		     long *client));
RT_EXPORT BU_EXTERN(void db_close,
		    (struct db_i *dbip));
/* dump a full copy of a database */
RT_EXPORT BU_EXTERN(int db_dump,
		    (struct rt_wdb *wdbp,
		     struct db_i *dbip));
RT_EXPORT BU_EXTERN(struct db_i *db_clone_dbi,
		    (struct db_i *dbip,
		     long *client));
/* db5_alloc.c */

RT_EXPORT BU_EXTERN(int db5_write_free,
		    (struct db_i *dbip,
		     struct directory *dp,
		     long length));
RT_EXPORT BU_EXTERN(int db5_realloc,
		    (struct db_i *dbip,
		     struct directory *dp,
		     struct bu_external *ep));

/* db5_io.c */
RT_EXPORT BU_EXTERN(void db5_export_object3,
		    (struct bu_external *out,
		     int			dli,
		     const char			*name,
		     const unsigned char	hidden,
		     const struct bu_external	*attrib,
		     const struct bu_external	*body,
		     int			major,
		     int			minor,
		     int			a_zzz,
		     int			b_zzz));
RT_EXPORT BU_EXTERN(int rt_db_cvt_to_external5,
		    (struct bu_external *ext,
		     const char *name,
		     const struct rt_db_internal *ip,
		     double conv2mm,
		     struct db_i *dbip,
		     struct resource *resp,
		     const int major));

RT_EXPORT BU_EXTERN(int db_wrap_v5_external,
		    (struct bu_external *ep,
		     const char *name));

RT_EXPORT BU_EXTERN(int rt_db_get_internal5,
		    (struct rt_db_internal	*ip,
		     const struct directory	*dp,
		     const struct db_i	*dbip,
		     const mat_t		mat,
		     struct resource		*resp));
RT_EXPORT BU_EXTERN(int rt_db_put_internal5,
		    (struct directory	*dp,
		     struct db_i		*dbip,
		     struct rt_db_internal	*ip,
		     struct resource		*resp,
		     const int		major));

RT_EXPORT BU_EXTERN(void db5_make_free_object_hdr,
		    (struct bu_external *ep,
		     long length));
RT_EXPORT BU_EXTERN(void db5_make_free_object,
		    (struct bu_external *ep,
		     long length));
RT_EXPORT BU_EXTERN(int db5_decode_signed,
		    (long			*lenp,
		     const unsigned char	*cp,
		     int			format));

RT_EXPORT BU_EXTERN(int db5_decode_length,
		    (long			*lenp,
		     const unsigned char	*cp,
		     int			format));

RT_EXPORT BU_EXTERN(int db5_select_length_encoding,
		    (long len));

RT_EXPORT BU_EXTERN(void db5_import_color_table,
		    (char *cp));

RT_EXPORT BU_EXTERN(int db5_import_attributes,
		    (struct bu_attribute_value_set *avs,
		     const struct bu_external *ap));

RT_EXPORT BU_EXTERN(void db5_export_attributes,
		    (struct bu_external *ap,
		     const struct bu_attribute_value_set *avs));

RT_EXPORT BU_EXTERN(int db5_get_raw_internal_fp,
		    (struct db5_raw_internal	*rip,
		     FILE			*fp));

RT_EXPORT BU_EXTERN(int db5_header_is_valid,
		    (const unsigned char *hp));

RT_EXPORT BU_EXTERN(int db5_fwrite_ident,
		    (FILE *,
		     const char *,
		     double));

RT_EXPORT BU_EXTERN(int db5_put_color_table,
		    (struct db_i *dbip));
RT_EXPORT BU_EXTERN(int db5_update_ident,
		    (struct db_i *dbip,
		     const char *title,
		     double local2mm));
RT_EXPORT BU_EXTERN(int db_put_external5,
		    (struct bu_external *ep,
		     struct directory *dp,
		     struct db_i *dbip));
RT_EXPORT BU_EXTERN(int db5_update_attributes,
		    (struct directory *dp,
		     struct bu_attribute_value_set *avsp,
		     struct db_i *dbip));
RT_EXPORT BU_EXTERN(int db5_update_attribute,
		    (const char *obj_name,
		     const char *aname,
		     const char *value,
		     struct db_i *dbip));
RT_EXPORT BU_EXTERN(int db5_replace_attributes,
		    (struct directory *dp,
		     struct bu_attribute_value_set *avsp,
		     struct db_i *dbip));
RT_EXPORT BU_EXTERN(int db5_get_attributes,
		    (const struct db_i *dbip,
		     struct bu_attribute_value_set *avs,
		     const struct directory *dp));

/* db_comb.c */
RT_EXPORT BU_EXTERN(int db_tree_nleaves,
		    (const union tree *tp));
RT_EXPORT BU_EXTERN(struct rt_tree_array *db_flatten_tree,
		    (struct rt_tree_array	*rt_tree_array,
		     union tree			*tp,
		     int			op,
		     int			avail,
		     struct resource		*resp));
RT_EXPORT BU_EXTERN(int rt_comb_import4,
		    (struct rt_db_internal	*ip,
		     const struct bu_external	*ep,
		     const mat_t		matrix,		/* NULL if identity */
		     const struct db_i		*dbip,
		     struct resource		*resp));
RT_EXPORT BU_EXTERN(int rt_comb_export4,
		    (struct bu_external			*ep,
		     const struct rt_db_internal	*ip,
		     double				local2mm,
		     const struct db_i			*dbip,
		     struct resource			*resp));
RT_EXPORT BU_EXTERN(void db_tree_flatten_describe,
		    (struct bu_vls	*vls,
		     const union tree	*tp,
		     int		indented,
		     int		lvl,
		     double		mm2local,
		     struct resource	*resp));
RT_EXPORT BU_EXTERN(void db_tree_describe,
		    (struct bu_vls	*vls,
		     const union tree	*tp,
		     int		indented,
		     int		lvl,
		     double		mm2local));
RT_EXPORT BU_EXTERN(void db_comb_describe,
		    (struct bu_vls	*str,
		     const struct rt_comb_internal	*comb,
		     int		verbose,
		     double		mm2local,
		     struct resource	*resp));
RT_EXPORT BU_EXTERN(void rt_comb_ifree,
		    (struct rt_db_internal *ip,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(int rt_comb_describe,
		    (struct bu_vls	*str,
		     const struct rt_db_internal *ip,
		     int		verbose,
		     double		mm2local,
		     struct resource *resp,
		     struct db_i *db_i));
RT_EXPORT BU_EXTERN(void db_wrap_v4_external,
		    (struct bu_external *op,
		     const char *name));
RT_EXPORT BU_EXTERN(int db_ck_left_heavy_tree,
		    (const union tree	*tp,
		     int		no_unions));
RT_EXPORT BU_EXTERN(int db_ck_v4gift_tree,
		    (const union tree *tp));
RT_EXPORT BU_EXTERN(union tree *db_mkbool_tree,
		    (struct rt_tree_array *rt_tree_array,
		     int		howfar,
		     struct resource	*resp));
RT_EXPORT BU_EXTERN(union tree *db_mkgift_tree,
		    (struct rt_tree_array	*trees,
		     int			subtreecount,
		     struct resource		*resp));

/* g_tgc.c */
RT_EXPORT BU_EXTERN(void rt_pt_sort,
		    (register fastf_t t[],
		     int npts));

/* g_ell.c */
RT_EXPORT BU_EXTERN(void rt_ell_16pts,
		    (register fastf_t *ov,
		     register fastf_t *V,
		     fastf_t *A,
		     fastf_t *B));


/* roots.c */
RT_EXPORT BU_EXTERN(int rt_poly_roots,
		    (bn_poly_t *eqn,
		     bn_complex_t roots[],
		     const char *name));


/* db_io.c */
RT_EXPORT BU_EXTERN(int db_write,
		    (struct db_i	*dbip,
		     const genptr_t	addr,
		     long		count,
		     long		offset));
RT_EXPORT BU_EXTERN(int db_fwrite_external,
		    (FILE			*fp,
		     const char		*name,
		     struct bu_external	*ep));

/* malloc & read records */
RT_EXPORT BU_EXTERN(union record *db_getmrec,
		    (const struct db_i *,
		     const struct directory *dp ));
/* get several records from db */
RT_EXPORT BU_EXTERN(int db_get,
		    (const struct db_i *,
		     const struct directory *dp,
		     union record *where,
		     int offset,
		     int len));
/* put several records into db */
RT_EXPORT BU_EXTERN(int db_put,
		    (struct db_i *,
		     const struct directory *dp,
		     union record *where,
		     int offset, int len));

RT_EXPORT BU_EXTERN(int db_get_external,
		    (struct bu_external *ep,
		     const struct directory *dp,
		     const struct db_i *dbip));
RT_EXPORT BU_EXTERN(int db_put_external,
		    (struct bu_external *ep,
		     struct directory *dp,
		     struct db_i *dbip));
RT_EXPORT BU_EXTERN(void db_free_external,
		    (struct bu_external *ep));

/* db_scan.c */
/* read db (to build directory) */
RT_EXPORT BU_EXTERN(int db_scan,
		    (struct db_i *,
		     int (*handler)BU_ARGS((struct db_i *,
					    const char *name,
					    long addr,
					    int nrec,
					    int flags,
					    genptr_t client_data)),
		     int do_old_matter,
		     genptr_t client_data));
/* update db unit conversions */
#define db_ident(a, b, c)		+++error+++
RT_EXPORT BU_EXTERN(int db_update_ident,
		    (struct db_i *dbip,
		     const char *title,
		     double local2mm));
RT_EXPORT BU_EXTERN(int db_fwrite_ident,
		    (FILE *fp,
		     const char *title,
		     double local2mm));
RT_EXPORT BU_EXTERN(void db_conversions,
		    (struct db_i *,
		     int units));
RT_EXPORT BU_EXTERN(int db_v4_get_units_code,
		    (const char *str));

/* db5_scan.c */
RT_EXPORT BU_EXTERN(int db_dirbuild,
		    (struct db_i *dbip));
RT_EXPORT BU_EXTERN(struct directory *db5_diradd,
		    (struct db_i *dbip,
		     const struct db5_raw_internal *rip,
		     long laddr,
		     genptr_t client_data));
RT_EXPORT BU_EXTERN(int db_get_version,
		    (struct db_i *dbip));
RT_EXPORT BU_EXTERN(int db5_scan,
		    (struct db_i *dbip,
		     void (*handler)(struct db_i *,
				     const struct db5_raw_internal *,
				     long addr,
				     genptr_t client_data),
		     genptr_t client_data));

/* db5_comb.c */
RT_EXPORT BU_EXTERN(int rt_comb_import5,
		    (struct rt_db_internal   *ip,
		     const struct bu_external *ep,
		     const mat_t             mat,
		     const struct db_i       *dbip,
		     struct resource         *resp,
		     const int		minor_type));

/* g_extrude.c */
RT_EXPORT BU_EXTERN(int rt_extrude_import5,
		    (struct rt_db_internal	*ip,
		     const struct bu_external	*ep,
		     register const mat_t	mat,
		     const struct db_i		*dbip,
		     struct resource		*resp,
		     const int			minor_type));


/* db_inmem.c */
RT_EXPORT BU_EXTERN(struct db_i * db_open_inmem, (void));

RT_EXPORT BU_EXTERN(struct db_i * db_create_inmem, (void));

RT_EXPORT BU_EXTERN(void db_inmem,
		    (struct directory	*dp,
		     struct bu_external	*ext,
		     int		flags,
		     struct db_i	*dbip));

/* db_lookup.c */
RT_EXPORT BU_EXTERN(int db_get_directory_size,
		    (const struct db_i	*dbip));
RT_EXPORT BU_EXTERN(void db_ck_directory,
		    (const struct db_i *dbip));

RT_EXPORT BU_EXTERN(int db_is_directory_non_empty,
		    (const struct db_i	*dbip));

RT_EXPORT BU_EXTERN(int db_dirhash,
		    (const char *str));
RT_EXPORT BU_EXTERN(int db_dircheck,
		    (struct db_i *dbip,
		     struct bu_vls *ret_name,
		     int noisy,
		     struct directory ***headp));
/* convert name to directory ptr */
RT_EXPORT BU_EXTERN(struct directory *db_lookup,
		    (const struct db_i *,
		     const char *name,
		     int noisy));
/* lookup directory entries based on attributes */
RT_EXPORT BU_EXTERN(struct bu_ptbl *db_lookup_by_attr,
		    (struct db_i *dbip,
		     int dir_flags,
		     struct bu_attribute_value_set *avs,
		     int op));
/* add entry to directory */
RT_EXPORT BU_EXTERN(struct directory *db_diradd,
		    (struct db_i *,
		     const char *name,
		     long laddr,
		     int len,
		     int flags,
		     genptr_t ptr));
RT_EXPORT BU_EXTERN(struct directory *db_diradd5,
		    (struct db_i *dbip,
		     const char *name,
		     long				laddr,
		     unsigned char			major_type,
		     unsigned char 			minor_type,
		     unsigned char			name_hidden,
		     long				object_length,
		     struct bu_attribute_value_set	*avs));

/* delete entry from directory */
RT_EXPORT BU_EXTERN(int db_dirdelete,
		    (struct db_i *,
		     struct directory *dp));
RT_EXPORT BU_EXTERN(int db_fwrite_ident,
		    (FILE *,
		     const char *,
		     double));
RT_EXPORT BU_EXTERN(void db_pr_dir,
		    (const struct db_i *dbip));
RT_EXPORT BU_EXTERN(int db_rename,
		    (struct db_i *,
		     struct directory *,
		     const char *newname));


/* db_match.c */
RT_EXPORT BU_EXTERN(void db_update_nref,
		    (struct db_i *dbip,
		     struct resource *resp));

RT_EXPORT BU_EXTERN(int db_regexp_match,
		    (const char *pattern,
		     const char *string));
RT_EXPORT BU_EXTERN(int db_regexp_match_all,
		    (struct bu_vls *dest,
		     struct db_i *dbip,
		     const char *pattern));

/* db_flags.c */
RT_EXPORT BU_EXTERN(int db_flags_internal,
		    (const struct rt_db_internal *intern));

RT_EXPORT BU_EXTERN(int db_flags_raw_internal,
		    (const struct db5_raw_internal *intern));

/* db_alloc.c */

/* allocate "count" granules */
RT_EXPORT BU_EXTERN(int db_alloc,
		    (struct db_i *,
		     struct directory *dp,
		     int count));
/* delete "recnum" from entry */
RT_EXPORT BU_EXTERN(int db_delrec,
		    (struct db_i *,
		     struct directory *dp,
		     int recnum));
/* delete all granules assigned dp */
RT_EXPORT BU_EXTERN(int db_delete,
		    (struct db_i *,
		     struct directory *dp));
/* write FREE records from 'start' */
RT_EXPORT BU_EXTERN(int db_zapper,
		    (struct db_i *,
		     struct directory *dp,
		     int start));

/* db_tree.c */
RT_EXPORT BU_EXTERN(void db_dup_db_tree_state,
		    (struct db_tree_state *otsp,
		     const struct db_tree_state *itsp));
RT_EXPORT BU_EXTERN(void db_free_db_tree_state,
		    (struct db_tree_state *tsp));
RT_EXPORT BU_EXTERN(void db_init_db_tree_state,
		    (struct db_tree_state *tsp,
		     struct db_i *dbip,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(struct combined_tree_state *db_new_combined_tree_state,
		    (const struct db_tree_state *tsp,
		     const struct db_full_path *pathp));
RT_EXPORT BU_EXTERN(struct combined_tree_state *db_dup_combined_tree_state,
		    (const struct combined_tree_state *old));
RT_EXPORT BU_EXTERN(void db_free_combined_tree_state,
		    (struct combined_tree_state *ctsp));
RT_EXPORT BU_EXTERN(void db_pr_tree_state,
		    (const struct db_tree_state *tsp));
RT_EXPORT BU_EXTERN(void db_pr_combined_tree_state,
		    (const struct combined_tree_state *ctsp));
RT_EXPORT BU_EXTERN(int db_apply_state_from_comb,
		    (struct db_tree_state *tsp,
		     const struct db_full_path *pathp,
		     const struct rt_comb_internal *comb));
RT_EXPORT BU_EXTERN(int db_apply_state_from_memb,
		    (struct db_tree_state *tsp,
		     struct db_full_path *pathp,
		     const union tree *tp));
RT_EXPORT BU_EXTERN(int db_apply_state_from_one_member,
		    (struct db_tree_state *tsp,
		     struct db_full_path *pathp,
		     const char *cp,
		     int sofar,
		     const union tree *tp));
RT_EXPORT BU_EXTERN(union tree *db_find_named_leaf,
		    (union tree *tp, const char *cp));
RT_EXPORT BU_EXTERN(union tree *db_find_named_leafs_parent,
		    (int *side,
		     union tree *tp,
		     const char *cp));
RT_EXPORT BU_EXTERN(void db_tree_del_lhs,
		    (union tree *tp,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(void db_tree_del_rhs,
		    (union tree *tp,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(int db_tree_del_dbleaf,
		    (union tree **tp,
		     const char *cp,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(void db_tree_mul_dbleaf,
		    (union tree *tp,
		     const mat_t mat));
RT_EXPORT BU_EXTERN(void db_tree_funcleaf,
		    (struct db_i		*dbip,
		     struct rt_comb_internal	*comb,
		     union tree		*comb_tree,
		     void		(*leaf_func)(),
		     genptr_t		user_ptr1,
		     genptr_t		user_ptr2,
		     genptr_t		user_ptr3));
RT_EXPORT BU_EXTERN(int db_follow_path,
		    (struct db_tree_state	*tsp,
		     struct db_full_path	*total_path,
		     const struct db_full_path	*new_path,
		     int			noisy,
		     int			depth));
RT_EXPORT BU_EXTERN(int db_follow_path_for_state,
		    (struct db_tree_state *tsp,
		     struct db_full_path *pathp,
		     const char *orig_str, int noisy));
RT_EXPORT BU_EXTERN(union tree *db_recurse,
		    (struct db_tree_state	*tsp,
		     struct db_full_path *pathp,
		     struct combined_tree_state **region_start_statepp,
		     genptr_t client_data));
RT_EXPORT BU_EXTERN(union tree *db_dup_subtree,
		    (const union tree *tp,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(void db_ck_tree,
		    (const union tree *tp));
RT_EXPORT BU_EXTERN(void db_free_tree,
		    (union tree *tp,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(void db_left_hvy_node,
		    (union tree *tp));
RT_EXPORT BU_EXTERN(void db_non_union_push,
		    (union tree *tp,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(int db_count_tree_nodes,
		    (const union tree *tp,
		     int count));
RT_EXPORT BU_EXTERN(int db_is_tree_all_unions,
		    (const union tree *tp));
RT_EXPORT BU_EXTERN(int db_count_subtree_regions,
		    (const union tree *tp));
RT_EXPORT BU_EXTERN(int db_tally_subtree_regions,
		    (union tree	*tp,
		     union tree	**reg_trees,
		     int		cur,
		     int		lim,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(int db_walk_tree,
		    (struct db_i *dbip,
		     int argc,
		     const char **argv,
		     int ncpu,
		     const struct db_tree_state *init_state,
		     int (*reg_start_func) (struct db_tree_state * /*tsp*/,
					    struct db_full_path * /*pathp*/,
					    const struct rt_comb_internal * /* combp */,
					    genptr_t client_data),
		     union tree *(*reg_end_func) (struct db_tree_state * /*tsp*/,
						  struct db_full_path * /*pathp*/,
						  union tree * /*curtree*/,
						  genptr_t client_data),
		     union tree *(*leaf_func) (struct db_tree_state * /*tsp*/,
					       struct db_full_path * /*pathp*/,
					       struct rt_db_internal * /*ip*/,
					       genptr_t client_data ),
		     genptr_t client_data ));
RT_EXPORT BU_EXTERN(int db_path_to_mat,
		    (struct db_i		*dbip,
		     struct db_full_path	*pathp,
		     mat_t			mat,		/* result */
		     int			depth,		/* number of arcs */
		     struct resource		*resp));
RT_EXPORT BU_EXTERN(void db_apply_anims,
		    (struct db_full_path *pathp,
		     struct directory *dp,
		     mat_t stck,
		     mat_t arc,
		     struct mater_info *materp));
/* XXX db_shader_mat, should be called rt_shader_mat */
RT_EXPORT BU_EXTERN(int db_region_mat,
		    (mat_t		m,		/* result */
		     struct db_i	*dbip,
		     const char	*name,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(int db_shader_mat,
		    (mat_t			model_to_shader,	/* result */
		     const struct rt_i	*rtip,
		     const struct region	*rp,
		     point_t			p_min,	/* input/output: shader/region min point */
		     point_t			p_max,	/* input/output: shader/region max point */
		     struct resource		*resp));

/* dir.c */
RT_EXPORT BU_EXTERN(struct rt_i *rt_dirbuild,
		    (const char *filename,
		     char *buf, int len));
RT_EXPORT BU_EXTERN(int rt_db_get_internal,
		    (struct rt_db_internal	*ip,
		     const struct directory	*dp,
		     const struct db_i	*dbip,
		     const mat_t		mat,
		     struct resource		*resp));
RT_EXPORT BU_EXTERN(int rt_db_put_internal,
		    (struct directory	*dp,
		     struct db_i		*dbip,
		     struct rt_db_internal	*ip,
		     struct resource		*resp));
RT_EXPORT BU_EXTERN(int rt_fwrite_internal,
		    (FILE *fp,
		     const char *name,
		     const struct rt_db_internal *ip,
		     double conv2mm));
RT_EXPORT BU_EXTERN(void rt_db_free_internal,
		    (struct rt_db_internal *ip,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(int rt_db_lookup_internal,
		    (struct db_i *dbip,
		     const char *obj_name,
		     struct directory **dpp,
		     struct rt_db_internal *ip,
		     int noisy,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(void rt_optim_tree,
		    (register union tree *tp,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(void db_get_directory,
		    (register struct resource *resp));

/* db_walk.c */
RT_EXPORT BU_EXTERN(void db_functree,
		    (struct db_i *dbip,
		     struct directory *dp,
		     void (*comb_func)(struct db_i *,
				       struct directory *,
				       genptr_t),
		     void (*leaf_func)(struct db_i *,
				       struct directory *,
				       genptr_t),
		     struct resource *resp,
		     genptr_t client_data));

/* mirror.c */
RT_EXPORT BU_EXTERN(struct directory *rt_mirror,
		    (struct db_i *dpip,
		     const char	*from,
		     const char *to,
		     point_t mirror_origin,
		     vect_t mirror_dir,
		     fastf_t mirror_pt,
		     struct resource *resp));

/*
  RT_EXPORT BU_EXTERN(void db_preorder_traverse,
  (struct directory *dp,
  struct db_traverse *dtp));
*/

/* g_arb.c */
RT_EXPORT BU_EXTERN(int rt_arb_get_cgtype,
		    ());		/* needs rt_arb_internal for arg list */
RT_EXPORT BU_EXTERN(int rt_arb_std_type,
		    (const struct rt_db_internal *ip,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void rt_arb_centroid,
		    ());		/* needs rt_arb_internal for arg list */
RT_EXPORT BU_EXTERN(int rt_arb_calc_points,
		    ());		/* needs wdb.h for arg list */
RT_EXPORT BU_EXTERN(int rt_arb_3face_intersect,
		    (point_t			point,
		     const plane_t		planes[6],
		     int			type,		/* 4..8 */
		     int			loc));
#ifdef __RTGEOM_H__
RT_EXPORT BU_EXTERN(int rt_arb_calc_planes,
		    (Tcl_Interp			*interp,
		     struct rt_arb_internal	*arb,
		     int			type,
		     plane_t			planes[6],
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int rt_arb_move_edge,
		    (Tcl_Interp		*interp,
		     struct rt_arb_internal	*arb,
		     vect_t			thru,
		     int			bp1,
		     int			bp2,
		     int			end1,
		     int			end2,
		     const vect_t		dir,
		     plane_t			planes[6],
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int rt_arb_edit,
		    (Tcl_Interp			*interp,
		     struct rt_arb_internal	*arb,
		     int			arb_type,
		     int			edit_type,
		     vect_t			pos_model,
		     plane_t			planes[6],
		     const struct bn_tol	*tol));
#endif

RT_EXPORT extern const int rt_arb_faces[5][24];
RT_EXPORT extern short earb8[12][18];
RT_EXPORT extern short earb7[12][18];
RT_EXPORT extern short earb6[10][18];
RT_EXPORT extern short earb5[9][18];
RT_EXPORT extern short earb4[5][18];

/* g_epa.c */
RT_EXPORT BU_EXTERN(void rt_ell,
		    (fastf_t *ov,
		     const fastf_t *V,
		     const fastf_t *A,
		     const fastf_t *B,
		     int sides));

/* g_pipe.c */
RT_EXPORT BU_EXTERN(void rt_vls_pipept,
		    (struct bu_vls *vp,
		     int seg_no,
		     const struct rt_db_internal *ip,
		     double mm2local));
RT_EXPORT BU_EXTERN(void rt_pipept_print,
		    ());		/* needs wdb_pipept for arg */
RT_EXPORT BU_EXTERN(int rt_pipe_ck,
		    (const struct bu_list *headp));

/* g_metaball.c */
struct rt_metaball_internal;
RT_EXPORT BU_EXTERN(void rt_vls_metaballpt,
		    (struct bu_vls *vp,
		     int pt_no,
		     const struct rt_db_internal *ip,
		     double mm2local));
RT_EXPORT BU_EXTERN(void rt_metaballpt_print,
		    ());		/* needs wdb_metaballpt for arg */
RT_EXPORT BU_EXTERN(int rt_metaball_ck,
		    (const struct bu_list *headp));
RT_EXPORT BU_EXTERN(fastf_t rt_metaball_point_value,
		    (point_t *p,
		     struct rt_metaball_internal *mb));
RT_EXPORT BU_EXTERN(int rt_metaball_lookup_type_id,
		    (const char *name));
RT_EXPORT BU_EXTERN(const char *rt_metaball_lookup_type_name,
		    (const int id));

/* g_rpc.c */
RT_EXPORT BU_EXTERN(int rt_mk_parabola,
		    (struct rt_pt_node *pts,
		     fastf_t r,
		     fastf_t b,
		     fastf_t dtol,
		     fastf_t ntol));
RT_EXPORT BU_EXTERN(struct rt_pt_node *rt_ptalloc,
		    ());

/* memalloc.c -- non PARALLEL routines */
RT_EXPORT BU_EXTERN(unsigned long rt_memalloc,
		    (struct mem_map **pp,
		     unsigned size));
RT_EXPORT BU_EXTERN(struct mem_map * rt_memalloc_nosplit,
		    (struct mem_map **pp,
		     unsigned size));
RT_EXPORT BU_EXTERN(unsigned long rt_memget,
		    (struct mem_map **pp,
		     unsigned int size,
		     unsigned int place));
RT_EXPORT BU_EXTERN(void rt_memfree,
		    (struct mem_map **pp,
		     unsigned size,
		     unsigned long addr));
RT_EXPORT BU_EXTERN(void rt_mempurge,
		    (struct mem_map **pp));
RT_EXPORT BU_EXTERN(void rt_memprint,
		    (struct mem_map **pp));
RT_EXPORT BU_EXTERN(void rt_memclose,
		    ());

RT_EXPORT BU_EXTERN(struct bn_vlblock *rt_vlblock_init,
		    ());
RT_EXPORT BU_EXTERN(void rt_vlblock_free,
		    (struct bn_vlblock *vbp));
RT_EXPORT BU_EXTERN(struct bu_list *rt_vlblock_find,
		    (struct bn_vlblock *vbp,
		     int r,
		     int g,
		     int b));

/* g_ars.c */
RT_EXPORT BU_EXTERN(void rt_hitsort,
		    (struct hit h[],
		     int nh));

/* g_pg.c */
RT_EXPORT BU_EXTERN(int rt_pg_to_bot,
		    (struct rt_db_internal *ip,
		     const struct bn_tol *tol,
		     struct resource *resp0));
RT_EXPORT BU_EXTERN(int rt_pg_plot,
		    (struct bu_list		*vhead,
		     struct rt_db_internal	*ip,
		     const struct rt_tess_tol *ttol,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int rt_pg_plot_poly,
		    (struct bu_list		*vhead,
		     struct rt_db_internal	*ip,
		     const struct rt_tess_tol	*ttol,
		     const struct bn_tol	*tol));

/* g_hf.c */
RT_EXPORT BU_EXTERN(int rt_hf_to_dsp,
		    (struct rt_db_internal *db_intern,
		     struct resource *resp));

/* g_dsp.c */
RT_EXPORT BU_EXTERN(int dsp_pos,
		    (point_t out,
		     struct soltab *stp,
		     point_t p));

/* pr.c */
RT_EXPORT BU_EXTERN(void rt_pr_soltab,
		    (const struct soltab *stp));
RT_EXPORT BU_EXTERN(void rt_pr_region,
		    (const struct region *rp));
RT_EXPORT BU_EXTERN(void rt_pr_partitions,
		    (const struct rt_i *rtip,
		     const struct partition	*phead,
		     const char *title));
RT_EXPORT BU_EXTERN(void rt_pr_pt_vls,
		    (struct bu_vls *v,
		     const struct rt_i *rtip,
		     const struct partition *pp));
RT_EXPORT BU_EXTERN(void rt_pr_pt,
		    (const struct rt_i *rtip,
		     const struct partition *pp));
RT_EXPORT BU_EXTERN(void rt_pr_seg_vls,
		    (struct bu_vls *,
		     const struct seg *));
RT_EXPORT BU_EXTERN(void rt_pr_seg,
		    (const struct seg *segp));
RT_EXPORT BU_EXTERN(void rt_pr_hit,
		    (const char *str,
		     const struct hit	*hitp));
RT_EXPORT BU_EXTERN(void rt_pr_hit_vls,
		    (struct bu_vls *v,
		     const char *str,
		     const struct hit *hitp));
RT_EXPORT BU_EXTERN(void rt_pr_hitarray_vls,
		    (struct bu_vls *v,
		     const char *str,
		     const struct hit *hitp,
		     int count));
RT_EXPORT BU_EXTERN(void rt_pr_tree,
		    (const union tree *tp,
		     int lvl));
RT_EXPORT BU_EXTERN(void rt_pr_tree_vls,
		    (struct bu_vls *vls,
		     const union tree *tp));
RT_EXPORT BU_EXTERN(char *rt_pr_tree_str,
		    (const union tree *tree));
RT_EXPORT BU_EXTERN(void rt_pr_tree_val,
		    (const union tree *tp,
		     const struct partition *partp,
		     int pr_name,
		     int lvl));
RT_EXPORT BU_EXTERN(void rt_pr_fallback_angle,
		    (struct bu_vls *str,
		     const char *prefix,
		     const double angles[5]));
RT_EXPORT BU_EXTERN(void rt_find_fallback_angle,
		    (double angles[5],
		     const vect_t vec));
RT_EXPORT BU_EXTERN(void rt_pr_tol,
		    (const struct bn_tol *tol));

/* regionfix.c */
RT_EXPORT BU_EXTERN(void rt_regionfix,
		    (struct rt_i *rtip));

/* table.c */
RT_EXPORT BU_EXTERN(int rt_id_solid,
		    (struct bu_external *ep));
RT_EXPORT BU_EXTERN(const struct rt_functab *rt_get_functab_by_label,
		    (const char *label));
RT_EXPORT BU_EXTERN(int rt_generic_xform,
		    (struct rt_db_internal	*op,
		     const mat_t		mat,
		     struct rt_db_internal	*ip,
		     int			avail,
		     struct db_i		*dbip,
		     struct resource		*resp));

RT_EXPORT BU_EXTERN(void rt_nul_make,
		    (const struct rt_functab *ftp,
		     struct rt_db_internal *intern,
		     double diameter));

/* prep.c */
RT_EXPORT BU_EXTERN(void rt_plot_all_bboxes,
		    (FILE *fp,
		     struct rt_i *rtip));
RT_EXPORT BU_EXTERN(void rt_plot_all_solids,
		    (FILE		*fp,
		     struct rt_i	*rtip,
		     struct resource	*resp));
RT_EXPORT BU_EXTERN(void rt_init_resource,
		    (struct resource *resp,
		     int		cpu_num,
		     struct rt_i	*rtip));
RT_EXPORT BU_EXTERN(void rt_clean_resource,
		    (struct rt_i *rtip,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(int rt_unprep,
		    (struct rt_i *rtip,
		     struct rt_reprep_obj_list *objs,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(int rt_reprep,
		    (struct rt_i *rtip,
		     struct rt_reprep_obj_list *objs,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(int re_prep_solids,
		    (struct rt_i *rtip,
		     int num_solids,
		     char **solid_names,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(int rt_find_paths,
		    (struct db_i *dbip,
		     struct directory *start,
		     struct directory *end,
		     struct bu_ptbl *paths,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(struct bu_bitv *get_solidbitv,
		    (long nbits,
		     struct resource *resp));

/* shoot.c */
RT_EXPORT BU_EXTERN(void rt_add_res_stats,
		    (struct rt_i *rtip,
		     struct resource *resp));
/* Tally stats into struct rt_i */
RT_EXPORT BU_EXTERN(void rt_zero_res_stats,
		    (struct resource *resp));
RT_EXPORT BU_EXTERN(void rt_res_pieces_clean,
		    (struct resource *resp,
		     struct rt_i *rtip));
RT_EXPORT BU_EXTERN(void rt_res_pieces_init,
		    (struct resource *resp,
		     struct rt_i *rtip));
RT_EXPORT BU_EXTERN(void rt_vstub,
		    (struct soltab *stp[],
		     struct xray *rp[],
		     struct  seg segp[],
		     int n,
		     struct application	*ap));


/* tree.c */
RT_EXPORT BU_EXTERN(int rt_bound_tree,
		    (const union tree	*tp,
		     vect_t		tree_min,
		     vect_t		tree_max));
RT_EXPORT BU_EXTERN(int rt_tree_elim_nops,
		    (union tree *,
		     struct resource *resp));


/* vlist.c */
/* XXX Has some stuff mixed in here that should go in LIBBN */
RT_EXPORT BU_EXTERN(struct bn_vlblock *bn_vlblock_init,
		    (struct bu_list	*free_vlist_hd,	/* where to get/put free vlists */
		     int		max_ent));
RT_EXPORT BU_EXTERN(struct bn_vlblock *	rt_vlblock_init,
		    ());
RT_EXPORT BU_EXTERN(void rt_vlblock_free,
		    (struct bn_vlblock *vbp));
RT_EXPORT BU_EXTERN(struct bu_list *rt_vlblock_find,
		    (struct bn_vlblock *vbp,
		     int r,
		     int g,
		     int b));
RT_EXPORT BU_EXTERN(int rt_ck_vlist,
		    (const struct bu_list *vhead));
RT_EXPORT BU_EXTERN(void rt_vlist_copy,
		    (struct bu_list *dest,
		     const struct bu_list *src));
RT_EXPORT BU_EXTERN(void bn_vlist_cleanup,
		    (struct bu_list *hd));
RT_EXPORT BU_EXTERN(void rt_vlist_cleanup,
		    ());
RT_EXPORT BU_EXTERN(void bn_vlist_rpp,
		    (struct bu_list *hd,
		     const point_t minn,
		     const point_t maxx));
RT_EXPORT BU_EXTERN(void rt_vlist_export,
		    (struct bu_vls *vls,
		     struct bu_list *hp,
		     const char *name));
RT_EXPORT BU_EXTERN(void rt_vlist_import,
		    (struct bu_list *hp,
		     struct bu_vls *namevls,
		     const unsigned char *buf));
RT_EXPORT BU_EXTERN(void rt_plot_vlblock,
		    (FILE *fp,
		     const struct bn_vlblock *vbp));
RT_EXPORT BU_EXTERN(void rt_vlist_to_uplot,
		    (FILE *fp,
		     const struct bu_list *vhead));
RT_EXPORT BU_EXTERN(int rt_process_uplot_value,
		    (struct bu_list **vhead,
		     struct bn_vlblock *vbp,
		     FILE *fp,
		     int c,
		     double char_size,
		     int mode));
RT_EXPORT BU_EXTERN(int rt_uplot_to_vlist,
		    (struct bn_vlblock *vbp,
		     FILE *fp,
		     double char_size,
		     int mode));
RT_EXPORT BU_EXTERN(void rt_label_vlist_verts,
		    (struct bn_vlblock *vbp,
		     struct bu_list *src,
		     mat_t mat,
		     double sz,
		     double mm2local));

#ifdef __RTGEOM_H__
/* g_sketch.c */
RT_EXPORT BU_EXTERN(void rt_sketch_ifree,
		    (struct rt_db_internal	*ip));
RT_EXPORT BU_EXTERN(int curve_to_vlist,
		    (struct bu_list		*vhead,
		     const struct rt_tess_tol	*ttol,
		     point_t			V,
		     vect_t			u_vec,
		     vect_t			v_vec,
		     struct rt_sketch_internal *sketch_ip,
		     struct curve		*crv));

RT_EXPORT BU_EXTERN(int rt_check_curve,
		    (struct curve *crv,
		     struct rt_sketch_internal *skt,
		     int noisey));

RT_EXPORT BU_EXTERN(void rt_curve_reverse_segment,
		    (long *lng));
RT_EXPORT BU_EXTERN(void rt_curve_order_segments,
		    (struct curve *crv));

RT_EXPORT BU_EXTERN(void rt_copy_curve,
		    (struct curve *crv_out,
		     const struct curve *crv_in));

RT_EXPORT BU_EXTERN(int rt_check_curve,
		    (struct curve *crv,
		     struct rt_sketch_internal *skt,
		     int noisey));
RT_EXPORT BU_EXTERN(void rt_curve_free,
		    (struct curve *crv));
RT_EXPORT BU_EXTERN(void rt_copy_curve,
		    (struct curve *crv_out,
		     const struct curve *crv_in));
RT_EXPORT BU_EXTERN(struct rt_sketch_internal *rt_copy_sketch,
		    (const struct rt_sketch_internal *sketch_ip));
RT_EXPORT BU_EXTERN(int curve_to_tcl_list,
		    (struct bu_vls *vls,
		     struct curve *crv));
#endif

/* htbl.c */
RT_EXPORT BU_EXTERN(void rt_htbl_init,
		    (struct rt_htbl *b,
		     int len,
		     const char *str));
RT_EXPORT BU_EXTERN(void rt_htbl_reset,
		    (struct rt_htbl *b));
RT_EXPORT BU_EXTERN(void rt_htbl_free,
		    (struct rt_htbl *b));
RT_EXPORT BU_EXTERN(struct hit *rt_htbl_get,
		    (struct rt_htbl *b));

/************************************************************************
 *									*
 *			N M G Support Function Declarations		*
 *									*
 ************************************************************************/
#if defined(__NMG_H__)

/* From file nmg_mk.c */
/*	MAKE routines */
RT_EXPORT BU_EXTERN(struct model *nmg_mm,
		    ());
RT_EXPORT BU_EXTERN(struct model *nmg_mmr,
		    ());
RT_EXPORT BU_EXTERN(struct nmgregion *nmg_mrsv,
		    (struct model *m));
RT_EXPORT BU_EXTERN(struct shell *nmg_msv,
		    (struct nmgregion *r_p));
RT_EXPORT BU_EXTERN(struct faceuse *nmg_mf,
		    (struct loopuse *lu1));
RT_EXPORT BU_EXTERN(struct loopuse *nmg_mlv,
		    (unsigned long *magic,
		     struct vertex *v,
		     int orientation));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_me,
		    (struct vertex *v1,
		     struct vertex *v2,
		     struct shell *s));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_meonvu,
		    (struct vertexuse *vu));
RT_EXPORT BU_EXTERN(struct loopuse *nmg_ml,
		    (struct shell *s));
/*	KILL routines */
RT_EXPORT BU_EXTERN(int nmg_keg,
		    (struct edgeuse *eu));
RT_EXPORT BU_EXTERN(int nmg_kvu,
		    (struct vertexuse *vu));
RT_EXPORT BU_EXTERN(int nmg_kfu,
		    (struct faceuse *fu1));
RT_EXPORT BU_EXTERN(int nmg_klu,
		    (struct loopuse *lu1));
RT_EXPORT BU_EXTERN(int nmg_keu,
		    (struct edgeuse *eu));
RT_EXPORT BU_EXTERN(int nmg_ks,
		    (struct shell *s));
RT_EXPORT BU_EXTERN(int nmg_kr,
		    (struct nmgregion *r));
RT_EXPORT BU_EXTERN(void nmg_km,
		    (struct model *m));
/*	Geometry and Attribute routines */
RT_EXPORT BU_EXTERN(void nmg_vertex_gv,
		    (struct vertex *v,
		     const point_t pt));
RT_EXPORT BU_EXTERN(void nmg_vertex_g,
		    (struct vertex *v,
		     fastf_t x,
		     fastf_t y,
		     fastf_t z));
RT_EXPORT BU_EXTERN(void nmg_vertexuse_nv,
		    (struct vertexuse *vu,
		     const vect_t norm));
RT_EXPORT BU_EXTERN(void nmg_vertexuse_a_cnurb,
		    (struct vertexuse *vu,
		     const fastf_t *uvw));
RT_EXPORT BU_EXTERN(void nmg_edge_g,
		    (struct edgeuse *eu));
RT_EXPORT BU_EXTERN(void nmg_edge_g_cnurb,
		    (struct edgeuse *eu,
		     int order,
		     int n_knots,
		     fastf_t *kv,
		     int n_pts,
		     int pt_type,
		     fastf_t *points));
RT_EXPORT BU_EXTERN(void nmg_edge_g_cnurb_plinear,
		    (struct edgeuse *eu));
RT_EXPORT BU_EXTERN(int nmg_use_edge_g,
		    (struct edgeuse *eu,
		     unsigned long *eg));
RT_EXPORT BU_EXTERN(void nmg_loop_g,
		    (struct loop *l,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_face_g,
		    (struct faceuse *fu,
		     const plane_t p));
RT_EXPORT BU_EXTERN(void nmg_face_new_g,
		    (struct faceuse *fu,
		     const plane_t pl));
RT_EXPORT BU_EXTERN(void nmg_face_g_snurb,
		    (struct faceuse *fu,
		     int u_order,
		     int v_order,
		     int n_u_knots,
		     int n_v_knots,
		     fastf_t *ukv,
		     fastf_t *vkv,
		     int n_rows,
		     int n_cols,
		     int pt_type,
		     fastf_t *mesh));
RT_EXPORT BU_EXTERN(void nmg_face_bb,
		    (struct face *f,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_shell_a,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_region_a,
		    (struct nmgregion *r,
		     const struct bn_tol *tol));
/*	DEMOTE routines */
RT_EXPORT BU_EXTERN(int nmg_demote_lu,
		    (struct loopuse *lu));
RT_EXPORT BU_EXTERN(int nmg_demote_eu,
		    (struct edgeuse *eu));
/*	MODIFY routines */
RT_EXPORT BU_EXTERN(void nmg_movevu,
		    (struct vertexuse *vu,
		     struct vertex *v));
#define nmg_moveeu(a, b)		nmg_je(a, b)
RT_EXPORT BU_EXTERN(void nmg_je,
		    (struct edgeuse *eudst,
		     struct edgeuse *eusrc));
RT_EXPORT BU_EXTERN(void nmg_unglueedge,
		    (struct edgeuse *eu));
RT_EXPORT BU_EXTERN(void nmg_jv,
		    (struct vertex *v1,
		     struct vertex *v2));
RT_EXPORT BU_EXTERN(void nmg_jfg,
		    (struct face *f1,
		     struct face *f2));
RT_EXPORT BU_EXTERN(void nmg_jeg,
		    (struct edge_g_lseg *dest_eg,
		     struct edge_g_lseg *src_eg));

/* From nmg_mod.c */
/*	REGION Routines */
RT_EXPORT BU_EXTERN(void nmg_merge_regions,
		    (struct nmgregion *r1,
		     struct nmgregion *r2,
		     const struct bn_tol *tol));

/*	SHELL Routines */
RT_EXPORT BU_EXTERN(void nmg_shell_coplanar_face_merge,
		    (struct shell *s,
		     const struct bn_tol *tol,
		     const int simplify));
RT_EXPORT BU_EXTERN(int nmg_simplify_shell,
		    (struct shell *s));
RT_EXPORT BU_EXTERN(void nmg_rm_redundancies,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_sanitize_s_lv,
		    (struct shell *s,
		     int orient));
RT_EXPORT BU_EXTERN(void nmg_s_split_touchingloops,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_s_join_touchingloops,
		    (struct shell		*s,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_js,
		    (struct shell	*s1,
		     struct shell	*s2,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_invert_shell,
		    (struct shell		*s));

/*	FACE Routines */
RT_EXPORT BU_EXTERN(struct faceuse *nmg_cmface,
		    (struct shell *s,
		     struct vertex **vt[],
		     int n));
RT_EXPORT BU_EXTERN(struct faceuse *nmg_cface,
		    (struct shell *s,
		     struct vertex **vt,
		     int n));
RT_EXPORT BU_EXTERN(struct faceuse *nmg_add_loop_to_face,
		    (struct shell *s,
		     struct faceuse *fu,
		     struct vertex **verts,
		     int n,
		     int dir));
RT_EXPORT BU_EXTERN(int nmg_fu_planeeqn,
		    (struct faceuse *fu,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_gluefaces,
		    (struct faceuse *fulist[],
		     int n,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_simplify_face,
		    (struct faceuse *fu));
RT_EXPORT BU_EXTERN(void nmg_reverse_face,
		    (struct faceuse *fu));
RT_EXPORT BU_EXTERN(void nmg_mv_fu_between_shells,
		    (struct shell *dest,
		     struct shell *src,
		     struct faceuse *fu));
RT_EXPORT BU_EXTERN(void nmg_jf,
		    (struct faceuse *dest_fu,
		     struct faceuse *src_fu));
RT_EXPORT BU_EXTERN(struct faceuse *nmg_dup_face,
		    (struct faceuse *fu,
		     struct shell *s));
/*	LOOP Routines */
RT_EXPORT BU_EXTERN(void nmg_jl,
		    (struct loopuse *lu,
		     struct edgeuse *eu));
RT_EXPORT BU_EXTERN(struct vertexuse *nmg_join_2loops,
		    (struct vertexuse *vu1,
		     struct vertexuse *vu2));
RT_EXPORT BU_EXTERN(struct vertexuse *nmg_join_singvu_loop,
		    (struct vertexuse *vu1,
		     struct vertexuse *vu2));
RT_EXPORT BU_EXTERN(struct vertexuse *nmg_join_2singvu_loops,
		    (struct vertexuse *vu1,
		     struct vertexuse *vu2));
RT_EXPORT BU_EXTERN(struct loopuse *nmg_cut_loop,
		    (struct vertexuse *vu1,
		     struct vertexuse *vu2));
RT_EXPORT BU_EXTERN(struct loopuse *nmg_split_lu_at_vu,
		    (struct loopuse *lu,
		     struct vertexuse *vu));
RT_EXPORT BU_EXTERN(struct vertexuse *nmg_find_repeated_v_in_lu,
		    (struct vertexuse *vu));
RT_EXPORT BU_EXTERN(void nmg_split_touchingloops,
		    (struct loopuse *lu,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_join_touchingloops,
		    (struct loopuse *lu));
RT_EXPORT BU_EXTERN(int nmg_get_touching_jaunts,
		    (const struct loopuse *lu,
		     struct bu_ptbl *tbl,
		     int *need_init));
RT_EXPORT BU_EXTERN(void nmg_kill_accordions,
		    (struct loopuse *lu));
RT_EXPORT BU_EXTERN(int nmg_loop_split_at_touching_jaunt,
		    (struct loopuse		*lu,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_simplify_loop,
		    (struct loopuse *lu));
RT_EXPORT BU_EXTERN(int nmg_kill_snakes,
		    (struct loopuse *lu));
RT_EXPORT BU_EXTERN(void nmg_mv_lu_between_shells,
		    (struct shell *dest,
		     struct shell *src,
		     struct loopuse *lu));
RT_EXPORT BU_EXTERN(void nmg_moveltof,
		    (struct faceuse *fu,
		     struct shell *s));
RT_EXPORT BU_EXTERN(struct loopuse *nmg_dup_loop,
		    (struct loopuse *lu,
		     unsigned long *parent,
		     long **trans_tbl));
RT_EXPORT BU_EXTERN(void nmg_set_lu_orientation,
		    (struct loopuse *lu,
		     int is_opposite));
RT_EXPORT BU_EXTERN(void nmg_lu_reorient,
		    (struct loopuse *lu));
/*	EDGE Routines */
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_eusplit,
		    (struct vertex *v,
		     struct edgeuse *oldeu,
		     int share_geom));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_esplit,
		    (struct vertex *v,
		     struct edgeuse *eu,
		     int share_geom));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_ebreak,
		    (struct vertex *v,
		     struct edgeuse *eu));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_ebreaker,
		    (struct vertex *v,
		     struct edgeuse *eu,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct vertex *nmg_e2break,
		    (struct edgeuse *eu1,
		     struct edgeuse *eu2));
RT_EXPORT BU_EXTERN(int nmg_unbreak_edge,
		    (struct edgeuse *eu1_first));
RT_EXPORT BU_EXTERN(int nmg_unbreak_shell_edge_unsafe,
		    (struct edgeuse *eu1_first));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_eins,
		    (struct edgeuse *eu));
RT_EXPORT BU_EXTERN(void nmg_mv_eu_between_shells,
		    (struct shell *dest,
		     struct shell *src,
		     struct edgeuse *eu));
/*	VERTEX Routines */
RT_EXPORT BU_EXTERN(void nmg_mv_vu_between_shells,
		    (struct shell *dest,
		     struct shell *src,
		     struct vertexuse *vu));

/* From nmg_info.c */
/* Model routines */
RT_EXPORT BU_EXTERN(struct model *nmg_find_model,
		    (const unsigned long *magic_p));
RT_EXPORT BU_EXTERN(void nmg_model_bb,
		    (point_t min_pt,
		     point_t max_pt,
		     const struct model *m));


/* Shell routines */
RT_EXPORT BU_EXTERN(int nmg_shell_is_empty,
		    (const struct shell *s));
RT_EXPORT BU_EXTERN(struct shell *nmg_find_s_of_lu,
		    (const struct loopuse *lu));
RT_EXPORT BU_EXTERN(struct shell *nmg_find_s_of_eu,
		    (const struct edgeuse *eu));
RT_EXPORT BU_EXTERN(struct shell *nmg_find_s_of_vu,
		    (const struct vertexuse *vu));

/* Face routines */
RT_EXPORT BU_EXTERN(struct faceuse *nmg_find_fu_of_eu,
		    (const struct edgeuse *eu));
RT_EXPORT BU_EXTERN(struct faceuse *nmg_find_fu_of_lu,
		    (const struct loopuse *lu));
RT_EXPORT BU_EXTERN(struct faceuse *nmg_find_fu_of_vu,
		    (const struct vertexuse *vu));
RT_EXPORT BU_EXTERN(struct faceuse *nmg_find_fu_with_fg_in_s,
		    (const struct shell *s1,
		     const struct faceuse *fu2));
RT_EXPORT BU_EXTERN(double nmg_measure_fu_angle,
		    (const struct edgeuse *eu,
		     const vect_t xvec,
		     const vect_t yvec,
		     const vect_t zvec));

/* Loop routines */
RT_EXPORT BU_EXTERN(struct loopuse*nmg_find_lu_of_vu,
		    (const struct vertexuse *vu));
RT_EXPORT BU_EXTERN(int nmg_loop_is_a_crack,
		    (const struct loopuse *lu));
RT_EXPORT BU_EXTERN(int	nmg_loop_is_ccw,
		    (const struct loopuse *lu,
		     const plane_t norm,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(const struct vertexuse *nmg_loop_touches_self,
		    (const struct loopuse *lu));
RT_EXPORT BU_EXTERN(int nmg_2lu_identical,
		    (const struct edgeuse *eu1,
		     const struct edgeuse *eu2));

/* Edge routines */
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_find_matching_eu_in_s,
		    (const struct edgeuse	*eu1,
		     const struct shell	*s2));
RT_EXPORT BU_EXTERN(struct edgeuse	*nmg_findeu,
		    (const struct vertex *v1,
		     const struct vertex *v2,
		     const struct shell *s,
		     const struct edgeuse *eup,
		     int dangling_only));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_find_eu_in_face,
		    (const struct vertex *v1,
		     const struct vertex *v2,
		     const struct faceuse *fu,
		     const struct edgeuse *eup,
		     int dangling_only));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_find_e,
		    (const struct vertex *v1,
		     const struct vertex *v2,
		     const struct shell *s,
		     const struct edge *ep));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_find_eu_of_vu,
		    (const struct vertexuse *vu));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_find_eu_with_vu_in_lu,
		    (const struct loopuse *lu,
		     const struct vertexuse *vu));
RT_EXPORT BU_EXTERN(const struct edgeuse *nmg_faceradial,
		    (const struct edgeuse *eu));
RT_EXPORT BU_EXTERN(const struct edgeuse *nmg_radial_face_edge_in_shell,
		    (const struct edgeuse *eu));
RT_EXPORT BU_EXTERN(const struct edgeuse *nmg_find_edge_between_2fu,
		    (const struct faceuse *fu1,
		     const struct faceuse *fu2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct edge *nmg_find_e_nearest_pt2,
		    (unsigned long *magic_p,
		     const point_t pt2,
		     const mat_t mat,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_find_matching_eu_in_s,
		    (const struct edgeuse *eu1,
		     const struct shell *s2));
RT_EXPORT BU_EXTERN(void nmg_eu_2vecs_perp,
		    (vect_t xvec,
		     vect_t yvec,
		     vect_t zvec,
		     const struct edgeuse *eu,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_find_eu_leftvec,
		    (vect_t left,
		     const struct edgeuse *eu));
RT_EXPORT BU_EXTERN(int nmg_find_eu_left_non_unit,
		    (vect_t left,
		     const struct edgeuse	*eu));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_find_ot_same_eu_of_e,
		    (const struct edge *e));

/* Vertex routines */
RT_EXPORT BU_EXTERN(struct vertexuse *nmg_find_v_in_face,
		    (const struct vertex *,
		     const struct faceuse *));
RT_EXPORT BU_EXTERN(struct vertexuse *nmg_find_v_in_shell,
		    (const struct vertex *v,
		     const struct shell *s,
		     int edges_only));
RT_EXPORT BU_EXTERN(struct vertexuse *nmg_find_pt_in_lu,
		    (const struct loopuse *lu,
		     const point_t pt,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct vertexuse *nmg_find_pt_in_face,
		    (const struct faceuse *fu,
		     const point_t pt,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct vertex *nmg_find_pt_in_shell,
		    (const struct shell *s,
		     const point_t pt,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct vertex *nmg_find_pt_in_model,
		    (const struct model *m,
		     const point_t pt,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_is_vertex_in_edgelist,
		    (const struct vertex *v,
		     const struct bu_list *hd));
RT_EXPORT BU_EXTERN(int nmg_is_vertex_in_looplist,
		    (const struct vertex *v,
		     const struct bu_list *hd,
		     int singletons));
RT_EXPORT BU_EXTERN(struct vertexuse *nmg_is_vertex_in_face,
		    (const struct vertex *v,
		     const struct face *f));
RT_EXPORT BU_EXTERN(int nmg_is_vertex_a_selfloop_in_shell,
		    (const struct vertex *v,
		     const struct shell *s));
RT_EXPORT BU_EXTERN(int nmg_is_vertex_in_facelist,
		    (const struct vertex *v,
		     const struct bu_list *hd));
RT_EXPORT BU_EXTERN(int nmg_is_edge_in_edgelist,
		    (const struct edge *e,
		     const struct bu_list *hd));
RT_EXPORT BU_EXTERN(int nmg_is_edge_in_looplist,
		    (const struct edge *e,
		     const struct bu_list *hd));
RT_EXPORT BU_EXTERN(int nmg_is_edge_in_facelist,
		    (const struct edge *e,
		     const struct bu_list *hd));
RT_EXPORT BU_EXTERN(int nmg_is_loop_in_facelist,
		    (const struct loop *l,
		     const struct bu_list *fu_hd));

/* Tabulation routines */
RT_EXPORT BU_EXTERN(void nmg_vertex_tabulate,
		    (struct bu_ptbl *tab,
		     const unsigned long *magic_p));
RT_EXPORT BU_EXTERN(void nmg_vertexuse_normal_tabulate,
		    (struct bu_ptbl *tab,
		     const unsigned long *magic_p));
RT_EXPORT BU_EXTERN(void nmg_edgeuse_tabulate,
		    (struct bu_ptbl *tab,
		     const unsigned long *magic_p));
RT_EXPORT BU_EXTERN(void nmg_edge_tabulate,
		    (struct bu_ptbl *tab,
		     const unsigned long *magic_p));
RT_EXPORT BU_EXTERN(void nmg_edge_g_tabulate,
		    (struct bu_ptbl *tab,
		     const unsigned long *magic_p));
RT_EXPORT BU_EXTERN(void nmg_face_tabulate,
		    (struct bu_ptbl *tab,
		     const unsigned long *magic_p));
RT_EXPORT BU_EXTERN(void nmg_edgeuse_with_eg_tabulate,
		    (struct bu_ptbl *tab,
		     const struct edge_g_lseg *eg));
RT_EXPORT BU_EXTERN(void nmg_edgeuse_on_line_tabulate,
		    (struct bu_ptbl		*tab,
		     const unsigned long	*magic_p,
		     const point_t		pt,
		     const vect_t		dir,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_e_and_v_tabulate,
		    (struct bu_ptbl		*eutab,
		     struct bu_ptbl		*vtab,
		     const unsigned long	*magic_p));
RT_EXPORT BU_EXTERN(int nmg_2edgeuse_g_coincident,
		    (const struct edgeuse	*eu1,
		     const struct edgeuse	*eu2,
		     const struct bn_tol	*tol));

/* From nmg_extrude.c */
RT_EXPORT BU_EXTERN(void nmg_translate_face,
		    (struct faceuse *fu,
		     const vect_t Vec,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_extrude_face,
		    (struct faceuse *fu,
		     const vect_t Vec,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct vertexuse *nmg_find_vertex_in_lu,
		    (const struct vertex *v,
		     const struct loopuse *lu));
RT_EXPORT BU_EXTERN(void nmg_fix_overlapping_loops,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_break_crossed_loops,
		    (struct shell *is,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct shell *nmg_extrude_cleanup,
		    (struct shell *is,
		     const int is_void,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_hollow_shell,
		    (struct shell *s,
		     const fastf_t thick,
		     const int approximate,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct shell *nmg_extrude_shell,
		    (struct shell *s,
		     const fastf_t dist,
		     const int normal_ward,
		     const int approximate,
		     const struct bn_tol *tol));

/* From nmg_pr.c */
RT_EXPORT BU_EXTERN(char *nmg_orientation,
		    (int orientation));
RT_EXPORT BU_EXTERN(void nmg_pr_orient,
		    (int orientation,
		     const char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_m,
		    (const struct model *m));
RT_EXPORT BU_EXTERN(void nmg_pr_r,
		    (const struct nmgregion *r,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_sa,
		    (const struct shell_a *sa,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_lg,
		    (const struct loop_g *lg,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_fg,
		    (const unsigned long *magic,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_s,
		    (const struct shell *s,
		     char *h));
RT_EXPORT BU_EXTERN(void  nmg_pr_s_briefly,
		    (const struct shell *s,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_f,
		    (const struct face *f,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_fu,
		    (const struct faceuse *fu,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_fu_briefly,
		    (const struct faceuse *fu,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_l,
		    (const struct loop *l,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_lu,
		    (const struct loopuse *lu,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_lu_briefly,
		    (const struct loopuse *lu,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_eg,
		    (const unsigned long *eg,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_e,
		    (const struct edge *e,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_eu,
		    (const struct edgeuse *eu,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_eu_briefly,
		    (const struct edgeuse *eu,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_eu_endpoints,
		    (const struct edgeuse *eu,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_vg,
		    (const struct vertex_g *vg,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_v,
		    (const struct vertex *v,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_vu,
		    (const struct vertexuse *vu,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_vu_briefly,
		    (const struct vertexuse *vu,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_pr_vua,
		    (const unsigned long *magic_p,
		     char *h));
RT_EXPORT BU_EXTERN(void nmg_euprint,
		    (const char *str,
		     const struct edgeuse *eu));
RT_EXPORT BU_EXTERN(void nmg_pr_ptbl,
		    (const char *title,
		     const struct bu_ptbl *tbl,
		     int verbose));
RT_EXPORT BU_EXTERN(void nmg_pr_ptbl_vert_list,
		    (const char *str,
		     const struct bu_ptbl *tbl,
		     const fastf_t *mag));
RT_EXPORT BU_EXTERN(void nmg_pr_one_eu_vecs,
		    (const struct edgeuse *eu,
		     const vect_t xvec,
		     const vect_t yvec,
		     const vect_t zvec,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_pr_fu_around_eu_vecs,
		    (const struct edgeuse *eu,
		     const vect_t xvec,
		     const vect_t yvec,
		     const vect_t zvec,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_pr_fu_around_eu,
		    (const struct edgeuse *eu,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_pl_lu_around_eu,
		    (const struct edgeuse *eu));
RT_EXPORT BU_EXTERN(void nmg_pr_fus_in_fg,
		    (const unsigned long *fg_magic));

/* From nmg_misc.c */
RT_EXPORT BU_EXTERN(int rt_dist_pt3_line3,
		    (fastf_t		*dist,
		     point_t		pca,
		     const point_t	a,
		     const point_t	p,
		     const vect_t	dir,
		     const struct bn_tol *tol));

RT_EXPORT BU_EXTERN(int rt_dist_line3_line3,
		    (fastf_t dist[2],
		     const point_t p1,
		     const point_t p2,
		     const vect_t d1,
		     const vect_t d2,
		     const struct bn_tol *tol));

RT_EXPORT BU_EXTERN(int nmg_snurb_calc_lu_uv_orient,
		    (const struct loopuse *lu));
RT_EXPORT BU_EXTERN(void nmg_snurb_fu_eval,
		    (const struct faceuse *fu,
		     const fastf_t u,
		     const fastf_t v,
		     point_t pt_on_srf));
RT_EXPORT BU_EXTERN(void nmg_snurb_fu_get_norm,
		    (const struct faceuse *fu,
		     const fastf_t u,
		     const fastf_t v,
		     vect_t norm));
RT_EXPORT BU_EXTERN(void nmg_snurb_fu_get_norm_at_vu,
		    (const struct faceuse *fu,
		     const struct vertexuse *vu,
		     vect_t norm));
RT_EXPORT BU_EXTERN(void nmg_find_zero_length_edges,
		    (const struct model *m));
RT_EXPORT BU_EXTERN(struct face *nmg_find_top_face_in_dir,
		    (const struct shell *s,
		     int dir, long *flags));
RT_EXPORT BU_EXTERN(struct face *nmg_find_top_face,
		    (const struct shell *s,
		     int *dir,
		     long *flags));
RT_EXPORT BU_EXTERN(int nmg_find_outer_and_void_shells,
		    (struct nmgregion *r,
		     struct bu_ptbl ***shells,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_mark_edges_real,
		    (const unsigned long *magic_p));
RT_EXPORT BU_EXTERN(void nmg_tabulate_face_g_verts,
		    (struct bu_ptbl *tab,
		     const struct face_g_plane *fg));
RT_EXPORT BU_EXTERN(void nmg_isect_shell_self,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_next_radial_eu,
		    (const struct edgeuse *eu,
		     const struct shell *s,
		     const int wires));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_prev_radial_eu,
		    (const struct edgeuse *eu,
		     const struct shell *s,
		     const int wires));
RT_EXPORT BU_EXTERN(int nmg_radial_face_count,
		    (const struct edgeuse *eu,
		     const struct shell *s));
RT_EXPORT BU_EXTERN(int nmg_check_closed_shell,
		    (const struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_move_lu_between_fus,
		    (struct faceuse *dest,
		     struct faceuse *src,
		     struct loopuse *lu));
RT_EXPORT BU_EXTERN(void nmg_loop_plane_newell,
		    (const struct loopuse *lu,
		     plane_t pl));
RT_EXPORT BU_EXTERN(fastf_t nmg_loop_plane_area,
		    (const struct loopuse *lu,
		     plane_t pl));
RT_EXPORT BU_EXTERN(int nmg_calc_face_plane,
		    (struct faceuse *fu_in,
		     plane_t pl));
RT_EXPORT BU_EXTERN(int nmg_calc_face_g,
		    (struct faceuse *fu));
RT_EXPORT BU_EXTERN(fastf_t nmg_faceuse_area,
		    (const struct faceuse *fu));
RT_EXPORT BU_EXTERN(fastf_t nmg_shell_area,
		    (const struct shell *s));
RT_EXPORT BU_EXTERN(fastf_t nmg_region_area,
		    (const struct nmgregion *r));
RT_EXPORT BU_EXTERN(fastf_t nmg_model_area,
		    (const struct model *m));
/* Some stray rt_ plane functions here */
RT_EXPORT BU_EXTERN(void nmg_purge_unwanted_intersection_points,
		    (struct bu_ptbl *vert_list,
		     fastf_t *mag,
		     const struct faceuse *fu,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_in_or_ref,
		    (struct vertexuse *vu,
		     struct bu_ptbl *b));
RT_EXPORT BU_EXTERN(void nmg_rebound,
		    (struct model *m,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_count_shell_kids,
		    (const struct model *m,
		     unsigned long *total_wires,
		     unsigned long *total_faces,
		     unsigned long *total_points));
RT_EXPORT BU_EXTERN(void nmg_close_shell,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct shell *nmg_dup_shell ,
		    (struct shell *s,
		     long ***copy_tbl,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_pop_eu,
		    (struct bu_ptbl *stack));
RT_EXPORT BU_EXTERN(void nmg_reverse_radials,
		    (struct faceuse *fu,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_reverse_face_and_radials,
		    (struct faceuse *fu,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_shell_is_void,
		    (const struct shell *s));
RT_EXPORT BU_EXTERN(void nmg_propagate_normals,
		    (struct faceuse *fu_in,
		     long *flags,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_connect_same_fu_orients,
		    (struct shell *s));
RT_EXPORT BU_EXTERN(void nmg_fix_decomposed_shell_normals,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct model *nmg_mk_model_from_region,
		    (struct nmgregion *r,
		     int reindex));
RT_EXPORT BU_EXTERN(void nmg_fix_normals,
		    (struct shell *s_orig,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_break_long_edges,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct faceuse *nmg_mk_new_face_from_loop,
		    (struct loopuse *lu));
RT_EXPORT BU_EXTERN(int nmg_split_loops_into_faces,
		    (unsigned long *magic_p,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_decompose_shell,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_stash_model_to_file,
		    (const char *filename,
		     const struct model *m,
		     const char *title));
RT_EXPORT BU_EXTERN(int nmg_unbreak_region_edges,
		    (unsigned long *magic_p));
RT_EXPORT BU_EXTERN(void nmg_vlist_to_eu,
		    (struct bu_list *vlist,
		     struct shell *s));
/* rt_dist_pt3_line3 */
RT_EXPORT BU_EXTERN(int nmg_mv_shell_to_region,
		    (struct shell *s,
		     struct nmgregion *r));
RT_EXPORT BU_EXTERN(int nmg_find_isect_faces,
		    (const struct vertex *new_v,
		     struct bu_ptbl *faces,
		     int *free_edges,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_simple_vertex_solve,
		    (struct vertex *new_v,
		     const struct bu_ptbl *faces,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_ck_vert_on_fus,
		    (const struct vertex *v,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_make_faces_at_vert,
		    (struct vertex *new_v,
		     struct bu_ptbl *int_faces,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_kill_cracks_at_vertex,
		    (const struct vertex *vp));
RT_EXPORT BU_EXTERN(int nmg_complex_vertex_solve,
		    (struct vertex *new_v,
		     const struct bu_ptbl *faces,
		     const int free_edges,
		     const int approximate,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_bad_face_normals,
		    (const struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_faces_are_radial,
		    (const struct faceuse *fu1,
		     const struct faceuse *fu2));
RT_EXPORT BU_EXTERN(int nmg_move_edge_thru_pt,
		    (struct edgeuse *mv_eu,
		     const point_t pt,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_vlist_to_wire_edges,
		    (struct shell *s,
		     const struct bu_list *vhead));
RT_EXPORT BU_EXTERN(void nmg_follow_free_edges_to_vertex,
		    (const struct vertex *vpa,
		     const struct vertex *vpb,
		     struct bu_ptbl *bad_verts,
		     const struct shell *s,
		     const struct edgeuse *eu,
		     struct bu_ptbl *verts,
		     int *found));
RT_EXPORT BU_EXTERN(void nmg_glue_face_in_shell,
		    (const struct faceuse *fu,
		     struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_open_shells_connect,
		    (struct shell *dst,
		     struct shell *src,
		     const long **copy_tbl,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_in_vert,
		    (struct vertex *new_v,
		     const int approximate,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_mirror_model,
		    (struct model *m));
RT_EXPORT BU_EXTERN(int nmg_kill_cracks,
		    (struct shell *s));
RT_EXPORT BU_EXTERN(int nmg_kill_zero_length_edgeuses,
		    (struct model *m));
RT_EXPORT BU_EXTERN(void nmg_make_faces_within_tol,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_intersect_loops_self,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct edge_g_cnurb *rt_join_cnurbs,
		    (struct bu_list *crv_head));
RT_EXPORT BU_EXTERN(struct edge_g_cnurb *rt_arc2d_to_cnurb,
		    (point_t i_center,
		     point_t i_start,
		     point_t i_end,
		     int point_type,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_break_edge_at_verts,
		    (struct edge *e,
		     struct bu_ptbl *verts,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_isect_shell_self,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(fastf_t nmg_loop_plane_area,
		    (const struct loopuse *lu,
		     plane_t pl));
RT_EXPORT BU_EXTERN(int nmg_break_edges,
		    (unsigned long *magic_p,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_lu_is_convex,
		    (struct loopuse *lu,
		     const struct bn_tol *tol));
#ifdef __RTGEOM_H__
RT_EXPORT BU_EXTERN(int nmg_to_arb,
		    (const struct model *m,
		     struct rt_arb_internal *arb_int));
RT_EXPORT BU_EXTERN(int nmg_to_tgc,
		    (const struct model *m,
		     struct rt_tgc_internal *tgc_int,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_to_poly,
		    (const struct model *m,
		     struct rt_pg_internal *poly_int,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct rt_bot_internal *nmg_bot,
		    (struct shell *s,
		     const struct bn_tol *tol));
#endif /* __NMG_H__ */

RT_EXPORT BU_EXTERN(int nmg_simplify_shell_edges,
		    (struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_edge_collapse,
		    (struct model *m,
		     const struct bn_tol *tol,
		     const fastf_t tol_coll,
		     const fastf_t min_angle));

/* g_bot.c */
RT_EXPORT BU_EXTERN(int rt_bot_edge_in_list,
		    (const int v1,
		     const int v2,
		     const int edge_list[],
		     const int edge_count0));
RT_EXPORT BU_EXTERN(int rt_bot_plot,
		    (struct bu_list		*vhead,
		     struct rt_db_internal	*ip,
		     const struct rt_tess_tol *ttol,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int rt_bot_plot_poly,
		    (struct bu_list		*vhead,
		     struct rt_db_internal	*ip,
		     const struct rt_tess_tol *ttol,
		     const struct bn_tol	*tol));
#ifdef __RTGEOM_H__
RT_EXPORT BU_EXTERN(int rt_bot_find_v_nearest_pt2,
		    (const struct rt_bot_internal *bot,
		     const point_t	pt2,
		     const mat_t	mat));
RT_EXPORT BU_EXTERN(int rt_bot_find_e_nearest_pt2,
		    (int *vert1,
		     int *vert2,
		     const struct rt_bot_internal *bot,
		     const point_t	pt2,
		     const mat_t	mat));
RT_EXPORT BU_EXTERN(int rt_bot_vertex_fuse,
		    (struct rt_bot_internal *bot));
RT_EXPORT BU_EXTERN(int rt_bot_face_fuse,
		    (struct rt_bot_internal *bot));
RT_EXPORT BU_EXTERN(int rt_bot_condense,
		    (struct rt_bot_internal *bot));
RT_EXPORT BU_EXTERN(int rt_bot_smooth,
		    (struct rt_bot_internal *bot,
		     char *bot_name,
		     struct db_i *dbip,
		     fastf_t normal_tolerance_angle));

#endif
RT_EXPORT BU_EXTERN(int rt_bot_same_orientation,
		    (const int *a,
		     const int *b));

/* From nmg_tri.c */
RT_EXPORT BU_EXTERN(void nmg_triangulate_shell,
		    (struct shell *s,
		     const struct bn_tol  *tol));


RT_EXPORT BU_EXTERN(void nmg_triangulate_model,
		    (struct model *m,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_triangulate_fu,
		    (struct faceuse *fu,
		     const struct bn_tol *tol));

/* nmg_manif.c */
RT_EXPORT BU_EXTERN(int nmg_dangling_face,
		    (const struct faceuse *fu,
		     const char *manifolds));
/* static paint_face */
/* static set_edge_sub_manifold */
/* static set_loop_sub_manifold */
/* static set_face_sub_manifold */
RT_EXPORT BU_EXTERN(char *nmg_shell_manifolds,
		    (struct shell *sp,
		     char *tbl));
RT_EXPORT BU_EXTERN(char *nmg_manifolds,
		    (struct model *m));

/* g_nmg.c */
RT_EXPORT BU_EXTERN(int nmg_ray_segs,
		    (struct ray_data	*rd));

/* g_torus.c */
RT_EXPORT BU_EXTERN(int rt_num_circular_segments,
		    (double maxerr,
		     double radius));

/* tcl.c */
RT_EXPORT BU_EXTERN(int rt_tcl_parse_ray,
		    (Tcl_Interp *interp,
		     struct xray *rp,
		     const char *const*argv));
RT_EXPORT BU_EXTERN(void rt_tcl_pr_cutter,
		    (Tcl_Interp *interp,
		     const union cutter *cutp));
RT_EXPORT BU_EXTERN(int rt_tcl_cutter,
		    (ClientData clientData,
		     Tcl_Interp *interp,
		     int argc,
		     const char *const*argv));
RT_EXPORT BU_EXTERN(void rt_tcl_pr_hit,
		    (Tcl_Interp *interp,
		     struct hit *hitp,
		     const struct seg *segp,
		     const struct xray *rayp,
		     int flipflag));
RT_EXPORT BU_EXTERN(int rt_tcl_rt,
		    (ClientData clientData,
		     Tcl_Interp *interp,
		     int argc,
		     const char **argv));
RT_EXPORT BU_EXTERN(int rt_tcl_import_from_path,
		    (Tcl_Interp *interp,
		     struct rt_db_internal *ip,
		     const char *path,
		     struct rt_wdb *wdb));
RT_EXPORT BU_EXTERN(void rt_generic_make,
		    (const struct rt_functab *ftp,
		     struct rt_db_internal *intern,
		     double diameter));
RT_EXPORT BU_EXTERN(void rt_tcl_setup,
		    (Tcl_Interp *interp));
RT_EXPORT BU_EXTERN(int Sysv_Init,
		    (Tcl_Interp *interp));
RT_EXPORT BU_EXTERN(int Rt_Init,
		    (Tcl_Interp *interp));
RT_EXPORT BU_EXTERN(void db_full_path_appendresult,
		    (Tcl_Interp *interp,
		     const struct db_full_path *pp));
RT_EXPORT BU_EXTERN(int tcl_obj_to_int_array,
		    (Tcl_Interp *interp,
		     Tcl_Obj *list,
		     int **array,
		     int *array_len));


RT_EXPORT BU_EXTERN(int tcl_obj_to_fastf_array,
		    (Tcl_Interp *interp,
		     Tcl_Obj *list,
		     fastf_t **array,
		     int *array_len));

RT_EXPORT BU_EXTERN(int tcl_list_to_int_array,
		    (Tcl_Interp *interp,
		     char *char_list,
		     int **array,
		     int *array_len));

RT_EXPORT BU_EXTERN(int tcl_list_to_fastf_array,
		    (Tcl_Interp *interp,
		     char *char_list,
		     fastf_t **array,
		     int *array_len));


/* g_rhc.c */
RT_EXPORT BU_EXTERN(int rt_mk_hyperbola,
		    (struct rt_pt_node *pts,
		     fastf_t r,
		     fastf_t b,
		     fastf_t c,
		     fastf_t dtol,
		     fastf_t ntol));


/* nmg_class.c */
RT_EXPORT BU_EXTERN(int nmg_classify_pt_loop,
		    (const point_t pt,
		     const struct loopuse *lu,
		     const struct bn_tol *tol));

RT_EXPORT BU_EXTERN(int nmg_classify_s_vs_s,
		    (struct shell *s,
		     struct shell *s2,
		     const struct bn_tol *tol));

RT_EXPORT BU_EXTERN(int nmg_classify_lu_lu,
		    (const struct loopuse *lu1,
		     const struct loopuse *lu2,
		     const struct bn_tol *tol));

RT_EXPORT BU_EXTERN(int nmg_class_pt_f,
		    (const point_t pt,
		     const struct faceuse *fu,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_class_pt_s,
		    (const point_t pt,
		     const struct shell *s,
		     const int in_or_out_only,
		     const struct bn_tol *tol));

/* From nmg_pt_fu.c */
RT_EXPORT BU_EXTERN(int nmg_eu_is_part_of_crack,
		    (const struct edgeuse *eu));

RT_EXPORT BU_EXTERN(int nmg_class_pt_lu_except,
		    (point_t		pt,
		     const struct loopuse	*lu,
		     const struct edge		*e_p,
		     const struct bn_tol	*tol));

RT_EXPORT BU_EXTERN(int nmg_class_pt_fu_except,
		    (const point_t pt,
		     const struct faceuse *fu,
		     const struct loopuse *ignore_lu,
		     void (*eu_func)(), void (*vu_func)(),
		     const char *priv,
		     const int call_on_hits,
		     const int in_or_out_only,
		     const struct bn_tol *tol));

/* From nmg_plot.c */
RT_EXPORT BU_EXTERN(void nmg_pl_shell,
		    (FILE *fp,
		     const struct shell *s,
		     int fancy));

RT_EXPORT BU_EXTERN(void nmg_vu_to_vlist,
		    (struct bu_list *vhead,
		     const struct vertexuse	*vu));
RT_EXPORT BU_EXTERN(void nmg_eu_to_vlist,
		    (struct bu_list *vhead,
		     const struct bu_list	*eu_hd));
RT_EXPORT BU_EXTERN(void nmg_lu_to_vlist,
		    (struct bu_list *vhead,
		     const struct loopuse	*lu,
		     int			poly_markers,
		     const vectp_t		normal));
RT_EXPORT BU_EXTERN(void nmg_snurb_fu_to_vlist,
		    (struct bu_list		*vhead,
		     const struct faceuse	*fu,
		     int			poly_markers));
RT_EXPORT BU_EXTERN(void nmg_s_to_vlist,
		    (struct bu_list		*vhead,
		     const struct shell	*s,
		     int			poly_markers));
RT_EXPORT BU_EXTERN(void nmg_r_to_vlist,
		    (struct bu_list		*vhead,
		     const struct nmgregion	*r,
		     int			poly_markers));
RT_EXPORT BU_EXTERN(void nmg_m_to_vlist,
		    (struct bu_list	*vhead,
		     struct model	*m,
		     int		poly_markers));
RT_EXPORT BU_EXTERN(void nmg_offset_eu_vert,
		    (point_t			base,
		     const struct edgeuse	*eu,
		     const vect_t		face_normal,
		     int			tip));
/* plot */
RT_EXPORT BU_EXTERN(void nmg_pl_v,
		    (FILE	*fp,
		     const struct vertex *v,
		     long *b));
RT_EXPORT BU_EXTERN(void nmg_pl_e,
		    (FILE *fp,
		     const struct edge *e,
		     long *b,
		     int red,
		     int green,
		     int blue));
RT_EXPORT BU_EXTERN(void nmg_pl_eu,
		    (FILE *fp,
		     const struct edgeuse *eu,
		     long *b,
		     int red,
		     int green,
		     int blue));
RT_EXPORT BU_EXTERN(void nmg_pl_lu,
		    (FILE *fp,
		     const struct loopuse *fu,
		     long *b,
		     int red,
		     int green,
		     int blue));
RT_EXPORT BU_EXTERN(void nmg_pl_fu,
		    (FILE *fp,
		     const struct faceuse *fu,
		     long *b,
		     int red,
		     int green,
		     int blue));
RT_EXPORT BU_EXTERN(void nmg_pl_s,
		    (FILE *fp,
		     const struct shell *s));
RT_EXPORT BU_EXTERN(void nmg_pl_r,
		    (FILE *fp,
		     const struct nmgregion *r));
RT_EXPORT BU_EXTERN(void nmg_pl_m,
		    (FILE *fp,
		     const struct model *m));
RT_EXPORT BU_EXTERN(void nmg_vlblock_v,
		    (struct bn_vlblock *vbp,
		     const struct vertex *v,
		     long *tab));
RT_EXPORT BU_EXTERN(void nmg_vlblock_e,
		    (struct bn_vlblock *vbp,
		     const struct edge *e,
		     long *tab,
		     int red,
		     int green,
		     int blue,
		     int fancy));
RT_EXPORT BU_EXTERN(void nmg_vlblock_eu,
		    (struct bn_vlblock *vbp,
		     const struct edgeuse *eu,
		     long *tab,
		     int red,
		     int green,
		     int blue,
		     int fancy,
		     int loopnum));
RT_EXPORT BU_EXTERN(void nmg_vlblock_euleft,
		    (struct bu_list			*vh,
		     const struct edgeuse		*eu,
		     const point_t			center,
		     const mat_t			mat,
		     const vect_t			xvec,
		     const vect_t			yvec,
		     double				len,
		     const struct bn_tol		*tol));
RT_EXPORT BU_EXTERN(void nmg_vlblock_around_eu,
		    (struct bn_vlblock		*vbp,
		     const struct edgeuse	*arg_eu,
		     long			*tab,
		     int			fancy,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_vlblock_lu,
		    (struct bn_vlblock *vbp,
		     const struct loopuse *lu,
		     long *tab,
		     int red,
		     int green,
		     int blue,
		     int fancy,
		     int loopnum));
RT_EXPORT BU_EXTERN(void nmg_vlblock_fu,
		    (struct bn_vlblock *vbp,
		     const struct faceuse *fu,
		     long *tab, int fancy));
RT_EXPORT BU_EXTERN(void nmg_vlblock_s,
		    (struct bn_vlblock *vbp,
		     const struct shell *s,
		     int fancy));
RT_EXPORT BU_EXTERN(void nmg_vlblock_r,
		    (struct bn_vlblock *vbp,
		     const struct nmgregion *r,
		     int fancy));
RT_EXPORT BU_EXTERN(void nmg_vlblock_m,
		    (struct bn_vlblock *vbp,
		     const struct model *m,
		     int fancy));
/* visualization helper routines */
RT_EXPORT BU_EXTERN(void nmg_pl_edges_in_2_shells,
		    (struct bn_vlblock	*vbp,
		     long			*b,
		     const struct edgeuse	*eu,
		     int			fancy,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_pl_isect,
		    (const char		*filename,
		     const struct shell	*s,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_pl_comb_fu,
		    (int num1,
		     int num2,
		     const struct faceuse *fu1));
RT_EXPORT BU_EXTERN(void nmg_pl_2fu,
		    (const char *str,
		     int num,
		     const struct faceuse *fu1,
		     const struct faceuse *fu2,
		     int show_mates));
/* graphical display of classifier results */
RT_EXPORT BU_EXTERN(void nmg_show_broken_classifier_stuff,
		    (unsigned long	*p,
		     long	*classlist[4],
		     int	all_new,
		     int	fancy,
		     const char	*a_string));
RT_EXPORT BU_EXTERN(void nmg_face_plot,
		    (const struct faceuse *fu));
RT_EXPORT BU_EXTERN(void nmg_2face_plot,
		    (const struct faceuse *fu1,
		     const struct faceuse *fu2));
RT_EXPORT BU_EXTERN(void nmg_face_lu_plot,
		    (const struct loopuse *lu,
		     const struct vertexuse *vu1,
		     const struct vertexuse *vu2));
RT_EXPORT BU_EXTERN(void nmg_plot_lu_ray,
		    (const struct loopuse		*lu,
		     const struct vertexuse		*vu1,
		     const struct vertexuse		*vu2,
		     const vect_t			left));
RT_EXPORT BU_EXTERN(void nmg_plot_ray_face,
		    (const char *fname,
		     point_t pt,
		     const vect_t dir,
		     const struct faceuse *fu));
RT_EXPORT BU_EXTERN(void nmg_plot_lu_around_eu,
		    (const char		*prefix,
		     const struct edgeuse	*eu,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int nmg_snurb_to_vlist,
		    (struct bu_list		*vhead,
		     const struct face_g_snurb	*fg,
		     int			n_interior));
RT_EXPORT BU_EXTERN(void nmg_cnurb_to_vlist,
		    (struct bu_list *vhead,
		     const struct edgeuse *eu,
		     int n_interior,
		     int cmd));

RT_EXPORT extern void (*nmg_plot_anim_upcall)();
RT_EXPORT extern void (*nmg_vlblock_anim_upcall)();
RT_EXPORT extern void (*nmg_mged_debug_display_hack)();
RT_EXPORT extern double nmg_eue_dist;

/* nurb_util.c */
RT_EXPORT BU_EXTERN(void rt_nurb_clean_cnurb,
		    (struct edge_g_cnurb * crv));

/* nurb_knot.c */
RT_EXPORT BU_EXTERN(int rt_nurb_knot_index,
		    (const struct knot_vector *kv,
		     fastf_t k_value,
		     int	order));

/* nurb_trim.c */
RT_EXPORT BU_EXTERN(int nmg_uv_in_lu,
		    (const fastf_t u,
		     const fastf_t v,
		     const struct loopuse *lu));


/* from nmg_mesh.c */
RT_EXPORT BU_EXTERN(int nmg_mesh_two_faces,
		    (struct faceuse *fu1,
		     struct faceuse *fu2,
		     const struct bn_tol	*tol));

RT_EXPORT BU_EXTERN(void nmg_radial_join_eu,
		    (struct edgeuse *eu1,
		     struct edgeuse *eu2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_mesh_faces,
		    (struct faceuse *fu1,
		     struct faceuse *fu2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_mesh_face_shell,
		    (struct faceuse *fu1,
		     struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_mesh_shell_shell,
		    (struct shell *s1,
		     struct shell *s2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(double nmg_measure_fu_angle,
		    (const struct edgeuse *eu,
		     const vect_t xvec,
		     const vect_t yvec,
		     const vect_t zvec));

/* from nmg_bool.c */
RT_EXPORT BU_EXTERN(struct nmgregion *nmg_do_bool,
		    (struct nmgregion *s1,
		     struct nmgregion *s2,
		     const int oper, const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_shell_coplanar_face_merge,
		    (struct shell *s,
		     const struct bn_tol *tol,
		     const int simplify));
RT_EXPORT BU_EXTERN(int nmg_two_region_vertex_fuse,
		    (struct nmgregion *r1,
		     struct nmgregion *r2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(union tree *nmg_booltree_leaf_tess,
		    (struct db_tree_state *tsp,
		     struct db_full_path *pathp,
		     struct rt_db_internal *ip,
		     genptr_t client_data));
RT_EXPORT BU_EXTERN(union tree *nmg_booltree_leaf_tnurb,
		    (struct db_tree_state *tsp,
		     struct db_full_path *pathp,
		     struct rt_db_internal *ip,
		     genptr_t client_data));
RT_EXPORT extern int nmg_bool_eval_silent;	/* quell output from nmg_booltree_evaluate */
RT_EXPORT BU_EXTERN(union tree *nmg_booltree_evaluate,
		    (union tree *tp,
		     const struct bn_tol *tol,
		     struct resource *resp));
RT_EXPORT BU_EXTERN(int nmg_boolean,
		    (union tree *tp,
		     struct model *m,
		     const struct bn_tol *tol,
		     struct resource *resp));

/* from nmg_class.c */
RT_EXPORT BU_EXTERN(void nmg_class_shells,
		    (struct shell *sA,
		     struct shell *sB,
		     long *classlist[4],
		     const struct bn_tol *tol));

/* from nmg_fcut.c */
/* static void ptbl_vsort */
RT_EXPORT BU_EXTERN(int nmg_ck_vu_ptbl,
		    (struct bu_ptbl	*p,
		     struct faceuse	*fu));
RT_EXPORT BU_EXTERN(double nmg_vu_angle_measure,
		    (struct vertexuse	*vu,
		     vect_t x_dir,
		     vect_t y_dir,
		     int assessment,
		     int in));
RT_EXPORT BU_EXTERN(int nmg_wedge_class,
		    (int	ass,	/* assessment of two edges forming wedge */
		     double	a,
		     double	b));
RT_EXPORT BU_EXTERN(void nmg_sanitize_fu,
		    (struct faceuse	*fu));
RT_EXPORT BU_EXTERN(void nmg_unlist_v,
		    (struct bu_ptbl	*b,
		     fastf_t *mag,
		     struct vertex	*v));
RT_EXPORT BU_EXTERN(struct edge_g_lseg *nmg_face_cutjoin,
		    (struct bu_ptbl *b1,
		     struct bu_ptbl *b2,
		     fastf_t *mag1,
		     fastf_t *mag2,
		     struct faceuse *fu1,
		     struct faceuse *fu2,
		     point_t pt,
		     vect_t dir,
		     struct edge_g_lseg *eg,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_fcut_face_2d,
		    (struct bu_ptbl *vu_list,
		     fastf_t *mag,
		     struct faceuse *fu1,
		     struct faceuse *fu2,
		     struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_insert_vu_if_on_edge,
		    (struct vertexuse *vu1,
		     struct vertexuse *vu2,
		     struct edgeuse *new_eu,
		     struct bn_tol *tol));
/* nmg_face_state_transition */

#define nmg_mev(_v, _u)	nmg_me((_v), (struct vertex *)NULL, (_u))

/* From nmg_eval.c */
RT_EXPORT BU_EXTERN(void nmg_ck_lu_orientation,
		    (struct loopuse *lu,
		     const struct bn_tol *tolp));
RT_EXPORT BU_EXTERN(const char *nmg_class_name,
		    (int class_no));
RT_EXPORT BU_EXTERN(void nmg_evaluate_boolean,
		    (struct shell	*sA,
		     struct shell	*sB,
		     int		op,
		     long		*classlist[8],
		     const struct bn_tol	*tol));

/* The following functions cannot be publicly declared because struct
 * nmg_bool_state is private to nmg_eval.c
 */
/* nmg_eval_shell */
/* nmg_eval_action */
/* nmg_eval_plot */


/* From nmg_rt_isect.c */
RT_EXPORT BU_EXTERN(void nmg_rt_print_hitlist,
		    (struct hitmiss *hl));

RT_EXPORT BU_EXTERN(void nmg_rt_print_hitmiss,
		    (struct hitmiss *a_hit));

RT_EXPORT BU_EXTERN(int nmg_class_ray_vs_shell,
		    (struct xray *rp,
		     const struct shell *s,
		     const int in_or_out_only,
		     const struct bn_tol *tol));

RT_EXPORT BU_EXTERN(void nmg_isect_ray_model,
		    (struct ray_data *rd));

/* From nmg_ck.c */
RT_EXPORT BU_EXTERN(void nmg_vvg,
		    (const struct vertex_g *vg));
RT_EXPORT BU_EXTERN(void nmg_vvertex,
		    (const struct vertex *v,
		     const struct vertexuse *vup));
RT_EXPORT BU_EXTERN(void nmg_vvua,
		    (const unsigned long *vua));
RT_EXPORT BU_EXTERN(void nmg_vvu,
		    (const struct vertexuse *vu,
		     const unsigned long *up_magic_p));
RT_EXPORT BU_EXTERN(void nmg_veg,
		    (const unsigned long *eg));
RT_EXPORT BU_EXTERN(void nmg_vedge,
		    (const struct edge *e,
		     const struct edgeuse *eup));
RT_EXPORT BU_EXTERN(void nmg_veu,
		    (const struct bu_list	*hp,
		     const unsigned long *up_magic_p));
RT_EXPORT BU_EXTERN(void nmg_vlg,
		    (const struct loop_g *lg));
RT_EXPORT BU_EXTERN(void nmg_vloop,
		    (const struct loop *l,
		     const struct loopuse *lup));
RT_EXPORT BU_EXTERN(void nmg_vlu,
		    (const struct bu_list	*hp,
		     const unsigned long *up));
RT_EXPORT BU_EXTERN(void nmg_vfg,
		    (const struct face_g_plane *fg));
RT_EXPORT BU_EXTERN(void nmg_vface,
		    (const struct face *f,
		     const struct faceuse *fup));
RT_EXPORT BU_EXTERN(void nmg_vfu,
		    (const struct bu_list	*hp,
		     const struct shell *s));
RT_EXPORT BU_EXTERN(void nmg_vshell,
		    (const struct bu_list *hp,
		     const struct nmgregion *r));
RT_EXPORT BU_EXTERN(void nmg_vregion,
		    (const struct bu_list *hp,
		     const struct model *m));
RT_EXPORT BU_EXTERN(void nmg_vmodel,
		    (const struct model *m));

/* checking routines */
RT_EXPORT BU_EXTERN(void nmg_ck_e,
		    (const struct edgeuse *eu,
		     const struct edge *e,
		     const char *str));
RT_EXPORT BU_EXTERN(void nmg_ck_vu,
		    (const unsigned long *parent,
		     const struct vertexuse *vu,
		     const char *str));
RT_EXPORT BU_EXTERN(void nmg_ck_eu,
		    (const unsigned long *parent,
		     const struct edgeuse *eu,
		     const char *str));
RT_EXPORT BU_EXTERN(void nmg_ck_lg,
		    (const struct loop *l,
		     const struct loop_g *lg,
		     const char *str));
RT_EXPORT BU_EXTERN(void nmg_ck_l,
		    (const struct loopuse *lu,
		     const struct loop *l,
		     const char *str));
RT_EXPORT BU_EXTERN(void nmg_ck_lu,
		    (const unsigned long *parent,
		     const struct loopuse *lu,
		     const char *str));
RT_EXPORT BU_EXTERN(void nmg_ck_fg,
		    (const struct face *f,
		     const struct face_g_plane *fg,
		     const char *str));
RT_EXPORT BU_EXTERN(void nmg_ck_f,
		    (const struct faceuse *fu,
		     const struct face *f,
		     const char *str));
RT_EXPORT BU_EXTERN(void nmg_ck_fu,
		    (const struct shell *s,
		     const struct faceuse *fu,
		     const char *str));
RT_EXPORT BU_EXTERN(int nmg_ck_eg_verts,
		    (const struct edge_g_lseg *eg,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_ck_geometry,
		    (const struct model *m,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_ck_face_worthless_edges,
		    (const struct faceuse *fu));
RT_EXPORT BU_EXTERN(void nmg_ck_lueu,
		    (const struct loopuse *lu, const char *s));
RT_EXPORT BU_EXTERN(int nmg_check_radial,
		    (const struct edgeuse *eu, const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_eu_2s_orient_bad,
		    (const struct edgeuse	*eu,
		     const struct shell	*s1,
		     const struct shell	*s2,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int nmg_ck_closed_surf,
		    (const struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_ck_closed_region,
		    (const struct nmgregion *r,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_ck_v_in_2fus,
		    (const struct vertex *vp,
		     const struct faceuse *fu1,
		     const struct faceuse *fu2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_ck_vs_in_region,
		    (const struct nmgregion *r,
		     const struct bn_tol *tol));


/* From nmg_inter.c */
RT_EXPORT BU_EXTERN(struct vertexuse *nmg_make_dualvu,
		    (struct vertex *v,
		     struct faceuse *fu,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(struct vertexuse *nmg_enlist_vu,
		    (struct nmg_inter_struct	*is,
		     const struct vertexuse *vu,
		     struct vertexuse *dualvu,
		     fastf_t dist));
RT_EXPORT BU_EXTERN(void nmg_isect2d_prep,
		    (struct nmg_inter_struct *is,
		     const unsigned long *assoc_use));
RT_EXPORT BU_EXTERN(void nmg_isect2d_cleanup,
		    (struct nmg_inter_struct *is));
RT_EXPORT BU_EXTERN(void nmg_isect2d_final_cleanup,
		    ());
RT_EXPORT BU_EXTERN(void nmg_isect_vert2p_face2p,
		    (struct nmg_inter_struct *is,
		     struct vertexuse *vu1,
		     struct faceuse *fu2));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_break_eu_on_v,
		    (struct edgeuse *eu1,
		     struct vertex *v2,
		     struct faceuse *fu,
		     struct nmg_inter_struct *is));
RT_EXPORT BU_EXTERN(void nmg_break_eg_on_v,
		    (const struct edge_g_lseg	*eg,
		     struct vertex		*v,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int nmg_isect_2colinear_edge2p,
		    (struct edgeuse	*eu1,
		     struct edgeuse	*eu2,
		     struct faceuse		*fu,
		     struct nmg_inter_struct	*is,
		     struct bu_ptbl		*l1,
		     struct bu_ptbl		*l2));
RT_EXPORT BU_EXTERN(int nmg_isect_edge2p_edge2p,
		    (struct nmg_inter_struct	*is,
		     struct edgeuse		*eu1,
		     struct edgeuse		*eu2,
		     struct faceuse		*fu1,
		     struct faceuse		*fu2));
RT_EXPORT BU_EXTERN(int nmg_isect_construct_nice_ray,
		    (struct nmg_inter_struct	*is,
		     struct faceuse		*fu2));
RT_EXPORT BU_EXTERN(void nmg_enlist_one_vu,
		    (struct nmg_inter_struct	*is,
		     const struct vertexuse	*vu,
		     fastf_t			dist));
RT_EXPORT BU_EXTERN(int	nmg_isect_line2_edge2p,
		    (struct nmg_inter_struct	*is,
		     struct bu_ptbl		*list,
		     struct edgeuse		*eu1,
		     struct faceuse		*fu1,
		     struct faceuse		*fu2));
RT_EXPORT BU_EXTERN(void nmg_isect_line2_vertex2,
		    (struct nmg_inter_struct	*is,
		     struct vertexuse	*vu1,
		     struct faceuse		*fu1));
RT_EXPORT BU_EXTERN(int nmg_isect_two_ptbls,
		    (struct nmg_inter_struct	*is,
		     const struct bu_ptbl	*t1,
		     const struct bu_ptbl	*t2));
RT_EXPORT BU_EXTERN(struct edge_g_lseg	*nmg_find_eg_on_line,
		    (const unsigned long	*magic_p,
		     const point_t		pt,
		     const vect_t		dir,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int nmg_k0eu,
		    (struct vertex	*v));
RT_EXPORT BU_EXTERN(struct vertex *nmg_repair_v_near_v,
		    (struct vertex		*hit_v,
		     struct vertex		*v,
		     const struct edge_g_lseg	*eg1,
		     const struct edge_g_lseg	*eg2,
		     int			bomb,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(struct vertex *nmg_search_v_eg,
		    (const struct edgeuse	*eu,
		     int			second,
		     const struct edge_g_lseg	*eg1,
		     const struct edge_g_lseg	*eg2,
		     struct vertex		*hit_v,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(struct vertex *nmg_common_v_2eg,
		    (struct edge_g_lseg	*eg1,
		     struct edge_g_lseg	*eg2,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int nmg_is_vertex_on_inter,
		    (struct vertex *v,
		     struct faceuse *fu1,
		     struct faceuse *fu2,
		     struct nmg_inter_struct *is));
RT_EXPORT BU_EXTERN(void nmg_isect_eu_verts,
		    (struct edgeuse *eu,
		     struct vertex_g *vg1,
		     struct vertex_g *vg2,
		     struct bu_ptbl *verts,
		     struct bu_ptbl *inters,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_isect_eu_eu,
		    (struct edgeuse *eu1,
		     struct vertex_g *vg1a,
		     struct vertex_g *vg1b,
		     vect_t dir1,
		     struct edgeuse *eu2,
		     struct bu_ptbl *verts,
		     struct bu_ptbl *inters,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_isect_eu_fu,
		    (struct nmg_inter_struct *is,
		     struct bu_ptbl		*verts,
		     struct edgeuse		*eu,
		     struct faceuse          *fu));
RT_EXPORT BU_EXTERN(void nmg_isect_fu_jra,
		    (struct nmg_inter_struct	*is,
		     struct faceuse		*fu1,
		     struct faceuse		*fu2,
		     struct bu_ptbl		*eu1_list,
		     struct bu_ptbl		*eu2_list));
RT_EXPORT BU_EXTERN(void nmg_isect_line2_face2pNEW,
		    (struct nmg_inter_struct *is,
		     struct faceuse *fu1, struct faceuse *fu2,
		     struct bu_ptbl *eu1_list,
		     struct bu_ptbl *eu2_list));
RT_EXPORT BU_EXTERN(int	nmg_is_eu_on_line3,
		    (const struct edgeuse	*eu,
		     const point_t		pt,
		     const vect_t		dir,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(struct edge_g_lseg	*nmg_find_eg_between_2fg,
		    (const struct faceuse	*ofu1,
		     const struct faceuse	*fu2,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(struct edgeuse *nmg_does_fu_use_eg,
		    (const struct faceuse	*fu1,
		     const unsigned long	*eg));
RT_EXPORT BU_EXTERN(int rt_line_on_plane,
		    (const point_t	pt,
		     const vect_t	dir,
		     const plane_t	plane,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_cut_lu_into_coplanar_and_non,
		    (struct loopuse *lu,
		     plane_t pl,
		     struct nmg_inter_struct *is));
RT_EXPORT BU_EXTERN(void nmg_check_radial_angles,
		    (char *str,
		     struct shell *s,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_faces_can_be_intersected,
		    (struct nmg_inter_struct *bs,
		     const struct faceuse *fu1,
		     const struct faceuse *fu2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_isect_two_generic_faces,
		    (struct faceuse		*fu1,
		     struct faceuse		*fu2,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_crackshells,
		    (struct shell *s1,
		     struct shell *s2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_fu_touchingloops,
		    (const struct faceuse *fu));


/* From nmg_index.c */
RT_EXPORT BU_EXTERN(int nmg_index_of_struct,
		    (const unsigned long *p));
RT_EXPORT BU_EXTERN(void nmg_m_set_high_bit,
		    (struct model *m));
RT_EXPORT BU_EXTERN(void nmg_m_reindex,
		    (struct model *m, long newindex));
RT_EXPORT BU_EXTERN(void nmg_vls_struct_counts,
		    (struct bu_vls *str,
		     const struct nmg_struct_counts *ctr));
RT_EXPORT BU_EXTERN(void nmg_pr_struct_counts,
		    (const struct nmg_struct_counts *ctr,
		     const char *str));
RT_EXPORT BU_EXTERN(unsigned long **nmg_m_struct_count,
		    (struct nmg_struct_counts *ctr,
		     const struct model *m));
RT_EXPORT BU_EXTERN(void nmg_struct_counts,
		    (const struct model	*m,
		     const char		*str));
RT_EXPORT BU_EXTERN(void nmg_merge_models,
		    (struct model *m1,
		     struct model *m2));
RT_EXPORT BU_EXTERN(long nmg_find_max_index,
		    (const struct model *m));

/* From nmg_rt.c */

/* From dspline.c */
RT_EXPORT BU_EXTERN(void rt_dspline_matrix,
		    (mat_t m, const char *type,
		     const double	tension,
		     const double	bias));
RT_EXPORT BU_EXTERN(double rt_dspline4,
		    (mat_t m,
		     double a,
		     double b,
		     double c,
		     double d,
		     double alpha));
RT_EXPORT BU_EXTERN(void rt_dspline4v,
		    (double *pt,
		     const mat_t m,
		     const double *a,
		     const double *b,
		     const double *c,
		     const double *d,
		     const int depth,
		     const double alpha));
RT_EXPORT BU_EXTERN(void rt_dspline_n,
		    (double *r,
		     const mat_t m,
		     const double *knots,
		     const int n,
		     const int depth,
		     const double alpha));

/* From nurb_bezier.c */
RT_EXPORT BU_EXTERN(int rt_nurb_bezier,
		    (struct bu_list *bezier_hd,
		     const struct face_g_snurb *orig_surf,
		     struct resource *res));
RT_EXPORT BU_EXTERN(int rt_bez_check,
		    (const struct face_g_snurb * srf));
RT_EXPORT BU_EXTERN(int nurb_crv_is_bezier,
		    (const struct edge_g_cnurb *crv));
RT_EXPORT BU_EXTERN(void nurb_c_to_bezier,
		    (struct bu_list *clist,
		     struct edge_g_cnurb *crv));

/* From nurb_copy.c */
RT_EXPORT BU_EXTERN(struct face_g_snurb *rt_nurb_scopy,
		    (const struct face_g_snurb * srf,
		     struct resource *res));
RT_EXPORT BU_EXTERN(struct edge_g_cnurb *rt_nurb_crv_copy,
		    (const struct edge_g_cnurb * crv));

/* From nmg_fuse.c */
RT_EXPORT BU_EXTERN(int nmg_is_common_bigloop,
		    (const struct face *f1,
		     const struct face *f2));
RT_EXPORT BU_EXTERN(void nmg_region_v_unique,
		    (struct nmgregion *r1,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_ptbl_vfuse,
		    (struct bu_ptbl *t,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int	nmg_region_both_vfuse,
		    (struct bu_ptbl *t1,
		     struct bu_ptbl *t2,
		     const struct bn_tol	*tol));
/* nmg_two_region_vertex_fuse replaced with nmg_model_vertex_fuse */
RT_EXPORT BU_EXTERN(int nmg_model_vertex_fuse,
		    (struct model *m,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_cnurb_is_linear,
		    (const struct edge_g_cnurb *cnrb));
RT_EXPORT BU_EXTERN(int nmg_snurb_is_planar,
		    (const struct face_g_snurb *srf,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_eval_linear_trim_curve,
		    (const struct face_g_snurb *snrb,
		     const fastf_t uvw[3],
		     point_t xyz));
RT_EXPORT BU_EXTERN(void nmg_eval_trim_curve,
		    (const struct edge_g_cnurb *cnrb,
		     const struct face_g_snurb *snrb,
		     const fastf_t t, point_t xyz));
/* nmg_split_trim */
RT_EXPORT BU_EXTERN(void nmg_eval_trim_to_tol,
		    (const struct edge_g_cnurb *cnrb,
		     const struct face_g_snurb *snrb,
		     const fastf_t t0,
		     const fastf_t t1,
		     struct bu_list *head,
		     const struct bn_tol *tol));
/* nmg_split_linear_trim */
RT_EXPORT BU_EXTERN(void nmg_eval_linear_trim_to_tol,
		    (const struct edge_g_cnurb *cnrb,
		     const struct face_g_snurb *snrb,
		     const fastf_t uvw1[3],
		     const fastf_t uvw2[3],
		     struct bu_list *head,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_cnurb_lseg_coincident,
		    (const struct edgeuse *eu1,
		     const struct edge_g_cnurb *cnrb,
		     const struct face_g_snurb *snrb,
		     const point_t pt1,
		     const point_t pt2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int	nmg_cnurb_is_on_crv,
		    (const struct edgeuse *eu,
		     const struct edge_g_cnurb *cnrb,
		     const struct face_g_snurb *snrb,
		     const struct bu_list *head,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_model_edge_fuse,
		    (struct model *m,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_model_edge_g_fuse,
		    (struct model		*m,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int nmg_ck_fu_verts,
		    (struct faceuse *fu1,
		     struct face *f2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_ck_fg_verts,
		    (struct faceuse *fu1,
		     struct face *f2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int	nmg_two_face_fuse,
		    (struct face	*f1,
		     struct face *f2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_model_face_fuse,
		    (struct model *m,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_break_all_es_on_v,
		    (unsigned long *magic_p,
		     struct vertex *v,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_model_break_e_on_v,
		    (struct model *m,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(int nmg_model_fuse,
		    (struct model *m,
		     const struct bn_tol *tol));

/* radial routines */
RT_EXPORT BU_EXTERN(void nmg_radial_sorted_list_insert,
		    (struct bu_list *hd,
		     struct nmg_radial *rad));
RT_EXPORT BU_EXTERN(void nmg_radial_verify_pointers,
		    (const struct bu_list *hd,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_radial_verify_monotone,
		    (const struct bu_list	*hd,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_insure_radial_list_is_increasing,
		    (struct bu_list	*hd,
		     fastf_t amin, fastf_t amax));
RT_EXPORT BU_EXTERN(void nmg_radial_build_list,
		    (struct bu_list		*hd,
		     struct bu_ptbl		*shell_tbl,
		     int			existing,
		     struct edgeuse		*eu,
		     const vect_t		xvec,
		     const vect_t		yvec,
		     const vect_t		zvec,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_radial_merge_lists,
		    (struct bu_list		*dest,
		     struct bu_list		*src,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int	 nmg_is_crack_outie,
		    (const struct edgeuse	*eu,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(struct nmg_radial	*nmg_find_radial_eu,
		    (const struct bu_list *hd,
		     const struct edgeuse *eu));
RT_EXPORT BU_EXTERN(const struct edgeuse *nmg_find_next_use_of_2e_in_lu,
		    (const struct edgeuse	*eu,
		     const struct edge	*e1,
		     const struct edge	*e2));
RT_EXPORT BU_EXTERN(void nmg_radial_mark_cracks,
		    (struct bu_list	*hd,
		     const struct edge	*e1,
		     const struct edge	*e2,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(struct nmg_radial *nmg_radial_find_an_original,
		    (const struct bu_list	*hd,
		     const struct shell	*s,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int nmg_radial_mark_flips,
		    (struct bu_list		*hd,
		     const struct shell	*s,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int nmg_radial_check_parity,
		    (const struct bu_list	*hd,
		     const struct bu_ptbl	*shells,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_radial_implement_decisions,
		    (struct bu_list		*hd,
		     const struct bn_tol	*tol,
		     struct edgeuse		*eu1,
		     vect_t xvec,
		     vect_t yvec,
		     vect_t zvec));
RT_EXPORT BU_EXTERN(void nmg_pr_radial,
		    (const char *title,
		     const struct nmg_radial	*rad));
RT_EXPORT BU_EXTERN(void nmg_pr_radial_list,
		    (const struct bu_list *hd,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_do_radial_flips,
		    (struct bu_list *hd));
RT_EXPORT BU_EXTERN(void nmg_do_radial_join,
		    (struct bu_list *hd,
		     struct edgeuse *eu1ref,
		     vect_t xvec, vect_t yvec, vect_t zvec,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_radial_join_eu_NEW,
		    (struct edgeuse *eu1,
		     struct edgeuse *eu2,
		     const struct bn_tol *tol));
RT_EXPORT BU_EXTERN(void nmg_radial_exchange_marked,
		    (struct bu_list		*hd,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_s_radial_harmonize,
		    (struct shell		*s,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(int nmg_eu_radial_check,
		    (const struct edgeuse	*eu,
		     const struct shell	*s,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_s_radial_check,
		    (struct shell		*s,
		     const struct bn_tol	*tol));
RT_EXPORT BU_EXTERN(void nmg_r_radial_check,
		    (const struct nmgregion	*r,
		     const struct bn_tol	*tol));


RT_EXPORT BU_EXTERN(struct edge_g_lseg	*nmg_pick_best_edge_g,
		    (struct edgeuse *eu1,
		     struct edgeuse *eu2,
		     const struct bn_tol *tol));

/* nmg_visit.c */
RT_EXPORT BU_EXTERN(void nmg_visit_vertex,
		    (struct vertex			*v,
		     const struct nmg_visit_handlers	*htab,
		     genptr_t			state));
RT_EXPORT BU_EXTERN(void nmg_visit_vertexuse,
		    (struct vertexuse		*vu,
		     const struct nmg_visit_handlers	*htab,
		     genptr_t			state));
RT_EXPORT BU_EXTERN(void nmg_visit_edge,
		    (struct edge			*e,
		     const struct nmg_visit_handlers	*htab,
		     genptr_t			state));
RT_EXPORT BU_EXTERN(void nmg_visit_edgeuse,
		    (struct edgeuse			*eu,
		     const struct nmg_visit_handlers	*htab,
		     genptr_t			state));
RT_EXPORT BU_EXTERN(void nmg_visit_loop,
		    (struct loop			*l,
		     const struct nmg_visit_handlers	*htab,
		     genptr_t			state));
RT_EXPORT BU_EXTERN(void nmg_visit_loopuse,
		    (struct loopuse			*lu,
		     const struct nmg_visit_handlers	*htab,
		     genptr_t			state));
RT_EXPORT BU_EXTERN(void nmg_visit_face,
		    (struct face			*f,
		     const struct nmg_visit_handlers	*htab,
		     genptr_t			state));
RT_EXPORT BU_EXTERN(void nmg_visit_faceuse,
		    (struct faceuse			*fu,
		     const struct nmg_visit_handlers	*htab,
		     genptr_t			state));
RT_EXPORT BU_EXTERN(void nmg_visit_shell,
		    (struct shell			*s,
		     const struct nmg_visit_handlers	*htab,
		     genptr_t			state));
RT_EXPORT BU_EXTERN(void nmg_visit_region,
		    (struct nmgregion		*r,
		     const struct nmg_visit_handlers	*htab,
		     genptr_t			state));
RT_EXPORT BU_EXTERN(void nmg_visit_model,
		    (struct model			*model,
		     const struct nmg_visit_handlers	*htab,
		     genptr_t			state));
RT_EXPORT BU_EXTERN(void nmg_visit,
		    (const unsigned long		*magicp,
		     const struct nmg_visit_handlers	*htab,
		     genptr_t			state));

/* db5_types.c */
RT_EXPORT BU_EXTERN(int db5_type_tag_from_major,
		    (char	**tag,
		     const int	major));

RT_EXPORT BU_EXTERN(int db5_type_descrip_from_major,
		    (char	**descrip,
		     const int	major));

RT_EXPORT BU_EXTERN(int db5_type_tag_from_codes,
		    (char	**tag,
		     const int	major,
		     const int	minor));

RT_EXPORT BU_EXTERN(int db5_type_descrip_from_codes,
		    (char	**descrip,
		     const int	major,
		     const int	minor));

RT_EXPORT BU_EXTERN(int db5_type_codes_from_tag,
		    (int	*major,
		     int	*minor,
		     const char	*tag));

RT_EXPORT BU_EXTERN(int db5_type_codes_from_descrip,
		    (int	*major,
		     int	*minor,
		     const char	*descrip));

RT_EXPORT BU_EXTERN(size_t db5_type_sizeof_h_binu,
		    (const int minor));

RT_EXPORT BU_EXTERN(size_t db5_type_sizeof_n_binu,
		    (const int minor));

#endif

/* defined in binary_obj.c */
RT_EXPORT BU_EXTERN(int rt_mk_binunif,
		    (struct rt_wdb *wdbp,
		     const char *obj_name,
		     const char *file_name,
		     unsigned int minor_type,
		     long max_count));

/* XXX do not rely on *_ifree() functions, why are these needed? */
#ifdef _RT_DECL_IFREE
/* defined in g_dsp.c */
RT_EXPORT BU_EXTERN(void rt_dsp_ifree,
		    (struct rt_db_internal *ip));

/* defined in g_ebm.c */
RT_EXPORT BU_EXTERN(void rt_ebm_ifree,
		    (struct rt_db_internal *ip));

/* defined in g_vol.c */
RT_EXPORT BU_EXTERN(void rt_vol_ifree,
		    (struct rt_db_internal *ip));
#endif

/* defined in db5_bin.c */
RT_EXPORT BU_EXTERN(void rt_binunif_free,
		    (struct rt_binunif_internal *bip));
RT_EXPORT BU_EXTERN(void rt_binunif_dump,
		    (struct rt_binunif_internal *bip));

/* defined in g_cline.c */
RT_EXPORT extern fastf_t rt_cline_radius;

/* defined in g_bot.c */
RT_EXPORT extern int rt_bot_minpieces;
RT_EXPORT extern int rt_bot_tri_per_piece;
#ifdef __RTGEOM_H__
RT_EXPORT BU_EXTERN(int rt_bot_sort_faces,
		    (struct rt_bot_internal *bot,
		     int tris_per_piece));
RT_EXPORT BU_EXTERN(int rt_bot_decimate,
		    (struct rt_bot_internal *bot,
		     fastf_t max_chord_error,
		     fastf_t max_normal_error,
		     fastf_t min_edge_length));
#endif


/*
 *  Constants provided and used by the RT library.
 */
RT_EXPORT extern const struct db_tree_state rt_initial_tree_state;
RT_EXPORT extern const char *rt_vlist_cmd_descriptions[];

/**
 * report version information about LIBRT
 */
RT_EXPORT BU_EXTERN(const char *rt_version, (void));

__END_DECLS

#endif /* __RAYTRACE_H__ */
/** @} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 9003
; brlcad.nsi

;--------------------------------
;BRL-CAD Version Variables

Var MAJOR
Var MINOR
Var PATCH
Var VERSION

Section
ClearErrors
IfFileExists ..\..\..\include\conf\MAJOR major_found
  Messagebox MB_OK "Unable to find MAJOR version file in ..\..\..\include\conf"
  Abort
major_found:
FileOpen $0 ..\..\..\include\conf\MAJOR r
IfErrors major
FileRead $0 $MAJOR
FileClose $0
Goto major_done
major:
StrCpy $MAJOR 'XX'
major_done:

ClearErrors
IfFileExists ..\..\..\include\conf\MINOR minor_found
  Messagebox MB_OK "Unable to find MINOR version file in ..\..\..\include\conf"
  Abort
minor_found:
FileOpen $0 ..\..\..\include\conf\MINOR r
IfErrors minor
FileRead $0 $MINOR
FileClose $0
Goto minor_done
minor:
StrCpy $MINOR 'XX'
minor_done:

ClearErrors
IfFileExists ..\..\..\include\conf\PATCH patch_found
  Messagebox MB_OK "Unable to find PATCH version file in ..\..\..\include\conf"
  Abort
patch_found:
FileOpen $0 ..\..\..\include\conf\PATCH r
IfErrors patch
FileRead $0 $PATCH
FileClose $0
Goto patch_done
patch:
StrCpy $PATCH 'XX'
patch_done:

StrCpy $VERSION "$MAJOR.$MINOR.$PATCH"
SectionEnd

;--------------------------------
;Include Modern UI

!include "MUI.nsh"
!include "FileFunc.nsh"

!insertmacro GetFileName

Function .onInit
  ; For the moment this must be global (nsis requires it)
  Var /GLOBAL PROG_FILES

  ReadEnvStr $PROG_FILES "PROGRAMFILES"
  StrCpy $INSTDIR "$PROG_FILES\BRL-CAD"
FunctionEnd

; Tack on BRL-CAD if it's not already there
Function .onVerifyInstDir
  ${GetFileName} $INSTDIR $R0
  StrCmp "BRL-CAD" $R0 found notFound

  notFound:
    StrCpy $INSTDIR "$INSTDIR\BRL-CAD"

  found:

FunctionEnd

;--------------------------------
;Configuration

  ; The name of the installer
  Name "BRL-CAD"

  ; The file to write
  OutFile "brlcad-$VERSION.exe"

  ; The default installation directory
  ;InstallDir $PROGRAMFILES\BRL-CAD

  ; Registry key to check for directory (so if you install again, it will 
  ; overwrite the old one automatically)
  InstallDirRegKey HKLM "Software\BRL-CAD" "Install_Dir"

  ; Make it look pretty in XP
  XPStyle on

;--------------------------------
;Variables

  Var MUI_TEMP
  Var STARTMENU_FOLDER
  Var BRLCAD_DATA_DIR

;--------------------------------
;Interface Settings

  ;Icons
  !define MUI_ICON "brlcad.ico"
  !define MUI_UNICON "uninstall.ico"

  ;Bitmaps
  !define MUI_WELCOMEFINISHPAGE_BITMAP "side.bmp"
  !define MUI_UNWELCOMEFINISHPAGE_BITMAP "side.bmp"

  !define MUI_HEADERIMAGE
  !define MUI_HEADERIMAGE_BITMAP "header.bmp"
  !define MUI_COMPONENTSPAGE_CHECKBITMAP "${NSISDIR}\Contrib\Graphics\Checks\simple-round2.bmp"

  !define MUI_COMPONENTSPAGE_SMALLDESC

  ;Show a warning before aborting install
  !define MUI_ABORTWARNING

;--------------------------------

; Pages

  ;Welcome page configuration
  !define MUI_WELCOMEPAGE_TEXT "This wizard will guide you through the installation of BRL-CAD $VERSION.\r\n\r\nBRL-CAD is a free open source multiplatform CAD software developed by the U.S. Army Research Laboratory (ARL).\r\n\r\nClick Next to continue."

  !insertmacro MUI_PAGE_WELCOME
  !insertmacro MUI_PAGE_LICENSE "..\..\COPYING"
  !insertmacro MUI_PAGE_COMPONENTS
  !insertmacro MUI_PAGE_DIRECTORY

  ;Start Menu Folder Page Configuration
  !define MUI_STARTMENUPAGE_REGISTRY_ROOT "HKLM" 
  !define MUI_STARTMENUPAGE_REGISTRY_KEY "Software\BRL-CAD$VERSION" 
  !define MUI_STARTMENUPAGE_REGISTRY_VALUENAME "Start Menu Folder"

  !insertmacro MUI_PAGE_STARTMENU Application $STARTMENU_FOLDER


  !insertmacro MUI_PAGE_INSTFILES

  ;Finished page configuration
  !define MUI_FINISHPAGE_NOAUTOCLOSE
  !define MUI_FINISHPAGE_SHOWREADME "..\..\README"
  !define MUI_FINISHPAGE_SHOWREADME_TEXT "View Readme"
  !define MUI_FINISHPAGE_SHOWREADME_NOTCHECKED

  !define MUI_FINISHPAGE_LINK "BRL-CAD Website"
  !define MUI_FINISHPAGE_LINK_LOCATION "http://brlcad.org/"

  !insertmacro MUI_PAGE_FINISH
  
  !insertmacro MUI_UNPAGE_WELCOME
  !insertmacro MUI_UNPAGE_CONFIRM
  !insertmacro MUI_UNPAGE_INSTFILES

  !define MUI_UNFINISHPAGE_NOAUTOCLOSE
  !insertmacro MUI_UNPAGE_FINISH

;--------------------------------
;Languages
 
  !insertmacro MUI_LANGUAGE "English"

;--------------------------------
;Installer Sections

; The stuff to install
Section "BRL-CAD (required)" BRL-CAD

  SectionIn RO

  ; Set output path to the installation directory.
  SetOutPath $INSTDIR
  File /r "..\..\brlcadInstall\archer.ico"
  File /r "..\..\brlcadInstall\brlcad.ico"

  SetOutPath $INSTDIR\bin
  File /r "..\..\brlcadInstall\bin\*"

  SetOutPath $INSTDIR\include
  File /r "..\..\brlcadInstall\include\*"

  SetOutPath $INSTDIR\lib
  File /r "..\..\brlcadInstall\lib\*"

  SetOutPath $INSTDIR\share
  File /r "..\..\brlcadInstall\share\*"

  ; Write the installation path into the registry
  WriteRegStr HKLM SOFTWARE\BRL-CAD "Install_Dir" "$INSTDIR"

  ; Write the uninstall keys for Windows
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\BRL-CAD" "DisplayName" "BRL-CAD $VERSION"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\BRL-CAD" "UninstallString" '"$INSTDIR\uninstall.exe"'
  ;Create uninstaller
  WriteUninstaller "uninstall.exe"


  StrCpy $BRLCAD_DATA_DIR "$INSTDIR\share\brlcad\$VERSION"

  ; Create desktop icons
  SetOutPath $INSTDIR
  CreateShortCut "$DESKTOP\Archer.lnk" "$INSTDIR\bin\archer.bat" "" "$INSTDIR\archer.ico" 0
  CreateShortCut "$DESKTOP\MGED.lnk" "$INSTDIR\bin\mged.bat" "" "$INSTDIR\brlcad.ico" 0
  CreateShortCut "$DESKTOP\RtWizard.lnk" "$INSTDIR\bin\rtwizard.bat" "" "$INSTDIR\brlcad.ico" 0

  !insertmacro MUI_STARTMENU_WRITE_BEGIN Application
    ;Main start menu shortcuts
    SetOutPath $INSTDIR
    CreateDirectory "$SMPROGRAMS\$STARTMENU_FOLDER"
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER\Archer.lnk" "$INSTDIR\bin\archer.bat" "" "$INSTDIR\archer.ico" 0
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER\MGED.lnk" "$INSTDIR\bin\mged.bat" "" "$INSTDIR\brlcad.ico" 0
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER\RtWizard.lnk" "$INSTDIR\bin\rtwizard.bat" "" "$INSTDIR\brlcad.ico" 0
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER\Uninstall.lnk" "$INSTDIR\uninstall.exe" "" "$INSTDIR\uninstall.exe" 0
  !insertmacro MUI_STARTMENU_WRITE_END

SectionEnd

Section "Documentation (required)" Documentation
  ; SectionIn RO means temporarily required
  ;SectionIn RO
  ;SetOutPath $INSTDIR\doc
  ;File /r ..\..\brlcadInstall\doc\*
  !insertmacro MUI_STARTMENU_WRITE_BEGIN Application
    ;Main start menu shortcuts
    SetOutPath $INSTDIR
    CreateDirectory "$SMPROGRAMS\$STARTMENU_FOLDER\Manuals"
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER\Manuals\Archer.lnk" "$BRLCAD_DATA_DIR\html\manuals\archer\Archer_Documentation.chm" "" "$INSTDIR\archer.ico" 0
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER\Manuals\BRL-CAD.lnk" "$BRLCAD_DATA_DIR\html\manuals\index.html" "" "$INSTDIR\brlcad.ico" 0
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER\Manuals\MGED.lnk" "$BRLCAD_DATA_DIR\html\manuals\mged\index.html" "" "$INSTDIR\brlcad.ico" 0
  !insertmacro MUI_STARTMENU_WRITE_END
SectionEnd

;Section "Samples" Samples
;  SetOutPath $INSTDIR\Samples
;  File ..\..\brlcadInstall\Samples\*
;SectionEnd

;Section "Developement headers" Developer
;  SetOutPath $INSTDIR\include
;  File ..\..\brlcadInstall\include\*
;SectionEnd

;--------------------------------
;Descriptions


  ;Language strings
  LangString DESC_BRL-CAD ${LANG_ENGLISH} "Installs the main application and the associated data files."
  LangString DESC_Documentation ${LANG_ENGLISH} "Installs documentation for BRL-CAD."
  ;LangString DESC_Samples ${LANG_ENGLISH} "Installs optional learning samples."
  ;LangString DESC_Developer ${LANG_ENGLISH} "Installs programming headers for developers."


  ;Assign language strings to sections
  !insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN
    !insertmacro MUI_DESCRIPTION_TEXT ${BRL-CAD} $(DESC_BRL-CAD)
    !insertmacro MUI_DESCRIPTION_TEXT ${Documentation} $(DESC_Documentation)
    ;!insertmacro MUI_DESCRIPTION_TEXT ${Samples} $(DESC_Samples)
    ;!insertmacro MUI_DESCRIPTION_TEXT ${Developer} $(DESC_Developer)
  !insertmacro MUI_FUNCTION_DESCRIPTION_END


;--------------------------------

; Uninstaller

Section "Uninstall"
  
  ; Remove registry keys
  DeleteRegKey HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\BRL-CAD"
  DeleteRegKey HKLM SOFTWARE\BRL-CAD

  !insertmacro MUI_STARTMENU_GETFOLDER Application $MUI_TEMP


  ; Remove shortcuts, if any
  Delete "$SMPROGRAMS\$MUI_TEMP\Manuals\*"
  Delete "$SMPROGRAMS\$MUI_TEMP\*"
  Delete "$DESKTOP\Archer.lnk"
  Delete "$DESKTOP\MGED.lnk"
  Delete "$DESKTOP\RtWizard.lnk"


  ; Remove miscellaneous files
  Delete "$INSTDIR\archer.ico"
  Delete "$INSTDIR\brlcad.ico"
  Delete "$INSTDIR\uninstall.exe"


  ; Remove directories used
  RMDir /r "$INSTDIR\bin"
  RMDir /r "$INSTDIR\include"
  RMDir /r "$INSTDIR\lib"
  RMDir /r "$INSTDIR\share"
  RMDir "$INSTDIR"
  RMDir "$SMPROGRAMS\$MUI_TEMP\Manuals"
  RMDir "$SMPROGRAMS\$MUI_TEMP"

SectionEnd
blob
data 19097
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="8.00"
	Name="librt"
	ProjectGUID="{EA0BB405-25E2-4B31-92D7-97316770F32B}"
	RootNamespace="librt"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory=".\$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory=".\$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="2"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				PreprocessorDefinitions="NDEBUG"
				MkTypLibCompatible="true"
				SuppressStartupBanner="true"
				TargetEnvironment="1"
				TypeLibraryName=".\$(PlatformName)\$(ConfigurationName)/librt.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="2"
				InlineFunctionExpansion="1"
				AdditionalIncludeDirectories="../../../include;../../../src/librt;../../../src/other/libregex;../../../src/other/tcl/generic;../../../src/other/tcl/win;../../../src/other/libz;../../../src/other/opennurbs;../../../src/other/tnt"
				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;__win32;ON_DLL_IMPORTS;RT_EXPORT_DLL;DB5_EXPORT_DLL;BRLCAD_DLL;HAVE_CONFIG_H;BRLCADBUILD;NEW_TOPS_BEHAVIOR;OBJ_BREP=1;TCL_THREADS=1;_RT_DECL_IFREE;_CRT_SECURE_NO_WARNINGS"
				StringPooling="true"
				BasicRuntimeChecks="0"
				RuntimeLibrary="2"
				EnableFunctionLevelLinking="true"
				TreatWChar_tAsBuiltInType="false"
				RuntimeTypeInfo="true"
				UsePrecompiledHeader="0"
				PrecompiledHeaderFile=".\$(PlatformName)\$(ConfigurationName)/librt.pch"
				AssemblerListingLocation=".\$(PlatformName)\$(ConfigurationName)/"
				ObjectFile=".\$(PlatformName)\$(ConfigurationName)/"
				ProgramDataBaseFileName=".\$(PlatformName)\$(ConfigurationName)/"
				WarningLevel="3"
				SuppressStartupBanner="true"
				Detect64BitPortabilityProblems="false"
				DebugInformationFormat="0"
				CompileAs="0"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
				Culture="1033"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="tcl85.lib libbu.lib libbn.lib libsysv.lib libregex.lib opennurbs.lib"
				OutputFile=".\$(PlatformName)\$(ConfigurationName)/librt.dll"
				LinkIncremental="1"
				SuppressStartupBanner="true"
				AdditionalLibraryDirectories="../../../brlcadInstall/lib"
				GenerateDebugInformation="false"
				ProgramDatabaseFile=".\$(PlatformName)\$(ConfigurationName)/librt.pdb"
				ImportLibrary=".\$(PlatformName)\$(ConfigurationName)/librt.lib"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
				CommandLine="copy &quot;$(TargetPath)&quot; ..\..\..\brlcadInstall\bin&#x0D;&#x0A;copy &quot;$(TargetDir)&quot;librt.lib ..\..\..\brlcadInstall\lib&#x0D;&#x0A;"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="2"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				PreprocessorDefinitions="NDEBUG"
				MkTypLibCompatible="true"
				SuppressStartupBanner="true"
				TargetEnvironment="3"
				TypeLibraryName=".\$(PlatformName)\$(ConfigurationName)/librt.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="2"
				InlineFunctionExpansion="1"
				AdditionalIncludeDirectories="../../../include;../../../src/librt;../../../src/other/tcl/generic;../../../src/other/tcl/win;../../../src/other/libz;../../../src/other/opennurbs;../../../src/other/tnt"
				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;__win32;ON_DLL_IMPORTS;RT_EXPORT_DLL;DB5_EXPORT_DLL;BRLCAD_DLL;HAVE_CONFIG_H;BRLCADBUILD;NEW_TOPS_BEHAVIOR;OBJ_BREP=1;TCL_THREADS=1;_RT_DECL_IFREE;_CRT_SECURE_NO_WARNINGS"
				StringPooling="true"
				BasicRuntimeChecks="0"
				RuntimeLibrary="2"
				EnableFunctionLevelLinking="true"
				TreatWChar_tAsBuiltInType="false"
				RuntimeTypeInfo="true"
				UsePrecompiledHeader="0"
				PrecompiledHeaderFile=".\$(PlatformName)\$(ConfigurationName)/librt.pch"
				AssemblerListingLocation=".\$(PlatformName)\$(ConfigurationName)/"
				ObjectFile=".\$(PlatformName)\$(ConfigurationName)/"
				ProgramDataBaseFileName=".\$(PlatformName)\$(ConfigurationName)/"
				WarningLevel="3"
				SuppressStartupBanner="true"
				Detect64BitPortabilityProblems="false"
				DebugInformationFormat="0"
				CompileAs="0"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
				Culture="1033"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="tcl85.lib libbu.lib libbn.lib libsysv.lib libregex.lib opennurbs.lib"
				OutputFile=".\$(PlatformName)\$(ConfigurationName)/librt.dll"
				LinkIncremental="1"
				SuppressStartupBanner="true"
				AdditionalLibraryDirectories="../../../brlcadInstall$(PlatformName)/lib"
				GenerateDebugInformation="false"
				ProgramDatabaseFile=".\$(PlatformName)\$(ConfigurationName)/librt.pdb"
				ImportLibrary=".\$(PlatformName)\$(ConfigurationName)/librt.lib"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
				CommandLine="copy &quot;$(TargetPath)&quot; ..\..\..\brlcadInstall$(PlatformName)\bin&#x0D;&#x0A;copy &quot;$(TargetDir)&quot;librt.lib ..\..\..\brlcadInstall$(PlatformName)\lib&#x0D;&#x0A;"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat;f90;for;f;fpp"
			>
			<File
				RelativePath="..\..\..\src\librt\primitives\arb8\arb8.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\arbn\arbn.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\ars\ars.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\bezier_2d_isect.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\binary_obj.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\bomb.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\bool.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bot\bot.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\brep\brep.cpp"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\bspline.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\bundle.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\cline\cline.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\cmd.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\cut.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db5_alloc.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db5_bin.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db5_comb.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db5_io.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db5_scan.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db5_types.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_alloc.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_anim.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_comb.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_flags.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_inmem.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_io.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_lookup.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_match.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_open.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_path.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_scan.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_tree.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\db_walk.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\dir.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\dsp\dsp.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\dspline.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\ebm\ebm.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\ehy\ehy.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\ell\ell.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\epa\epa.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\eto\eto.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\extrude\extrude.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\fortray.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\globals.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\grip\grip.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\half\half.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\hf\hf.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\htbl.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\hyp\hyp.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\many.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\mater.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\memalloc.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\metaball\metaball.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\mirror.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\mkbundle.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_bool.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_ck.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_class.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_eval.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_extrude.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_fcut.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_fuse.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_index.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_info.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_inter.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_manif.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_mesh.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_misc.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_mk.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_mod.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_plot.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_pr.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_pt_fu.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_rt_isect.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_rt_segs.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_tri.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\nmg\nmg_visit.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_basis.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_bezier.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_bound.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_c2.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_copy.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_diff.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_eval.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_flat.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_interp.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_knot.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_norm.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_plot.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_poly.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_ray.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_refine.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_reverse.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_solve.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_split.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_tess.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_trim.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_trim_util.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_util.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\bspline\nurb_xsplit.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\opennurbs_ext.cpp"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\oslo_calc.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\oslo_map.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\part\part.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\pipe\pipe.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\poly\poly.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\pr.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\prep.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\rec\rec.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\regionfix.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\rhc\rhc.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\roots.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\rpc\rpc.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\shoot.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\sketch\sketch.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\spectrum.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\sph\sph.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\storage.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\submodel\submodel.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\superell\superell.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\table.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\tcl.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\tgc\tgc.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\timer-nt.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\tor\tor.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\transform.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\tree.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\vers.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\vlist.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\primitives\vol\vol.c"
				>
			</File>
			<File
				RelativePath="..\..\..\src\librt\wdb.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;fi;fd"
			>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>
blob
data 18908
#                      I N S T A L L T R E E . T C L
# BRL-CAD
#
# Copyright (c) 2002-2007 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# version 2.1 as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this file; see the file named COPYING for more
# information.
#
###
#
# Author(s):
#    Bob Parker
#
# Description:
#    Script for building the install tree on Windows.
#

set brlcadInstall [lindex $argv 0]
if {$brlcadInstall == ""} {
    set brlcadInstall brlcadInstall
}

set rootDir [file normalize ../../..]
if {![file exists $rootDir]} {
    puts "$rootDir must exist and must be the root of the BRL-CAD source tree. "
    return
}

set installDir [file join $rootDir $brlcadInstall]
if {[file exists $installDir]} {
    puts "$installDir already exists."
    return
}

# Look for required source files
set missingFile 0
if {![file exists [file join $rootDir src other iwidgets iwidgets.tcl.in]]} {
    puts "Missing [file join $rootDir src other iwidgets iwidgets.tcl.in]"
    set missingFile 1
}

if {![file exists [file join $rootDir src other iwidgets pkgIndex.tcl.in]]} {
    puts "Missing [file join $rootDir src other iwidgets pkgIndex.tcl.in]"
    set missingFile 1
}

if {![file exists [file join $rootDir src other tk win wish.exe.manifest].in]} {
    puts "Missing [file join $rootDir src other tk win wish.exe.manifest].in]"
    set missingFile 1
}

if {![file exists [file join $rootDir include conf MAJOR]]} {
    puts "Missing [file join $rootDir include conf MAJOR]]"
    set missingFile 1
}

if {![file exists [file join $rootDir include conf MINOR]]} {
    puts "Missing [file join $rootDir include conf MINOR]]"
    set missingFile 1
}

if {![file exists [file join $rootDir include conf PATCH]]} {
    puts "Missing [file join $rootDir include conf PATCH]]"
    set missingFile 1
}


if {$missingFile} {
    return
}


# Set Tcl related versions
set tclVersion "8.5"
set itclVersion "3.4"
set iwidgetsVersion "4.0.2"
set bltVersion "2.4"


# Set BRL-CAD's version
set fd [open [file join $rootDir include conf MAJOR] "r"]
set major [read $fd]
close $fd

set fd [open [file join $rootDir include conf MINOR] "r"]
set minor [read $fd]
close $fd

set fd [open [file join $rootDir include conf PATCH] "r"]
set patch [read $fd]
close $fd

set major [string trim $major]
set minor [string trim $minor]
set patch [string trim $patch]

if {![string is int $major] ||
    ![string is int $minor] ||
    ![string is int $patch]} {
    puts "Failed to acquire BRL-CAD's version."
    puts "Bad value for one or more of the following:"
    puts "major - $major, minor - $minor, patch - $patch"
    return
}

set cadVersion "$major.$minor.$patch"
# End Set BRL-CAD's version

set shareDir [file join $installDir share brlcad $cadVersion]

# More initialization for tclsh
# Show tclsh where to find required tcl files
lappend auto_path [file join $rootDir src other tcl library]
lappend auto_path [file join $rootDir misc win32-msvc8 tclsh library]
file copy -force [file join $rootDir src other incrTcl itcl library itcl.tcl] [file join $rootDir misc win32-msvc8 tclsh library]
file copy -force [file join $rootDir src other incrTcl itcl library pkgIndex.tcl] [file join $rootDir misc win32-msvc8 tclsh library]
set argv ""
source "[file join $rootDir src tclscripts ami.tcl]"
package require Itcl

# End More initialization for tclsh


# Create install directories
puts "Creating [file join $installDir]"
file mkdir [file join $installDir]
puts "Creating [file join $installDir bin]"
file mkdir [file join $installDir bin]
puts "Creating [file join $installDir lib]"
file mkdir [file join $installDir lib]
puts "Creating [file join $installDir lib iwidgets$iwidgetsVersion]"
file mkdir [file join $installDir lib iwidgets$iwidgetsVersion]
puts "Creating [file join $installDir share]"
file mkdir [file join $installDir share]
puts "Creating [file join $installDir share brlcad]"
file mkdir [file join $installDir share brlcad]
puts "Creating [file join $shareDir]"
file mkdir [file join $shareDir]
puts "Creating [file join $shareDir plugins]"
file mkdir [file join $shareDir plugins]
puts "Creating [file join $shareDir plugins archer]"
file mkdir [file join $shareDir plugins archer]
puts "Creating [file join $shareDir plugins archer Utilities]"
file mkdir [file join $shareDir plugins archer Utilities]
puts "Creating [file join $shareDir plugins archer Wizards]"
file mkdir [file join $shareDir plugins archer Wizards]
puts "Creating [file join $shareDir db]"
file mkdir [file join $shareDir db]
#puts "Creating [file join $shareDir pix]"
#file mkdir [file join $shareDir pix]
puts "Creating [file join $shareDir sample_applications]"
file mkdir [file join $shareDir sample_applications]
# End Create install directories


# Copy files to install directory
puts "copy [file join $rootDir doc html manuals archer archer.ico] [file join $installDir]"
file copy [file join $rootDir doc html manuals archer archer.ico] [file join $installDir]
puts "copy [file join $rootDir misc nsis brlcad.ico] [file join $installDir]"
file copy [file join $rootDir misc nsis brlcad.ico] [file join $installDir]


# Copy files to the bin directory
puts "copy [file join $rootDir src archer archer] [file join $installDir bin]"
file copy [file join $rootDir src archer archer] [file join $installDir bin]
puts "copy [file join $rootDir src archer archer.bat] [file join $installDir bin]"
file copy [file join $rootDir src archer archer.bat] [file join $installDir bin]
puts "copy [file join $rootDir src mged mged.bat] [file join $installDir bin]"
file copy [file join $rootDir src mged mged.bat] [file join $installDir bin]
puts "copy [file join $rootDir src util rtwizard.bat] [file join $installDir bin]"
file copy [file join $rootDir src util rtwizard.bat] [file join $installDir bin]
# End Copy files to the bin directory


# Copy files to the include directory
file copy [file join $rootDir include] $installDir
# End Copy files to the include directory


# Copy files to the lib directory
puts "copy [file join $rootDir src other blt library] [file join $installDir lib blt$bltVersion]"
file copy [file join $rootDir src other blt library] [file join $installDir lib blt$bltVersion]
puts "copy [file join $rootDir src other tcl library] [file join $installDir lib tcl$tclVersion]"
file copy [file join $rootDir src other tcl library] [file join $installDir lib tcl$tclVersion]
puts "copy [file join $rootDir src other tk library] [file join $installDir lib tk$tclVersion]"
file copy [file join $rootDir src other tk library] [file join $installDir lib tk$tclVersion]
puts "copy [file join $rootDir src other incrTcl itcl library] [file join $installDir lib itcl$itclVersion]"
file copy [file join $rootDir src other incrTcl itcl library] [file join $installDir lib itcl$itclVersion]
puts "copy [file join $rootDir src other incrTcl itk library] [file join $installDir lib itk$itclVersion]"
file copy [file join $rootDir src other incrTcl itk library] [file join $installDir lib itk$itclVersion]
puts "copy [file join $rootDir src other iwidgets generic] [file join $installDir lib iwidgets$iwidgetsVersion]"
file copy [file join $rootDir src other iwidgets generic] [file join $installDir lib iwidgets$iwidgetsVersion scripts]
# End Copy files to the lib directory


# Copy files to the share directories
puts "copy [file join $rootDir AUTHORS] [file join $shareDir]"
file copy [file join $rootDir AUTHORS] [file join $shareDir]
puts "copy [file join $rootDir COPYING] [file join $shareDir]"
file copy [file join $rootDir COPYING] [file join $shareDir]
puts "copy [file join $rootDir doc] [file join $shareDir]"
file copy [file join $rootDir doc] [file join $shareDir]
puts "copy [file join $rootDir doc html] [file join $shareDir]"
file copy [file join $rootDir doc html] [file join $shareDir]
puts "copy [file join $rootDir HACKING] [file join $shareDir]"
file copy [file join $rootDir HACKING] [file join $shareDir]
puts "copy [file join $rootDir INSTALL] [file join $shareDir]"
file copy [file join $rootDir INSTALL] [file join $shareDir]
puts "copy [file join $rootDir NEWS] [file join $shareDir]"
file copy [file join $rootDir NEWS] [file join $shareDir]
puts "copy [file join $rootDir README] [file join $shareDir]"
file copy [file join $rootDir README] [file join $shareDir]
puts "copy [file join $rootDir misc fortran_example.f] [file join $shareDir sample_applications]"
file copy [file join $rootDir misc fortran_example.f] [file join $shareDir sample_applications]
puts "copy [file join $rootDir src vfont] [file join $shareDir]"
file copy [file join $rootDir src vfont] [file join $shareDir]
puts "copy [file join $rootDir src tclscripts] [file join $shareDir]"
file copy [file join $rootDir src tclscripts] [file join $shareDir]
puts "copy [file join $rootDir src archer plugins utility.tcl] [file join $shareDir plugins archer]"
file copy [file join $rootDir src archer plugins utility.tcl] \
    [file join $shareDir plugins archer]
puts "copy [file join $rootDir src archer plugins wizards.tcl] [file join $shareDir plugins archer]"
file copy [file join $rootDir src archer plugins wizards.tcl] \
    [file join $shareDir plugins archer]
puts "copy [file join $rootDir src conv g-xxx.c] [file join $shareDir sample_applications]"
file copy [file join $rootDir src conv g-xxx.c] [file join $shareDir sample_applications]
puts "copy [file join $rootDir src conv g-xxx_facets.c] [file join $shareDir sample_applications]"
file copy [file join $rootDir src conv g-xxx_facets.c] [file join $shareDir sample_applications]
puts "copy [file join $rootDir src gtools g_transfer.c] [file join $shareDir sample_applications]"
file copy [file join $rootDir src gtools g_transfer.c] [file join $shareDir sample_applications]
puts "copy [file join $rootDir src libpkg tpkg.c] [file join $shareDir sample_applications]"
file copy [file join $rootDir src libpkg tpkg.c] [file join $shareDir sample_applications]
puts "copy [file join $rootDir src librt primitives xxx xxx.c] [file join $shareDir sample_applications]"
file copy [file join $rootDir src librt primitives xxx xxx.c] [file join $shareDir sample_applications]
puts "copy [file join $rootDir src librt raydebug.tcl] [file join $shareDir sample_applications]"
file copy [file join $rootDir src librt raydebug.tcl] [file join $shareDir sample_applications]
puts "copy [file join $rootDir src librt nurb_example.c] [file join $shareDir sample_applications]"
file copy [file join $rootDir src librt nurb_example.c] [file join $shareDir sample_applications]
puts "copy [file join $rootDir src rt rtexample.c] [file join $shareDir sample_applications]"
file copy [file join $rootDir src rt rtexample.c] [file join $shareDir sample_applications]
puts "copy [file join $rootDir src util pl-dm.c] [file join $shareDir sample_applications]"
file copy [file join $rootDir src util pl-dm.c] [file join $shareDir sample_applications]
puts "copy [file join $rootDir src util roots_example.c] [file join $shareDir sample_applications]"
file copy [file join $rootDir src util roots_example.c] [file join $shareDir sample_applications]
puts "copy [file join $rootDir src nirt sfiles] [file join $shareDir nirt]"
file copy [file join $rootDir src nirt sfiles] [file join $shareDir nirt]
# End Copy files to the share directories


# Remove undesired directories/files as a result of wholesale copies
file delete -force [file join $installDir include .cvsignore]
file delete -force [file join $installDir include conf .cvsignore]
file delete -force [file join $installDir lib blt$bltVersion Makefile.am]
file delete -force [file join $installDir lib blt$bltVersion dd_protocols Makefile.am]
file delete -force [file join $installDir lib itcl$itclVersion Makefile.am]
file delete -force [file join $installDir lib itk$itclVersion Makefile.am]
file delete -force [file join $installDir lib iwidgets$iwidgetsVersion Makefile.am]
file delete -force [file join $installDir lib iwidgets$iwidgetsVersion scripts Makefile.am]
#file delete -force [file join $installDir lib tk$tclVersion Makefile.am]
#file delete -force [file join $installDir lib tk$tclVersion demos Makefile.am]
#file delete -force [file join $installDir lib tk$tclVersion demos images Makefile.am]
#file delete -force [file join $installDir lib tk$tclVersion images Makefile.am]
#file delete -force [file join $installDir lib tk$tclVersion msgs Makefile.am]
#file delete -force [file join $installDir lib tk$tclVersion ttk Makefile.am]

file delete -force [file join $shareDir doc .cvsignore]
file delete -force [file join $shareDir doc book Makefile.am]
file delete -force [file join $shareDir doc html]
file delete -force [file join $shareDir doc legal Makefile.am]
file delete -force [file join $shareDir doc Makefile.am]

file delete -force [file join $shareDir html Makefile.am]
file delete -force [file join $shareDir html manuals Anim_Tutorial Makefile.am]
file delete -force [file join $shareDir html manuals archer Makefile.am]
file delete -force [file join $shareDir html manuals cadwidgets Makefile.am]
file delete -force [file join $shareDir html manuals libbu Makefile.am]
file delete -force [file join $shareDir html manuals libdm Makefile.am]
file delete -force [file join $shareDir html manuals librt Makefile.am]
file delete -force [file join $shareDir html manuals Makefile.am]
file delete -force [file join $shareDir html manuals mged .cvsignore]
file delete -force [file join $shareDir html manuals mged Makefile.am]
file delete -force [file join $shareDir html manuals mged animmate Makefile.am]
file delete -force [file join $shareDir html manuals shaders Makefile.am]
file delete -force [file join $shareDir html ReleaseNotes Makefile.am]
file delete -force [file join $shareDir html ReleaseNotes Rel5.0 Makefile.am]
file delete -force [file join $shareDir html ReleaseNotes Rel5.0 Summary Makefile.am]
file delete -force [file join $shareDir html ReleaseNotes Rel6.0 Makefile.am]

file delete -force [file join $shareDir tclscripts archer images Makefile.am]
file delete -force [file join $shareDir tclscripts archer images Themes Makefile.am]
file delete -force [file join $shareDir tclscripts archer images Themes Crystal Makefile.am]
file delete -force [file join $shareDir tclscripts archer images Themes Crystal_Large Makefile.am]
file delete -force [file join $shareDir tclscripts archer images Themes Windows Makefile.am]
file delete -force [file join $shareDir tclscripts archer Makefile.am]
file delete -force [file join $shareDir tclscripts geometree Makefile.am]
file delete -force [file join $shareDir tclscripts lib Makefile.am]
file delete -force [file join $shareDir tclscripts mged Makefile.am]
file delete -force [file join $shareDir tclscripts nirt Makefile.am]
file delete -force [file join $shareDir tclscripts pl-dm Makefile.am]
file delete -force [file join $shareDir tclscripts rtwizard Makefile.am]
file delete -force [file join $shareDir tclscripts rtwizard examples Makefile.am]
file delete -force [file join $shareDir tclscripts rtwizard examples PictureTypeA Makefile.am]
file delete -force [file join $shareDir tclscripts rtwizard examples PictureTypeB Makefile.am]
file delete -force [file join $shareDir tclscripts rtwizard examples PictureTypeC Makefile.am]
file delete -force [file join $shareDir tclscripts rtwizard examples PictureTypeD Makefile.am]
file delete -force [file join $shareDir tclscripts rtwizard examples PictureTypeE Makefile.am]
file delete -force [file join $shareDir tclscripts rtwizard examples PictureTypeF Makefile.am]
file delete -force [file join $shareDir tclscripts rtwizard lib Makefile.am]
file delete -force [file join $shareDir tclscripts sdialogs Makefile.am]
file delete -force [file join $shareDir tclscripts sdialogs scripts Makefile.am]
file delete -force [file join $shareDir tclscripts swidgets Makefile.am]
file delete -force [file join $shareDir tclscripts swidgets images Makefile.am]
file delete -force [file join $shareDir tclscripts swidgets scripts Makefile.am]
file delete -force [file join $shareDir tclscripts util Makefile.am]
file delete -force [file join $shareDir tclscripts Makefile.am]
file delete -force [file join $shareDir vfont Makefile.am]
file delete -force [file join $shareDir nirt Makefile.am]
# End Remove undesired directories/files as a result of wholesale copies


# Create iwidgets.tcl
set fd1 [open [file join $rootDir src other iwidgets iwidgets.tcl.in] r]
set lines [read $fd1]
close $fd1
puts "Creating [file join $installDir lib iwidgets$iwidgetsVersion iwidgets.tcl]"
set fd2 [open [file join $installDir lib iwidgets$iwidgetsVersion iwidgets.tcl] w]
set lines [regsub -all {@ITCL_VERSION@} $lines $itclVersion]
set lines [regsub -all {@IWIDGETS_VERSION@} $lines $iwidgetsVersion]
puts $fd2 $lines
close $fd2
# End Create iwidgets.tcl


# Create pkgIndex.tcl for iwidgets
set fd1 [open [file join $rootDir src other iwidgets pkgIndex.tcl.in] r]
set lines [read $fd1]
close $fd1
puts "Creating [file join $installDir lib iwidgets$iwidgetsVersion pkgIndex.tcl]"
set fd2 [open [file join $installDir lib iwidgets$iwidgetsVersion pkgIndex.tcl] w]
set lines [regsub -all {@IWIDGETS_VERSION@} $lines $iwidgetsVersion]
puts $fd2 $lines
close $fd2
# End Create pkgIndex.tcl for iwidgets


# Create wish.exe.manifest
set fd1 [open [file join $rootDir src other tk win wish.exe.manifest].in r]
set lines [read $fd1]
close $fd1
puts "Creating [file join $rootDir src other tk win wish.exe.manifest]"
set fd2 [open [file join $rootDir src other tk win wish.exe.manifest] w]
set lines [regsub -all {@TK_WIN_VERSION@} $lines $tclVersion]
set lines [regsub -all {@MACHINE@} $lines "x86"]
puts $fd2 $lines
close $fd2
# End Create wish.exe.manifest


# Create the tclIndex files
#lappend auto_path 
make_tclIndex [list [file join $shareDir tclscripts]]
make_tclIndex [list [file join $shareDir tclscripts lib]]
make_tclIndex [list [file join $shareDir tclscripts archer]]
make_tclIndex [list [file join $shareDir tclscripts mged]]
make_tclIndex [list [file join $shareDir tclscripts rtwizard]]
make_tclIndex [list [file join $shareDir tclscripts util]]

#XXX More needed

# End Create the tclIndex files


# Copy redist files
catch {
    file copy "C:/Program Files/Microsoft Visual Studio 8/VC/redist/x86/Microsoft.VC80.CRT" [file join $installDir bin]
    file copy "C:/Program Files/Microsoft Visual Studio 8/VC/redist/x86/Microsoft.VC80.MFC" [file join $installDir bin]
}
#blob
data 399
# $Id$

SUBDIRS = \
	bench \
	doc \
	isst \
	libcommon \
	librender \
	libtexture \
	libtie \
	libtienet \
	libutil \
	master \
	misc \
	rise \
	scripts \
	slave

tieincludedir = $(includedir)/tie
tieinclude_HEADERS = adrt.h adrt_struct.h

if HAVE_DOXYGEN
doxygen:
	mkdir doxygen
	doxygen Doxyfile
endif

EXTRA_DIST = \
	AUTHORS \
	README

DEPS = src/libbu

include $(top_srcdir)/misc/Makefile.defs
blob
data 6518
/*                         B E N C H . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2007-2008 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/**
 * @file bench.c
 */

#include "bench.h"
#include <math.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
/*** lib common ***/
#include "canim.h"
#include "cdb.h"
#include "pack.h"
#include "unpack.h"
/*** lib util ***/
#include "camera.h"
#include "image.h"
#include "umath.h"
/*** Networking Includes ***/
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include "bio.h"


#define LOCAL_PORT 10000


void *bench_frame;
common_db_t db;
util_camera_t camera;
tie_t tie;
void *app_data;
int app_size;
int server_socket;
pthread_t bench_thread;
tienet_sem_t bench_net_sem;


static void* bench_ipc(void *ptr) {
    struct sockaddr_in server;
    struct sockaddr_in client;
    int client_socket;
    unsigned int addrlen;


    /* create a socket */
    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
	fprintf(stderr, "unable to create socket, exiting.\n");
	exit(1);
    }

    /* server address */
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = htonl(INADDR_ANY);
    server.sin_port = htons(LOCAL_PORT);

    /* bind socket */
    if (bind(server_socket, (struct sockaddr *)&server, sizeof(server)) < 0) {
	fprintf(stderr, "socket already bound, exiting.\n");
	exit(1);
    }

    /* listen for connections */
    listen(server_socket, 3);

    /* wait for connection before streaming data */
    addrlen = sizeof(client);
    tienet_sem_post(&bench_net_sem);
    client_socket = accept(server_socket, (struct sockaddr *)&client, &addrlen);

    /* send the application data */
    printf("ipc connection established, sending data: %d bytes\n", app_size);
    tienet_send(client_socket, &app_size, sizeof(int));
    tienet_send(client_socket, app_data, app_size);

    close(client_socket);
    close(server_socket);
}


void bench(char* proj, int cache, int image) {
    struct sockaddr_in server;
    struct sockaddr_in client;
    struct hostent h;
    int i, res_len, client_socket;
    common_work_t work;
    void *res_buf;
    unsigned char *image24;
    clock_t ticks1, ticks2, ticks3;
    tfloat t;


    ticks1 = clock();
    tienet_sem_init(&bench_net_sem, 0);

    printf("loading and prepping ...\n");
    /* Camera with no threads */
    util_camera_init(&camera, 1);

    /* Parse Env Data */
    common_db_load(&db, proj);

    /*
     * Hack the environment settings to make it think there is no cache file
     * if the user is generating one, otherwise it never generates one
     */
    if (cache)
	db.env.kdtree_cache_file[0] = 0;

    /* Read the data off disk and pack it */
    app_size = common_pack(&db, &app_data, proj);

    /* Launch a networking thread to do ipc data streaming */
    pthread_create(&bench_thread, NULL, bench_ipc, 0);

    /* Parse the data into memory for rendering */
    /* create a socket */
    if ((client_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
	fprintf(stderr, "unable to create socket, exiting.\n");
	exit(1);
    }

    /* Bind any available port number */
    client.sin_family = AF_INET;
    client.sin_addr.s_addr = htonl(INADDR_ANY);
    client.sin_port = htons(0);

    if (bind(client_socket, (struct sockaddr *)&client, sizeof(client)) < 0) {
	fprintf(stderr, "unable to bind socket, exiting\n");
	exit(1);
    }

    /* Establish ipc connection */
    if (gethostbyname("localhost")) {
	h = gethostbyname("localhost")[0];
    } else {
	fprintf(stderr, "unknown host: %s\n", "localhost");
	exit(1);
    }

    server.sin_family = h.h_addrtype;
    memcpy((char *)&server.sin_addr.s_addr, h.h_addr_list[0], h.h_length);
    server.sin_port = htons(LOCAL_PORT);

    tienet_sem_wait(&bench_net_sem);
    if (connect(client_socket, (struct sockaddr *)&server, sizeof(server)) < 0) {
	fprintf(stderr, "cannot establish connection, exiting.\n");
	exit(1);
    }

    /* stream and unpack the data */
    common_unpack(&db, &tie, &camera, client_socket);
    tie_prep(&tie);

    /* Prep */
    common_env_prep(&db.env);
    util_camera_prep(&camera, &db);

    /* Allocate memory for a frame */
    bench_frame = malloc(4 * sizeof(tfloat) * db.env.img_w * db.env.img_h);
    if (!bench_frame) {
	perror("bench_frame");
	exit(1);
    }
    memset(bench_frame, 0, 4 * sizeof(tfloat) * db.env.img_w * db.env.img_h);

    /* Render an image */
    work.orig_x = 0;
    work.orig_y = 0;
    work.size_x = db.env.img_w;
    work.size_y = db.env.img_h;
    work.format = COMMON_BIT_DEPTH_24;

    printf("rendering ...\n");
    res_buf = NULL;
    ticks2 = clock();
    util_camera_render(&camera, &db, &tie, &work, sizeof(common_work_t), &res_buf, &res_len);
    ticks3 = clock();

    printf("prep   time: %.3f sec\n", (tfloat)(ticks2 - ticks1) / (tfloat)CLOCKS_PER_SEC);
    t = (tfloat)(ticks3 - ticks2) / (tfloat)CLOCKS_PER_SEC;
    printf("render time: %.3f sec\n", t);
    printf("rays /  sec: %d\n", (int)((db.env.img_w * db.env.img_h) / t));
    if (image) {
	image24 = &((unsigned char *)res_buf)[sizeof(common_work_t)];
	util_image_save_ppm("dump.ppm", image24, db.env.img_w, db.env.img_h);
    }

    close(client_socket);

    util_camera_free(&camera);
    free(app_data);
    free(bench_frame);
    common_unpack_free(&db);

    if (cache) {
	void *kdcache;
	unsigned int size;
	FILE *fh;

	tie_kdtree_cache_free(&tie, &kdcache);
	memcpy(&size, kdcache, sizeof(unsigned int));
	printf("saving kd-tree cache: %d bytes\n", size);
	fh = fopen("kdtree.cache", "wb");
	fwrite(kdcache, size, 1, fh);
	fclose(fh);
	free(kdcache);
    }
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 15439
/*                      O B S E R V E R . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2007-2008 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file observer.c
 *
 */

#include "common.h"

#include "observer.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include "SDL.h"
#include "isst.h"
#include "image.h"
#include "display.h"
#include "umath.h"
#include "isst_struct.h"
#include "tienet.h"
#include "splash.h"
/* Networking Includes */
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#if ISST_USE_COMPRESSION
#  include <zlib.h>
#endif

#include "bio.h"

typedef struct isst_observer_net_info_s {
    struct hostent master;
    int port;
} isst_observer_net_info_t;


void isst_observer(char *host, int port);
void* isst_observer_networking(void *ptr);
void isst_observer_event_loop(void);


/***** GLOBALS *****/
pthread_t isst_observer_networking_thread;
pthread_mutex_t isst_observer_magnify_mut;
pthread_mutex_t event_mut;

tienet_sem_t isst_observer_sdlinit_sem;
tienet_sem_t isst_observer_sdlready_sem;
tienet_sem_t isst_observer_splash_sem;
pthread_mutex_t isst_observer_console_mut;

int screen_w;
int screen_h;

short isst_observer_endian;
uint8_t isst_observer_event_queue_size;
isst_event_t isst_observer_event_queue[64];
int isst_observer_event_loop_alive;
int isst_observer_display_init;
int isst_observer_master_socket;
unsigned int isst_observer_mouse_grab;
unsigned int isst_observer_magnify;

void *magnify_buffer;
/*******************/


void isst_observer(char *host, int port) {
    isst_observer_net_info_t ni;

    /* server address */
    if (gethostbyname(host)) {
	ni.master = gethostbyname(host)[0];
    } else {
	fprintf(stderr, "hostname %s unknown, exiting.\n", host);
	exit(1);
    }
    ni.port = port;

    isst_observer_event_queue_size = 0;
    isst_observer_event_loop_alive = 1;

    pthread_mutex_init(&event_mut, 0);
    pthread_mutex_init(&isst_observer_magnify_mut, 0);
    isst_observer_magnify = 1;

    tienet_sem_init(&isst_observer_sdlinit_sem, 0);
    tienet_sem_init(&isst_observer_sdlready_sem, 0);
    tienet_sem_init(&isst_observer_splash_sem, 0);
    pthread_mutex_init(&isst_observer_console_mut, 0);
    isst_observer_display_init = 1;

    /* Launch a thread to handle events */
    pthread_create(&isst_observer_networking_thread, NULL, isst_observer_networking, &ni);

    /* Process events */
    tienet_sem_wait(&isst_observer_sdlinit_sem);
    isst_observer_event_loop();

    /* JOIN EVENT HANDLING THREAD */
    pthread_join(isst_observer_networking_thread, NULL);
}


void* isst_observer_networking(void *ptr) {
    isst_observer_net_info_t *ni;
    struct timeval start, cur;
    struct sockaddr_in my_addr, srv_addr;
    unsigned int addrlen;
    unsigned char op;
    tfloat fps;
    int frame_num;
    void *frame;
#if ISST_USE_COMPRESSION
    void *comp_buf;
#endif

    ni = (isst_observer_net_info_t *)ptr;

    /* create a socket */
    if ((isst_observer_master_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
	perror("Socket creation error");
	exit(1);
    }

    /* client address */
    my_addr.sin_family = AF_INET;
    my_addr.sin_addr.s_addr = INADDR_ANY;
    my_addr.sin_port = htons(0);

    srv_addr.sin_family = ni->master.h_addrtype;
    memcpy((char*)&srv_addr.sin_addr.s_addr, ni->master.h_addr_list[0], ni->master.h_length);
    srv_addr.sin_port = htons(ni->port);

    if (bind(isst_observer_master_socket, (struct sockaddr *)&my_addr, sizeof(my_addr)) < 0) {
	fprintf(stderr, "unable to bind socket, exiting.\n");
	exit(1);
    }

    /* connect to master */
    if (connect(isst_observer_master_socket, (struct sockaddr *)&srv_addr, sizeof(srv_addr)) < 0) {
	fprintf(stderr, "cannot connect to master, exiting.\n");
	exit(1);
    }

    addrlen = sizeof(srv_addr);

    /* send version and get endian info */
    op = ISST_NET_OP_INIT;
    tienet_send(isst_observer_master_socket, &op, 1, isst_observer_endian);
    tienet_recv(isst_observer_master_socket, &isst_observer_endian, sizeof(short));
    isst_observer_endian = isst_observer_endian == 1 ? 0 : 1;
    tienet_recv(isst_observer_master_socket, &screen_w, sizeof(int), isst_observer_endian);
    tienet_recv(isst_observer_master_socket, &screen_h, sizeof(int), isst_observer_endian);

    /* Screen size is known.  Initialize SDL and continue once it's ready */
    tienet_sem_post(&isst_observer_sdlinit_sem);

    /* Allocate memory for frame buffer */
    magnify_buffer = malloc(screen_w*screen_h*3);
    if (!magnify_buffer) {
	perror("magnify_buffer");
	exit(1);
    }
    frame = malloc(screen_w*screen_h*3);
    if (!frame) {
	perror("frame");
	exit(1);
    }
#if ISST_USE_COMPRESSION
    comp_buf = malloc(screen_w*screen_h*3);
    if (!comp_buf) {
	perror("comp_buf");
	exit(1);
    }
#endif


    gettimeofday(&start, NULL);
    frame_num = 0;


    while (1) {
	/* Send request for next frame */
	op = ISST_NET_OP_FRAME;
	tienet_send(isst_observer_master_socket, &op, 1, isst_observer_endian);

	/* Check whether to quit here or not */
	tienet_recv(isst_observer_master_socket, &op, 1, isst_observer_endian);

	if (op == ISST_NET_OP_QUIT) {
	    free(frame);
#if isst_USE_COMPRESSION
	    free(comp_buf);
#endif
	    util_display_free();
	    close(isst_observer_master_socket);

	    isst_observer_event_loop_alive = 0;
	    printf("Observer detatched from master.\n");
	    return(NULL);
	}

	/* Send Event Queue to Master */
	pthread_mutex_lock(&event_mut);

	tienet_send(isst_observer_master_socket, &isst_observer_event_queue_size, sizeof(uint8_t));
	if (isst_observer_event_queue_size)
	    tienet_send(isst_observer_master_socket, isst_observer_event_queue, isst_observer_event_queue_size * sizeof(isst_event_t));
	isst_observer_event_queue_size = 0;

	pthread_mutex_unlock(&event_mut);

	/* get frame data */
	pthread_mutex_lock(&isst_observer_magnify_mut);

#if ISST_USE_COMPRESSION
	{
	    unsigned long dest_len;
	    unsigned int comp_size;

	    tienet_recv(isst_observer_master_socket, &comp_size, sizeof(unsigned int));
	    tienet_recv(isst_observer_master_socket, comp_buf, comp_size);

	    dest_len = screen_w*screen_h*3;
	    uncompress(frame, &dest_len, comp_buf, (unsigned long)comp_size);
	}
#else
	tienet_recv(isst_observer_master_socket, frame, 3*screen_w*screen_h);
#endif

	if (isst_observer_display_init) {
	    isst_observer_display_init = 0;
	    tienet_sem_post(&isst_observer_splash_sem);
	    tienet_sem_wait(&isst_observer_sdlready_sem);
	}


	/* Magnify the image if magnify > 1 */
	{
	    unsigned int x, y;
	    unsigned char pixel[6];

	    if (isst_observer_magnify == 1) {
		memcpy(util_display_buffer->pixels, frame, 3*screen_w*screen_h);
	    } else if (isst_observer_magnify == 2) {
		for (y = 0; y < screen_h; y++) {
		    for (x = 0; x < screen_w; x++) {
			memcpy(pixel, &((char *)frame)[3*(y*screen_w+x)], 3);
			pixel[3] = pixel[0];
			pixel[4] = pixel[1];
			pixel[5] = pixel[2];
			memcpy(&((char *)util_display_buffer->pixels)[3*(4*y*screen_w+2*x)], pixel, 6);
			memcpy(&((char *)util_display_buffer->pixels)[3*(2*screen_w*(2*y+1)+2*x)], pixel, 6);
		    }
		}
	    }
	}


	/* compute frames per second (fps) */
	frame_num++;
	if (!(frame_num % 7)) {
	    gettimeofday(&cur, NULL);
	    fps = (tfloat)(frame_num) / ((cur.tv_sec + (tfloat)cur.tv_usec/1000000.0) - (start.tv_sec + (tfloat)start.tv_usec/1000000.0)),
		start = cur;
	    frame_num = 0;
	    fflush(stdout);
	}

	/* Get the overlay data */
	{
	    isst_overlay_data_t overlay;
	    char string[ADRT_NAME_SIZE];

	    tienet_recv(isst_observer_master_socket, &overlay, sizeof(isst_overlay_data_t));

	    /* Wait for the console to unlock */
	    pthread_mutex_lock(&isst_observer_console_mut);

	    /* Draw Frame */
	    util_display_draw(NULL);

	    /* Overlay some useful text */
	    snprintf(string, ADRT_NAME_SIZE, "position: %.3f %.3f %.3f", overlay.camera_position.v[0], overlay.camera_position.v[1], overlay. camera_position.v[2]);
	    util_display_text(string, 0, 0, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);

	    snprintf(string, ADRT_NAME_SIZE, "camera_ae: %.3f %.3f", overlay.camera_azimuth, overlay.camera_elevation);
	    util_display_text(string, 0, 1, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);

	    snprintf(string, ADRT_NAME_SIZE, "in_hit: %.3f %.3f %.3f", overlay.in_hit.v[0], overlay.in_hit.v[1], overlay.in_hit.v[2], overlay.out_hit.v[0], overlay.out_hit.v[1], overlay.out_hit.v[2]);
	    util_display_text(string, 0, 2, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);

	    snprintf(string, ADRT_NAME_SIZE, "nodes: %d", overlay.compute_nodes);
	    util_display_text(string, 0, 0, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_BOTTOM);

	    snprintf(string, ADRT_NAME_SIZE, "fps: %.1f", fps);
	    util_display_text(string, 0, 1, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_BOTTOM);

	    snprintf(string, ADRT_NAME_SIZE, "units: meters");
	    util_display_text(string, 0, 0, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_TOP);

	    /* Multiply by 100 to put this number into a more weidly domain */
	    snprintf(string, ADRT_NAME_SIZE, "scale: %.3f", overlay.scale * 100.0);
	    util_display_text(string, 0, 1, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_TOP);

	    snprintf(string, ADRT_NAME_SIZE, "res: %s", overlay.resolution);
	    util_display_text(string, 0, 1, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_BOTTOM);

	    snprintf(string, ADRT_NAME_SIZE, "controller: %s", overlay.controller ? "yes" : "no");
	    util_display_text(string, 0, 0, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_BOTTOM);

	    util_display_cross();
	    util_display_flip();

	    pthread_mutex_unlock(&isst_observer_console_mut);
	}

	pthread_mutex_unlock(&isst_observer_magnify_mut);
    }

    return(NULL);
}


void isst_observer_process(char *content, char *response) {
    char op;

    op = ISST_NET_OP_MESG;
    tienet_send(isst_observer_master_socket, &op, 1);

    /* length of content */
    op = strlen(content);
    if (strlen(content)) {
	op += 1;
	tienet_send(isst_observer_master_socket, &op, 1);

	/* content */
	tienet_send(isst_observer_master_socket, content, op);

	/* get the response */
	tienet_recv(isst_observer_master_socket, &op, 1);
	tienet_recv(isst_observer_master_socket, response, op);
    }
}


void isst_observer_event_loop() {
    SDL_Event event;
    char **content_buffer, **console_buffer;
    int content_lines, console_lines, i;


    content_lines = 0;
    console_lines = 0;
    content_buffer = (char **)malloc(sizeof(char *) * 100);
    if (!content_buffer) {
	perror("content_buffer");
	exit(1);
    }
    console_buffer = (char **)malloc(sizeof(char *) * 100);
    if (!console_buffer) {
	perror("console_buffer");
	exit(1);
    }
    for (i = 0; i < 100; i++) {
	content_buffer[i] = (char *)malloc(80);
	if (!content_buffer[i]) {
	    perror("content_buffer[i]");
	    exit(1);
	}
	console_buffer[i] = (char *)malloc(80);
	if (!console_buffer[i]) {
	    perror("console_buffer[i]");
	    exit(1);
	}
    }
    content_buffer[0][0] = 0;
    console_buffer[0][0] = 0;


    /* Display Loading Splash Screen */
    util_display_init(isst_logo.width, isst_logo.height);

    SDL_WM_SetCaption("ADRT_ISST_Observer Loading...", NULL);
    memcpy(util_display_buffer->pixels, isst_logo.pixel_data, 3 * isst_logo.width * isst_logo.height);
    util_display_draw(NULL);
    util_display_flip();

    tienet_sem_wait(&isst_observer_splash_sem);
    util_display_free();

    /* Initialize the display with the size of the render context */
    util_display_init(screen_w, screen_h);

    SDL_WM_SetCaption("ADRT_ISST_Observer", NULL);
    tienet_sem_post(&isst_observer_sdlready_sem);

    while (SDL_WaitEvent(&event) >= 0 && isst_observer_event_loop_alive) {
	switch (event.type) {
	    case SDL_KEYDOWN:
		switch (event.key.keysym.sym) {
		    case SDLK_F1: /* screen magnify 1x */
			/* Set magnification level */
			pthread_mutex_lock(&isst_observer_magnify_mut);
			isst_observer_magnify = 1;

			/* Free the existing context */
			util_display_free();

			/* Initialize the new context */
			util_display_init(screen_w, screen_h);

			magnify_buffer = realloc(magnify_buffer, screen_w*screen_h*3);
			pthread_mutex_unlock(&isst_observer_magnify_mut);
			break;

		    case SDLK_F2: /* screen magnify 2x */
			/* Set magnification level */
			pthread_mutex_lock(&isst_observer_magnify_mut);
			isst_observer_magnify = 2;

			/* Free the existing context */
			util_display_free();

			/* Initialize the new context */
			util_display_init(2*screen_w, 2*screen_h);

			magnify_buffer = realloc(magnify_buffer, 4*screen_w*screen_h*3);
			pthread_mutex_unlock(&isst_observer_magnify_mut);
			break;

		    case SDLK_f: /* fullscreen mode */
			SDL_WM_ToggleFullScreen(util_display_screen);
			break;

		    case SDLK_g: /* mouse grabbing */
			isst_observer_mouse_grab ^= 1;
			SDL_WM_GrabInput(isst_observer_mouse_grab ? SDL_GRAB_ON : SDL_GRAB_OFF);
			SDL_ShowCursor(!isst_observer_mouse_grab);
			break;

		    case SDLK_PRINT:
		    {
			void *image24;

			/* Screen dump */
			image24 = malloc(3 * screen_w * screen_h);
			if (!image24) {
			    perror("image24");
			    exit(1);
			}
			util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 0);
			util_image_save_ppm("screenshot.ppm", image24, screen_w, screen_h);
			free(image24);
		    }
		    break;

		    case SDLK_BACKQUOTE:
			/* Bring up the console */
			pthread_mutex_lock(&isst_observer_console_mut);
			util_display_editor(content_buffer, &content_lines, console_buffer, &console_lines, isst_observer_process);
			pthread_mutex_unlock(&isst_observer_console_mut);
			break;

		    default:
			break;
		}
		break;

	    default:
		break;
	}

	pthread_mutex_lock(&event_mut);
	/* Build up an event queue to send prior to receiving each frame */
	if (isst_observer_event_queue_size < 64) {
	    isst_observer_event_queue[isst_observer_event_queue_size].type = event.type;
	    isst_observer_event_queue[isst_observer_event_queue_size].keysym = event.key.keysym.sym;
	    isst_observer_event_queue[isst_observer_event_queue_size].button = event.button.button;
	    isst_observer_event_queue[isst_observer_event_queue_size].motion_state = event.motion.state;
	    isst_observer_event_queue[isst_observer_event_queue_size].motion_xrel = event.motion.xrel;
	    isst_observer_event_queue[isst_observer_event_queue_size].motion_yrel = event.motion.yrel;
	    isst_observer_event_queue_size++;
	}
	pthread_mutex_unlock(&event_mut);
    }


    for (i = 0; i < 100; i++) {
	free(content_buffer[i]);
	free(console_buffer[i]);
    }
    free(content_buffer);
    free(console_buffer);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 20560
/*                     U N P A C K . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2002-2008 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file unpack.c
 *
 *  Common Library - Parsing and Packing Header
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "unpack.h"
#include "tienet.h"
#include "umath.h"

int prop_num;
common_unpack_prop_node_t *prop_list;

int texture_num;
common_unpack_texture_node_t *texture_list;

common_prop_t common_unpack_def_prop;

void	common_unpack(common_db_t *db, tie_t *tie, util_camera_t *camera, int socknum);
void	common_unpack_free(common_db_t *db);
void	common_unpack_camera(util_camera_t *camera, int socknum);
void	common_unpack_env(common_db_t *db, int socknum);
void	common_unpack_prop(int socknum);
void	common_unpack_texture(int socknum);
void	common_unpack_mesh(common_db_t *db, int socknum, tie_t *tie);
void	common_unpack_kdtree_cache(int socknum, tie_t *tie);
void	common_unpack_mesh_map(common_db_t *db, int socknum);
void	common_unpack_mesh_link(const char* mesh_name, const char* prop_name, common_db_t* db);
void	common_unpack_prop_lookup(const char* name, common_prop_t** prop);
void	common_unpack_texture_lookup(const char* name, texture_t** texture);


void common_unpack(common_db_t *db, tie_t *tie, util_camera_t *camera, int socknum) {
    int size;
    short ver, block;

    prop_num = 0;
    prop_list = NULL;
    texture_num = 0;
    texture_list = NULL;
    db->mesh_num = 0;
    db->mesh_list = NULL;

    /* Set default prop values */
    common_unpack_def_prop.color.v[0] = 0.8;
    common_unpack_def_prop.color.v[1] = 0.8;
    common_unpack_def_prop.color.v[2] = 0.8;
    common_unpack_def_prop.gloss = 0.2;
    common_unpack_def_prop.density = 0.5;
    common_unpack_def_prop.emission = 0.0;
    common_unpack_def_prop.ior = 1.0;

    /* Read in the size of the application data */
    tienet_recv(socknum, &size, sizeof(int));

    /* Version */
    tienet_recv(socknum, &ver, sizeof(short), tienet_endian);

    /* Unpack Data */
    common_unpack_env(db, socknum);
    common_unpack_camera(camera, socknum);
    common_unpack_prop(socknum);
    common_unpack_texture(socknum);
    common_unpack_mesh(db, socknum, tie);
    common_unpack_kdtree_cache(socknum, tie);
    common_unpack_mesh_map(db, socknum);
}


void common_unpack_free(common_db_t *db) {
    int i;

    /* Free texture data */
    for (i = 0; i < texture_num; i++)
	texture_list[i].texture->free(texture_list[i].texture);
    free(texture_list);

    if (!db)
	return;

    /* Free mesh data */
    for (i = 0; i < db->mesh_num; i++) {
	/* Free triangle data */
	free(db->mesh_list[i]->tri_list);
	free(db->mesh_list[i]);
    }
    free(db->mesh_list);
}


void common_unpack_env(common_db_t *db, int socknum) {
    int ind, size;
    short block;

    /* size of environment data */
    tienet_recv(socknum, &size, sizeof(int));

    ind = 0;
    do {
	tienet_recv(socknum, &block, sizeof(short), tienet_endian);
	ind += sizeof(short);
	switch (block) {
	    case COMMON_PACK_ENV_RM:
	    {
		tienet_recv(socknum, &db->env.rm, sizeof(int), tienet_endian);
		ind += sizeof(int);
		switch (db->env.rm) {
		    case RENDER_METHOD_FLAT:
			render_flat_init(&db->env.render);
			break;

		    case RENDER_METHOD_NORMAL:
			render_normal_init(&db->env.render);
			break;

		    case RENDER_METHOD_PHONG:
			render_phong_init(&db->env.render);
			break;

		    case RENDER_METHOD_DEPTH:
			render_depth_init(&db->env.render);
			break;

		    case RENDER_METHOD_PATH:
		    {
			int samples;

			tienet_recv(socknum, &samples, sizeof(int), tienet_endian);
			ind += sizeof(int);
			render_path_init(&db->env.render, samples);
		    }
		    break;

		    case RENDER_METHOD_PLANE:
		    {
			TIE_3 ray_pos, ray_dir;

			tienet_recv(socknum, &ray_pos.v[0], sizeof(tfloat), tienet_endian);
			tienet_recv(socknum, &ray_pos.v[1], sizeof(tfloat), tienet_endian);
			tienet_recv(socknum, &ray_pos.v[2], sizeof(tfloat), tienet_endian);

			tienet_recv(socknum, &ray_dir.v[0], sizeof(tfloat), tienet_endian);
			tienet_recv(socknum, &ray_dir.v[1], sizeof(tfloat), tienet_endian);
			tienet_recv(socknum, &ray_dir.v[2], sizeof(tfloat), tienet_endian);

			ind += 6 * sizeof(tfloat);
			render_cut_init(&db->env.render, ray_pos, ray_dir);
		    }
		    break;

		    default:
			break;
		}
	    }
	    break;

	    case COMMON_PACK_ENV_IMAGESIZE:
	    {
		tienet_recv(socknum, &db->env.img_w, sizeof(int), tienet_endian);
		tienet_recv(socknum, &db->env.img_h, sizeof(int), tienet_endian);
		tienet_recv(socknum, &db->env.img_hs, sizeof(int), tienet_endian);
		ind += 3 * sizeof(int);
	    }
	    break;

	    default:
		break;
	}
    } while (ind < size);
}


void common_unpack_camera(util_camera_t *camera, int socknum) {
    int size;

    /* size of camera data */
    tienet_recv(socknum, &size, sizeof(int));

    /* POSITION */
    tienet_recv(socknum, &camera->pos.v[0], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &camera->pos.v[1], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &camera->pos.v[2], sizeof(tfloat), tienet_endian);

    /* FOCUS */
    tienet_recv(socknum, &camera->focus.v[0], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &camera->focus.v[1], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &camera->focus.v[2], sizeof(tfloat), tienet_endian);

    /* TILT */
    tienet_recv(socknum, &camera->tilt, sizeof(tfloat), tienet_endian);

    /* FIELD OF VIEW */
    tienet_recv(socknum, &camera->fov, sizeof(tfloat), tienet_endian);

    /* DEPTH OF FIELD */
    tienet_recv(socknum, &camera->dof, sizeof(tfloat), tienet_endian);
}


void common_unpack_prop(int socknum) {
    int ind, size;
    char c;

    /* size of property data */
    tienet_recv(socknum, &size, sizeof(int));

    ind = 0;
    while (ind < size) {
	prop_num++;
	prop_list = (common_unpack_prop_node_t*)realloc(prop_list, sizeof(common_unpack_prop_node_t)*prop_num);

	/* property name */
	tienet_recv(socknum, &c, sizeof(char));
	tienet_recv(socknum, prop_list[prop_num-1].name, c);
	ind += c + 1;

	/* property data */
	tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[0], sizeof(tfloat), tienet_endian);
	tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[1], sizeof(tfloat), tienet_endian);
	tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[2], sizeof(tfloat), tienet_endian);
	tienet_recv(socknum, &prop_list[prop_num-1].prop.density, sizeof(tfloat), tienet_endian);
	tienet_recv(socknum, &prop_list[prop_num-1].prop.gloss, sizeof(tfloat), tienet_endian);
	tienet_recv(socknum, &prop_list[prop_num-1].prop.emission, sizeof(tfloat), tienet_endian);
	tienet_recv(socknum, &prop_list[prop_num-1].prop.ior, sizeof(tfloat), tienet_endian);
	ind += 7 * sizeof(tfloat);
    }
}


void common_unpack_texture(int socknum) {
    texture_t *stack = NULL, *texture = NULL;
    int ind, size;
    short block;
    unsigned char c;

    /* size of texture data */
    tienet_recv(socknum, &size, sizeof(int));


    ind = 0;
    while (ind < size) {
	tienet_recv(socknum, &block, sizeof(short), tienet_endian);
	ind += sizeof(short);

	switch (block) {
	    case TEXTURE_STACK:
		texture_num++;
		texture_list = (common_unpack_texture_node_t *)realloc(texture_list, sizeof(common_unpack_texture_node_t)*texture_num);

		texture_list[texture_num-1].texture = stack = (texture_t *)malloc(sizeof(texture_t));
		if (!texture_list[texture_num-1].texture) {
		    perror("texture_list[texture_num-1].texture");
		    exit(1);
		}
		texture_stack_init(stack);

		tienet_recv(socknum, &c, sizeof(char));
		tienet_recv(socknum, texture_list[texture_num-1].name, c);
		ind += c + 1;
		break;

	    case TEXTURE_MIX:
	    {
		texture_t *texture1, *texture2;
		char s1[64], s2[64];
		tfloat coef;

		texture_num++;
		texture_list = (common_unpack_texture_node_t*)realloc(texture_list, sizeof(common_unpack_texture_node_t)*texture_num);
		texture_list[texture_num-1].texture = (texture_t*)malloc(sizeof(texture_t));
		if (!texture_list[texture_num-1].texture) {
		    perror("texture_list[texture_num-1].texture");
		    exit(1);
		}
		tienet_recv(socknum, &c, sizeof(char));
		tienet_recv(socknum, texture_list[texture_num-1].name, c);
		ind += c + c+1;
		tienet_recv(socknum, &c, sizeof(char));
		tienet_recv(socknum, s1, c);
		ind += c + c+1;
		tienet_recv(socknum, &c, sizeof(char));
		tienet_recv(socknum, s2, c);
		ind += c + c+1;
		tienet_recv(socknum, &coef, sizeof(tfloat), tienet_endian);
		ind += sizeof(tfloat);
		common_unpack_texture_lookup(s1, &texture1);
		common_unpack_texture_lookup(s2, &texture2);
		texture_mix_init(texture_list[texture_num-1].texture, texture1, texture2, coef);
	    }
	    break;

	    case TEXTURE_BLEND:
	    {
		TIE_3 color1, color2;

		texture = (texture_t*)malloc(sizeof(texture_t));
		if (!texture) {
		    perror("texture");
		    exit(1);
		}
		/* COLOR 1 */
		tienet_recv(socknum, &color1.v[0], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &color1.v[1], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &color1.v[2], sizeof(tfloat), tienet_endian);
		ind += 3 * sizeof(tfloat);
		/* COLOR 2 */
		tienet_recv(socknum, &color2.v[0], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &color2.v[1], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &color2.v[2], sizeof(tfloat), tienet_endian);
		ind += 3 * sizeof(tfloat);
		texture_blend_init(texture, color1, color2);
		texture_stack_push(stack, texture);
	    }
	    break;

	    case TEXTURE_BUMP:
	    {
		TIE_3 coef;

		texture = (texture_t*)malloc(sizeof(texture_t));
		if (!texture) {
		    perror("texture");
		    exit(1);
		}
		tienet_recv(socknum, &coef.v[0], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &coef.v[1], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &coef.v[2], sizeof(tfloat), tienet_endian);
		ind += 3 * sizeof(tfloat);
		texture_bump_init(texture, coef);
		texture_stack_push(stack, texture);
	    }
	    break;

	    case TEXTURE_CHECKER:
	    {
		int tile;

		texture = (texture_t*)malloc(sizeof(texture_t));
		if (!texture) {
		    perror("texture");
		    exit(1);
		}
		tienet_recv(socknum, &tile, sizeof(int), tienet_endian);
		ind += sizeof(int);
		texture_checker_init(texture, tile);
		texture_stack_push(stack, texture);
	    }
	    break;

	    case TEXTURE_CAMO:
	    {
		tfloat size;
		int octaves, absolute;
		TIE_3 color1, color2, color3;

		texture = (texture_t*)malloc(sizeof(texture_t));
		if (!texture) {
		    perror("texture");
		    exit(1);
		}
		tienet_recv(socknum, &size, sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &octaves, sizeof(int), tienet_endian);
		tienet_recv(socknum, &absolute, sizeof(int), tienet_endian);
		tienet_recv(socknum, &color1.v[0], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &color1.v[1], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &color1.v[2], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &color2.v[0], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &color2.v[1], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &color2.v[2], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &color3.v[0], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &color3.v[1], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &color3.v[2], sizeof(tfloat), tienet_endian);
		ind += 10*sizeof(tfloat) + 2*sizeof(int);
		texture_camo_init(texture, size, octaves, absolute, color1, color2, color3);
		texture_stack_push(stack, texture);
	    }
	    break;

	    case TEXTURE_CLOUDS:
	    {
		tfloat size;
		int octaves, absolute;
		TIE_3 scale, translate;

		texture = (texture_t*)malloc(sizeof(texture_t));
		if (!texture) {
		    perror("texture");
		    exit(1);
		}
		tienet_recv(socknum, &size, sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &octaves, sizeof(int), tienet_endian);
		tienet_recv(socknum, &absolute, sizeof(int), tienet_endian);
		tienet_recv(socknum, &scale.v[0], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &scale.v[1], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &scale.v[2], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &translate.v[0], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &translate.v[1], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &translate.v[2], sizeof(tfloat), tienet_endian);
		ind += 7*sizeof(tfloat) + 2*sizeof(int);
		texture_clouds_init(texture, size, octaves, absolute, scale, translate);
		texture_stack_push(stack, texture);
	    }
	    break;

	    case TEXTURE_IMAGE:
	    {
		short w, h;
		unsigned char *image;

		texture = (texture_t*)malloc(sizeof(texture_t));
		if (!texture) {
		    perror("texture");
		    exit(1);
		}
		tienet_recv(socknum, &w, sizeof(short), tienet_endian);
		tienet_recv(socknum, &h, sizeof(short), tienet_endian);
		ind += 2*sizeof(short);
		image = (unsigned char*)malloc(3*w*h);
		if (!image) {
		    perror("image");
		    exit(1);
		}
		tienet_recv(socknum, image, 3*w*h);
		ind += 3*w*h;
		texture_image_init(texture, w, h, image);
		texture_stack_push(stack, texture);
		free(image);
	    }
	    break;

	    case TEXTURE_GRADIENT:
	    {
		int axis;

		texture = (texture_t*)malloc(sizeof(texture_t));
		if (!texture) {
		    perror("texture");
		    exit(1);
		}
		tienet_recv(socknum, &axis, sizeof(int), tienet_endian);
		ind += sizeof(int);
		texture_gradient_init(texture, axis);
		texture_stack_push(stack, texture);
	    }
	    break;

	    default:
		break;
	}
    }
}


void common_unpack_mesh(common_db_t *db, int socknum, tie_t *tie) {
    TIE_3 v[3], *vlist, *tlist;
    char name[256];
    unsigned char c;
    short block;
    unsigned int num, ind;
    int size, *flist, i, start, vnum, vmax, fnum, fmax;


    vlist = NULL;
    flist = NULL;
    tlist = NULL;
    vmax = 0;
    fmax = 0;

    /* size of mesh data */
    tienet_recv(socknum, &size, sizeof(int));
    ind = 0;

    /* initialize tie with triangle number */
    tienet_recv(socknum, &num, sizeof(unsigned int), tienet_endian);
    tie_init(tie, num, TIE_KDTREE_FAST);
    ind += sizeof(unsigned int);

    while (ind < size) {
	/* Create a Mesh */
	db->mesh_num++;
	db->mesh_list = (common_mesh_t **)realloc(db->mesh_list, sizeof(common_mesh_t *)*db->mesh_num);
	db->mesh_list[db->mesh_num-1] = (common_mesh_t *)malloc(sizeof(common_mesh_t));
	if (!db->mesh_list[db->mesh_num-1]) {
	    perror("db->mesh_list[db->mesh_num-1]");
	    exit(1);
	}
	db->mesh_list[db->mesh_num-1]->flags = 0;
	db->mesh_list[db->mesh_num-1]->tri_num = 0;
	db->mesh_list[db->mesh_num-1]->tri_list = NULL;

	/* Mesh Name */
	tienet_recv(socknum, &c, sizeof(char));
	tienet_recv(socknum, db->mesh_list[db->mesh_num-1]->name, c);
	ind += c + 1;

	/* Vertices */
	tienet_recv(socknum, &vnum, sizeof(int), tienet_endian);
	ind += sizeof(int);
	if (vnum > vmax) {
	    vmax = vnum;
	    vlist = (TIE_3 *)realloc(vlist, vmax * sizeof(TIE_3));
	}
	tienet_recv(socknum, vlist, vnum * sizeof(TIE_3));
	ind += vnum * sizeof(TIE_3);

	/* Faces */
	/* Determine short or int based indices */
	tienet_recv(socknum, &c, 1);
	ind += 1;

	if (c) {
	    tienet_recv(socknum, &fnum, sizeof(int), tienet_endian);
	    ind += sizeof(int);

	    if (fnum > fmax) {
		fmax = fnum;
		flist = (int *)realloc(flist, fmax * 3 * sizeof(int));
		tlist = (TIE_3 *)realloc(tlist, fmax * 3 * sizeof(TIE_3));
	    }
	    tienet_recv(socknum, flist, fnum * 3 * sizeof(int));
	    ind += fnum * 3 * sizeof(int);
	} else {
	    unsigned short sfnum, sind[144];
	    int j, n;

	    tienet_recv(socknum, &sfnum, sizeof(unsigned short), tienet_endian);
	    ind += sizeof(unsigned short);

	    fnum = sfnum;
	    if (fnum > fmax) {
		fmax = fnum;
		flist = (int *)realloc(flist, fmax * 3 * sizeof(int));
		tlist = (TIE_3 *)realloc(tlist, fmax * 3 * sizeof(TIE_3));
	    }

	    i = 0;
	    while (i < fnum) {
		n = fnum - i > 48 ? 48 : fnum - i;
		tienet_recv(socknum, &sind, 3 * n * sizeof(unsigned short));

		for (j = 0; j < n; j++) {
		    flist[3*(i+j) + 0] = sind[3*j + 0];
		    flist[3*(i+j) + 1] = sind[3*j + 1];
		    flist[3*(i+j) + 2] = sind[3*j + 2];
		}

		i += n;
	    }

	    ind += fnum * 3 * sizeof(unsigned short);
	}

	/* Min and Max */
#if 0
	for (j = 0; j < 3; j++)
	    tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->min.v[j]), sizeof(tfloat), tienet_endian);
	for (j = 0; j < 3; j++)
	    tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->max.v[j]), sizeof(tfloat), tienet_endian);
#endif

	/* Matrix */
	for (i = 0; i < 16; i++)
	    tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->matrix[i]), sizeof(tfloat), tienet_endian);
	ind += 16 * sizeof(tfloat);

	/* Store inverted matrix */
	math_mat_invert(db->mesh_list[db->mesh_num-1]->matinv, db->mesh_list[db->mesh_num-1]->matrix, 4);

	/* Apply Transformation Matrix to Vertices */
	for (i = 0; i < vnum; i++) {
	    v[0] = vlist[i];
	    MATH_VEC_TRANSFORM(vlist[i], v[0], db->mesh_list[db->mesh_num-1]->matrix);
	}

	/* Allocate memory for ADRT triangles */
	db->mesh_list[db->mesh_num-1]->tri_num = fnum;
	db->mesh_list[db->mesh_num-1]->tri_list = (common_triangle_t *)malloc(fnum * sizeof(common_triangle_t));
	if (!db->mesh_list[db->mesh_num-1]->tri_list) {
	    perror("db->mesh_list[db->mesh_num-1]->tri_list");
	    exit(1);
	}

	/* Build the triangle list */
	for (i = 0; i < fnum; i++) {
	    db->mesh_list[db->mesh_num-1]->tri_list[i].mesh = db->mesh_list[db->mesh_num-1];
	    db->mesh_list[db->mesh_num-1]->tri_list[i].normals = NULL;
	    tlist[i*3+0] = vlist[flist[3*i+0]];
	    tlist[i*3+1] = vlist[flist[3*i+1]];
	    tlist[i*3+2] = vlist[flist[3*i+2]];
	}

	/* ADD TRIANGLES TO TIE */
	tie_push(tie, &tlist, fnum, db->mesh_list[db->mesh_num-1]->tri_list, sizeof(common_triangle_t));
    }

    free(vlist);
    free(flist);
    free(tlist);
}


void common_unpack_kdtree_cache(int socknum, tie_t *tie) {
    int size;
    void *kdcache;

    /* size of kdtree cache data */
    tienet_recv(socknum, &size, sizeof(int));

    /* retreive the data */
    if (size > 0) {
	kdcache = malloc(size);
	if (!kdcache) {
	    perror("kdcache");
	    exit(1);
	}
	tienet_recv(socknum, kdcache, size);

	/* feed the kd-tree into libtie */
	tie_kdtree_cache_load(tie, kdcache, size);

	free(kdcache);
    }
}


void common_unpack_mesh_map(common_db_t *db, int socknum) {
    unsigned int size, ind;
    unsigned char c;
    char mesh_name[256], prop_name[256];

    /* size of mesh data */
    tienet_recv(socknum, &size, sizeof(unsigned int));
    ind = 0;

    while (ind < size) {
	tienet_recv(socknum, &c, 1);
	tienet_recv(socknum, mesh_name, c);
	ind += 1 + c;

	tienet_recv(socknum, &c, 1);
	tienet_recv(socknum, prop_name, c);
	ind += 1 + c;

	/* Link a property and texture to a mesh */
	common_unpack_mesh_link(mesh_name, prop_name, db);
    }
}


void common_unpack_mesh_link(const char* mesh_name, const char* prop_name, common_db_t* db) {
    unsigned int i;


    for (i = 0; i < db->mesh_num; i++) {
	/* Find Mesh */
	if (!strcmp(mesh_name, db->mesh_list[i]->name)) {
	    common_unpack_prop_lookup(prop_name, &(db->mesh_list[i]->prop));
	    db->mesh_list[i]->texture = NULL;
	    return;
	}
    }
}


void common_unpack_prop_lookup(const char* name, common_prop_t** prop) {
    unsigned int i;

    for (i = 0; i < prop_num; i++)
	if (!strcmp(name, prop_list[i].name)) {
/*       printf("*** FOUND FOR: -%s-\n", name); */
	    *prop = &prop_list[i].prop;
	    return;
	}

/*  printf("PROPERTIES NOT FOUND FOR: -%s-\n", name); */
    *prop = &common_unpack_def_prop;
}


void common_unpack_texture_lookup(const char* name, texture_t** texture) {
    unsigned int i;

    for (i = 0; i < texture_num; i++)
	if (!strcmp(name, texture_list[i].name)) {
	    *texture = texture_list[i].texture;
	    return;
	}

    *texture = NULL;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 26303
/*                 T I E N E T _ M A S T E R . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2002-2008 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file tienet_master.c
 *
 *  Comments -
 *      TIE Networking Master
 *
 */

#include "tienet_master.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include "bio.h"

#include "tie.h"
#include "tienet_define.h"
#include "tienet_util.h"

#include "bu.h"

#if TN_COMPRESSION
# include <zlib.h>
#endif


typedef struct tienet_master_data_s {
    void *data;
    int size;	/* Current size of work in bytes */
} tienet_master_data_t;


typedef struct tienet_master_socket_s {
    int active;	/* Once a slave has completed its first work unit this becomes 1 */
    int idle;	/* When a slave has finished a work unit and there's nothing left for it to work on */
    int num;
    tienet_master_data_t mesg;	/* Used for a broadcast message */
    tienet_master_data_t work;	/* The work unit currently being processed */
    struct tienet_master_socket_s *prev;
    struct tienet_master_socket_s *next;
} tienet_master_socket_t;


void				tienet_master_init(int port, void fcb_result(tienet_buffer_t *result), char *list, char *exec, int buffer_size, int ver_key, int verbose);
void				tienet_master_free(void);
void				tienet_master_push(const void *data, size_t size);
void				tienet_master_shutdown(void);
void				tienet_master_broadcast(const void *mesg, size_t mesg_len);

void				tienet_master_begin(void);
void				tienet_master_end(void);
void				tienet_master_wait(void);

void				tienet_master_connect_slaves(fd_set *readfds);
void*				tienet_master_listener(void *ptr);
void				tienet_master_send_work(tienet_master_socket_t *sock);
void				tienet_master_result(tienet_master_socket_t *sock);
void				tienet_master_shutdown(void);

static int			tienet_master_ver_key;
static int			tienet_master_port;
static int			tienet_master_highest_fd;

int				tienet_master_active_slaves;
int				tienet_master_socket_num;
static tienet_master_socket_t	*tienet_master_socket_list;
static tienet_master_socket_t	*tienet_master_dead_socket_list;

int				tienet_master_buffer_size;
static tienet_master_data_t	*tienet_master_buffer;		/* Buffer */
static int			tienet_master_pos_fill;
static int			tienet_master_pos_read;

static tienet_sem_t		tienet_master_sem_fill;	/* Fill Buffer Semaphore */
static tienet_sem_t		tienet_master_sem_read;	/* Read Buffer Semaphore */
static tienet_sem_t		tienet_master_sem_app;	/* Application Semaphore */
static tienet_sem_t		tienet_master_sem_out;	/* Outstanding Semaphore */
static tienet_sem_t		tienet_master_sem_shutdown; /* Shutdown Semaphore */

uint64_t			tienet_master_transfer;
static char			tienet_master_exec[64];	/* Something to run in order to jumpstart the slaves */
static char			tienet_master_list[64]; /* A list of slaves in daemon mode to connect to */
int				tienet_master_verbose;
int				tienet_master_endflag;
int				tienet_master_shutdown_state;
int				tienet_master_halt_networking;

tienet_buffer_t			tienet_master_result_buffer;
pthread_mutex_t			tienet_master_send_mut;
pthread_mutex_t			tienet_master_push_mut;
pthread_mutex_t			tienet_master_broadcast_mut;


#if TN_COMPRESSION
tienet_buffer_t			tienet_master_result_buffer_comp;
#endif

/* result data callback */
typedef void tienet_master_fcb_result_t(tienet_buffer_t *result);
tienet_master_fcb_result_t	*tienet_master_fcb_result;


void tienet_master_init(int port, void fcb_result(tienet_buffer_t *result), char *list, char *exec, int buffer_size, int ver_key, int verbose)
{
    pthread_t thread;
    int i;


    tienet_master_port = port;
    tienet_master_verbose = verbose;
    tienet_master_buffer_size = buffer_size;
    tienet_master_buffer = (tienet_master_data_t *)bu_malloc(sizeof(tienet_master_data_t) * tienet_master_buffer_size, "initial tienet buffer");

    tienet_master_fcb_result = fcb_result;
    tienet_master_active_slaves = 0;
    tienet_master_socket_num = 0;
    tienet_master_socket_list = NULL;
    tienet_master_dead_socket_list = NULL;

    tienet_master_transfer = 0;
    tienet_master_endflag = 0;
    tienet_master_shutdown_state = 0;
    tienet_master_halt_networking = 0;

    tienet_master_pos_fill = 0;
    tienet_master_pos_read = 0;

    TIENET_BUFFER_INIT(tienet_master_result_buffer);
#if TN_COMPRESSION
    TIENET_BUFFER_INIT(tienet_master_result_buffer_comp);
#endif

    strncpy(tienet_master_list, list, sizeof(tienet_master_list));
    strncpy(tienet_master_exec, exec, sizeof(tienet_master_exec));

    /* Copy version key to validate slaves of correct version are connecting */
    tienet_master_ver_key = ver_key;

    /* Force the first slave that connects to perform a Fill Buffer -> Read Buffer Move */
    tienet_sem_init(&tienet_master_sem_fill, 0);
    tienet_sem_init(&tienet_master_sem_read, 0);

    /* Allow the application to fill the buffer with tienet_master_buffer_size */
    for (i = 0; i < tienet_master_buffer_size; i++)
    {
	tienet_master_buffer[i].data = NULL;
	tienet_master_buffer[i].size = 0;
	tienet_sem_post(&tienet_master_sem_fill);
    }

    tienet_sem_init(&tienet_master_sem_app, 0);
    tienet_sem_init(&tienet_master_sem_out, 0);
    pthread_mutex_init(&tienet_master_send_mut, 0);
    pthread_mutex_init(&tienet_master_push_mut, 0);
    pthread_mutex_init(&tienet_master_broadcast_mut, 0);
  
    /* Start the Listener as a Thread */
    pthread_create(&thread, NULL, tienet_master_listener, NULL);
}


void tienet_master_free()
{
    int i;
    tienet_master_socket_t *sock;

    tienet_sem_free(&tienet_master_sem_fill);
    tienet_sem_free(&tienet_master_sem_read);
    tienet_sem_free(&tienet_master_sem_app);
    tienet_sem_free(&tienet_master_sem_out);

    TIENET_BUFFER_FREE(tienet_master_result_buffer);
#if TN_COMPRESSION
    TIENET_BUFFER_FREE(tienet_master_result_buffer_bomp);
#endif
    bu_free(tienet_master_buffer, "tienet master buffer");

    for (i = 0; i < tienet_master_buffer_size; i++)
	bu_free(tienet_master_buffer[i].data, "tienet master buffer data");

    for (sock = tienet_master_socket_list->next; sock; sock = sock->next)
	bu_free(sock->prev, "master socket");
}


void tienet_master_push(const void *data, size_t size)
{
    tienet_master_socket_t *socket, *tmp;
    short op;

    pthread_mutex_lock(&tienet_master_push_mut);

    op = TN_OP_SENDWORK;

    /* Decrement semaphore */
    tienet_sem_wait(&tienet_master_sem_fill);

    /* Fill buffer, Grow if necessary */
    if (sizeof(short) + sizeof(int) + size > tienet_master_buffer[tienet_master_pos_fill].size)
    {
	tienet_master_buffer[tienet_master_pos_fill].size = sizeof(short) + sizeof(int) + size;
	tienet_master_buffer[tienet_master_pos_fill].data = bu_realloc(tienet_master_buffer[tienet_master_pos_fill].data, tienet_master_buffer[tienet_master_pos_fill].size, "master buffer data");
    }
    TCOPY(short, &op, 0, tienet_master_buffer[tienet_master_pos_fill].data, 0);
    TCOPY(int, &size, 0, tienet_master_buffer[tienet_master_pos_fill].data, sizeof(short));
    memcpy(&((char *)(tienet_master_buffer[tienet_master_pos_fill].data))[sizeof(short) + sizeof(int)], data, size);

    /* Circular Increment */
    tienet_master_pos_fill = (tienet_master_pos_fill + 1) % tienet_master_buffer_size;
    tienet_sem_post(&tienet_master_sem_read);

    /* Process items in tienet_master_DeadSocketList */
    for (socket = tienet_master_dead_socket_list; socket;)
    {
	tienet_sem_wait(&tienet_master_sem_fill);
	TCOPY(int, &(socket->work.size), 0, &size, 0);

	/* Fill buffer, Grow if necessary */
	if (sizeof(short) + sizeof(int) + size > tienet_master_buffer[tienet_master_pos_fill].size)
	{
	    tienet_master_buffer[tienet_master_pos_fill].size = sizeof(short) + sizeof(int) + size;
	    tienet_master_buffer[tienet_master_pos_fill].data = bu_realloc(tienet_master_buffer[tienet_master_pos_fill].data, tienet_master_buffer[tienet_master_pos_fill].size, "master buffer data");
	}
	memcpy(tienet_master_buffer[tienet_master_pos_fill].data, socket->work.data, sizeof(short) + sizeof(int) + size);

	/* Circular Increment */
	tienet_master_pos_fill = (tienet_master_pos_fill + 1) % tienet_master_buffer_size;

	tmp = socket;
	if (socket == tienet_master_dead_socket_list)
	    tienet_master_dead_socket_list = tienet_master_dead_socket_list->next;
	socket = socket->next;

	bu_free(tmp->work.data, "work data");
	bu_free(tmp, "tmp socket");

	tienet_sem_post(&tienet_master_sem_read);
    }

  
    /*
     * Tell any idle slaves to get back to work.
     * This is the case where slaves have exhausted the work buffer,
     * then new work becomes available.
     */
    for (socket = tienet_master_socket_list; socket; socket = socket->next)
    {
	/* Only if not master socket do we send data to slave */
	if (socket->next && socket->idle)
	    tienet_master_send_work(socket);
    }

    pthread_mutex_unlock(&tienet_master_push_mut);
}


void tienet_master_begin()
{
    if (!tienet_master_sem_app.val)
	tienet_master_endflag = 0;
}


void tienet_master_end()
{
    tienet_master_endflag = 1;
}


void tienet_master_wait()
{
    tienet_sem_wait(&tienet_master_sem_app);
}


void tienet_master_connect_slaves(fd_set *readfds)
{
    FILE				*fh;
    struct	sockaddr_in	daemon, slave;
    struct	hostent		slave_ent;
    tienet_master_socket_t	*tmp;
    short				op;
    char				host[64], *temp;
    int				daemon_socket, port, slave_ver_key;


    fh = fopen(tienet_master_list, "rb");
    if (fh)
    {
	while (!feof(fh))
	{
	    bu_fgets(host, 64, fh);
	    if (host[0])
	    {
		port = TN_SLAVE_PORT;
		temp = strchr(host, ':');
		if (temp)
		{
		    port = atoi(&temp[1]);
		    temp[0] = 0;
		}
		else
		{
		    host[strlen(host)-1] = 0;
		}

		/* check to see if this slave is in dns */
		if (gethostbyname(host))
		{
		    slave_ent = gethostbyname(host)[0];

		    /* This is what we're connecting to */
		    slave.sin_family = slave_ent.h_addrtype;
		    memcpy((char *)&slave.sin_addr.s_addr, slave_ent.h_addr_list[0], slave_ent.h_length);
		    slave.sin_port = htons(port);

		    /* Make a communications socket that will get stuffed into the list */
		    daemon_socket = socket(AF_INET, SOCK_STREAM, 0);
		    if (daemon_socket < 0)
		    {
			fprintf(stderr, "unable to create  socket, exiting.\n");
			exit(1);
		    }

		    daemon.sin_family = AF_INET;
		    daemon.sin_addr.s_addr = htonl(INADDR_ANY);
		    daemon.sin_port = htons(0);

		    if (bind(daemon_socket, (struct sockaddr *)&daemon, sizeof(daemon)) < 0)
		    {
			fprintf(stderr, "unable to bind socket, exiting.\n");
			exit(1);
		    }

		    /* Make an attempt to connect to this host and initiate work */
		    if (connect(daemon_socket, (struct sockaddr *)&slave, sizeof(slave)) < 0)
		    {
			fprintf(stderr, "cannot connect to slave: %s:%d, skipping.\n", host, port);
		    }
		    else
		    {
			/* Send endian to slave */
			op = 1;
			tienet_send(daemon_socket, &op, sizeof(short));

			/* Read Version Key and Compare to ver_key, if valid proceed, if not tell slave to disconnect */
			tienet_recv(daemon_socket, &slave_ver_key, sizeof(int));
			if (slave_ver_key != tienet_master_ver_key)
			{
			    op = TN_OP_COMPLETE;
			    tienet_send(daemon_socket, &op, sizeof(short));
			}
			else
			{
			    op = TN_OP_OKAY;
			    tienet_send(daemon_socket, &op, sizeof(short));

			    /* Append to select list */
			    tmp = tienet_master_socket_list;
			    tienet_master_socket_list = (tienet_master_socket_t *)bu_malloc(sizeof(tienet_master_socket_t), "socket list");
			    tienet_master_socket_list->next = tmp;
			    tienet_master_socket_list->prev = NULL;
			    tienet_master_socket_list->work.data = NULL;
			    tienet_master_socket_list->work.size = 0;
			    tienet_master_socket_list->mesg.data = NULL;
			    tienet_master_socket_list->mesg.size = 0;
			    tienet_master_socket_list->num = daemon_socket;
			    tienet_master_socket_list->active = 0;
			    tienet_master_socket_list->idle = 1;

			    tmp->prev = tienet_master_socket_list;
			    tienet_master_socket_num++;
			    FD_SET(daemon_socket, readfds);

			    /* Check to see if it's the new highest */
			    if (daemon_socket > tienet_master_highest_fd)
				tienet_master_highest_fd = daemon_socket;
			}
		    }
		}
		else
		{
		    fprintf(stderr, "unknown host: %s, skipping.\n", host);
		}
	    }
	    host[0] = 0;
	}
	fclose(fh);
    }
}


void* tienet_master_listener(void *ptr)
{
    struct	sockaddr_in	master, slave;
    socklen_t			addrlen;
    fd_set			readfds;
    tienet_master_socket_t	*sock, *tmp;
    int				r, master_socket, slave_socket, slave_ver_key;
    short				op;


    if ((master_socket = socket(AF_INET, SOCK_STREAM, 0)) <= 0)
    {
	fprintf(stderr, "cannot creating socket, exiting.\n");
	exit(1);
    }

    addrlen = sizeof(struct sockaddr_in);
    master.sin_family = AF_INET;
    master.sin_addr.s_addr = INADDR_ANY;
    master.sin_port = htons(tienet_master_port);

    if (bind(master_socket, (struct sockaddr *)&master, addrlen))
    {
	fprintf(stderr, "socket already bound, exiting.\n");
	exit(1);
    }

    /* Set first socket as master, rest are slaves - LIFO Stack - Always gets processed last */
    tienet_master_socket_list = (tienet_master_socket_t *)bu_malloc(sizeof(tienet_master_socket_t), "socket list");
    tienet_master_socket_list->next = NULL;
    tienet_master_socket_list->prev = NULL;
    tienet_master_socket_list->work.data = NULL;
    tienet_master_socket_list->work.size = 0;
    tienet_master_socket_list->mesg.data = NULL;
    tienet_master_socket_list->mesg.size = 0;
    tienet_master_socket_list->num = master_socket;
    tienet_master_highest_fd = master_socket;

    /* Listen for connections */
    listen(master_socket, 3);

    addrlen = sizeof(slave);

    FD_ZERO(&readfds);
    FD_SET(master_socket, &readfds);

    /* Execute script - used for spawning slaves */
    system(tienet_master_exec);

    /* Process slave host list - used for connecting to running daemons */
    tienet_master_connect_slaves(&readfds);

    /* Handle Network Communications */
    while (1)
    {
	select(tienet_master_highest_fd+1, &readfds, NULL, NULL, NULL);

	/*
	 * Kill this thread if the shutdown call has been made and work
	 * units that were out have come back in.
	 */
	if (tienet_master_halt_networking)
	    return(NULL);


	/* Slave Communication */
	for (sock = tienet_master_socket_list; sock; sock = sock->next)
	{
	    if (FD_ISSET(sock->num, &readfds))
	    {
		if (sock->num == master_socket)
		{
		    /* New Connections, Always LAST in readfds list */
		    slave_socket = accept(master_socket, (struct sockaddr *)&slave, &addrlen);
		    if (slave_socket >= 0)
		    {
			if (tienet_master_verbose)
			    printf ("The slave %s has connected on port: %d, sock_num: %d\n", inet_ntoa(slave.sin_addr), tienet_master_port, slave_socket);
			tmp = tienet_master_socket_list;
			tienet_master_socket_list = (tienet_master_socket_t *)bu_malloc(sizeof(tienet_master_socket_t), "master socket list");
			tienet_master_socket_list->next = tmp;
			tienet_master_socket_list->prev = NULL;
			tienet_master_socket_list->work.data = NULL;
			tienet_master_socket_list->work.size = 0;
			tienet_master_socket_list->mesg.data = NULL;
			tienet_master_socket_list->mesg.size = 0;
			tienet_master_socket_list->num = slave_socket;
			tienet_master_socket_list->active = 0;
			tienet_master_socket_list->idle = 1;
			tmp->prev = tienet_master_socket_list;
			tienet_master_socket_num++;

			/* Send endian to slave */
			op = 1;
			tienet_send(slave_socket, &op, sizeof(short));
			/* Read Version Key and Compare to ver_key, if valid proceed, if not tell slave to disconnect */
			tienet_recv(slave_socket, &slave_ver_key, sizeof(int));
			if (slave_ver_key != tienet_master_ver_key)
			{
			    op = TN_OP_COMPLETE;
			    tienet_send(slave_socket, &op, sizeof(short));
			}
			else
			{
			    /* Version is okay, proceed */
			    op = TN_OP_OKAY;
			    tienet_send(slave_socket, &op, sizeof(short));

			    /* Append to select list */
			    if (slave_socket > tienet_master_highest_fd)
				tienet_master_highest_fd = slave_socket;
			}

			/* Send some work */
//            tienet_master_send_work(sock);
		    }
		}
		else
		{
		    /* Make sure socket is still active on this recv */
		    r = tienet_recv(sock->num, &op, sizeof(short));
		    /* if "r", error code returned, remove slave from pool */
		    if (r)
		    {
			tienet_master_socket_t		*tmp2;
			/* Because master socket is always last there is no need to check if "next" exists.
			 * Remove this socket from chain and link prev and next up to fill gap. */
			if (sock->prev)
			    sock->prev->next = sock->next;
			sock->next->prev = sock->prev;

			/* Store ptr to sock before we modify it */
			tmp = sock;
			/* If the socket is the head then we need to not only modify the socket,
			 * but the head as well. */
			if (tienet_master_socket_list == sock)
			    tienet_master_socket_list = sock->next;
			sock = sock->prev ? sock->prev : sock->next;

			/* Put the socket into the tienet_master_DeadSocketList */
			if (tienet_master_dead_socket_list)
			{
			    tmp2 = tienet_master_dead_socket_list;
			    tienet_master_dead_socket_list = tmp;
			    tienet_master_dead_socket_list->prev = NULL;
			    tienet_master_dead_socket_list->next = tmp2;
			    tmp2->prev = tienet_master_dead_socket_list;
			}
			else
			{
			    tienet_master_dead_socket_list = tmp;
			    tienet_master_dead_socket_list->next = NULL;
			    tienet_master_dead_socket_list->prev = NULL;
			}

			tienet_master_socket_num--;
		    }
		    else
		    {
			/*
			 * Slave Op Instructions
			 */
			switch (op)
			{
			    case TN_OP_REQWORK:
				tienet_master_send_work(sock);
				break;

			    case TN_OP_RESULT:
				tienet_master_result(sock);
				break;

			    default:
				break;
			}
		    }
		}
	    }
	}

	/* Rebuild select list for next select call */
	tienet_master_highest_fd = 0;
	for (sock = tienet_master_socket_list; sock; sock = sock->next)
	{
	    if (sock->num > tienet_master_highest_fd)
		tienet_master_highest_fd = sock->num;
	    FD_SET(sock->num, &readfds);
	}
    }
}


void tienet_master_send_work(tienet_master_socket_t *sock)
{
    int size;
    short op;

    /* 
     * This exists to prevent a collision from tienet_master_push calling this function
     * as a result of a socket being idle and then given work.  If this function were called
     * and 2 threads entered the if (tienet_master_sem_read.val) block and waited on tienet_master_sem_read
     * with the first one hitting the wait on a value of one the other one could end up waiting forever.
     */
    pthread_mutex_lock(&tienet_master_send_mut);

    /*
     * If shutdown has been initiated, do not send any data to the slaves,
     * instead they need to wait for a shutdown message.
     */
    if (tienet_master_shutdown_state)
    {
	/* if no work units are out, allow the shutdown to proceed. */
	if (!tienet_master_sem_out.val)
	    tienet_sem_post(&tienet_master_sem_shutdown);
	return;
    }


    /*
     * Check to see if a broadcast message is sitting in the queue.
     * The mutex prevents a read and write from occuring at the same time.
     */
    pthread_mutex_lock(&tienet_master_broadcast_mut);
    if (sock->mesg.size)
    {
	op = TN_OP_SENDWORK;
	tienet_send(sock->num, &op, sizeof(short));
	tienet_send(sock->num, &sock->mesg.size, sizeof(int));
	tienet_send(sock->num, sock->mesg.data, sock->mesg.size);

	bu_free(sock->mesg.data, "message data");
	sock->mesg.data = NULL;
	sock->mesg.size = 0;

	pthread_mutex_unlock(&tienet_master_broadcast_mut);
	pthread_mutex_unlock(&tienet_master_send_mut);
	return;
    }
    pthread_mutex_unlock(&tienet_master_broadcast_mut);


    /* Check to see if work is available */
    if (tienet_master_sem_read.val)
    {
	sock->idle = 0;
	tienet_sem_wait(&tienet_master_sem_read);

	/* Increment counter for work units out */
	tienet_sem_post(&tienet_master_sem_out);

	/* Send Work Unit */
	TCOPY(int, tienet_master_buffer[tienet_master_pos_read].data, sizeof(short), &size, 0);
	tienet_send(sock->num, tienet_master_buffer[tienet_master_pos_read].data, sizeof(short) + sizeof(int) + size);

	if (sizeof(short) + sizeof(int) + size > sock->work.size)
	{
	    sock->work.size = sizeof(short) + sizeof(int) + size;
	    sock->work.data = bu_realloc(sock->work.data, sock->work.size, "work data");
	}

	/* Make a copy of this data in the slave list */
	memcpy(sock->work.data, tienet_master_buffer[tienet_master_pos_read].data, sizeof(short) + sizeof(int) + size);

	/* Circular Increment */
	tienet_master_pos_read = (tienet_master_pos_read + 1) % tienet_master_buffer_size;

	/* Application is free to push another work unit into the buffer */
	tienet_sem_post(&tienet_master_sem_fill);

	tienet_master_transfer += size;
    }
    else
    {
	/* no work was available, socket is entering an active idle state. */
	sock->idle = 1;
    }

    pthread_mutex_unlock(&tienet_master_send_mut);
}


void tienet_master_result(tienet_master_socket_t *sock)
{
#if TN_COMPRESSION
    unsigned long	dest_len;
#endif

    /* A work unit has come in, this slave is officially active */
    if (!sock->active)
    {
	sock->active = 1;
	tienet_master_active_slaves++;
    }

    /* Decrement counter for work units out */
    tienet_sem_wait(&tienet_master_sem_out);

    /* receive result length */
    tienet_recv(sock->num, &tienet_master_result_buffer.ind, sizeof(unsigned int));
    tienet_master_transfer += sizeof(unsigned int);

    /* allocate memory for result buffer if more is needed */
    TIENET_BUFFER_SIZE(tienet_master_result_buffer, tienet_master_result_buffer.ind);
#if TN_COMPRESSION
    /* receive compressed length */
    tienet_recv(sock->num, &tienet_master_result_buffer_comp.ind, sizeof(unsigned int));

    TIENET_BUFFER_SIZE(tienet_master_result_buffer_comp, comp_len);

    tienet_recv(sock->num, tienet_master_result_buffer_comp.data, comp_len);

    /* uncompress the data */
    dest_len = tienet_master_result_buffer.ind+32;	/* some extra padding for zlib to work with */
    uncompress(tienet_master_result_buffer.data, &dest_len, tienet_master_result_buffer_comp.data, tienet_master_result_buffer_comp.ind);

    tienet_master_transfer += tienet_master_result_buffer_comp.ind + sizeof(unsigned int);
#else
    /* receive result data */
    tienet_recv(sock->num, tienet_master_result_buffer.data, tienet_master_result_buffer.ind);
    tienet_master_transfer += tienet_master_result_buffer.ind;
#endif

    /* Send next work unit out before processing results so that slave is not waiting while result is being processed. */
    tienet_master_send_work(sock);

    /* Application level result callback function to process results. */
    tienet_master_fcb_result(&tienet_master_result_buffer);

    /*
     * If there's no units still out, the application has indicated it's done generating work,
     * and there's no available work left in the buffer, we're done.
     */

    if (!tienet_master_sem_out.val && tienet_master_endflag && !tienet_master_sem_read.val)
    {
	/* Release the wait semaphore, we're all done. */
	tienet_sem_post(&tienet_master_sem_shutdown);
	tienet_sem_post(&tienet_master_sem_app);
    }
}


void tienet_master_shutdown()
{
    short op;
    tienet_master_socket_t *socket;


    tienet_master_shutdown_state = 1;
    printf("Master is shutting down, standby.\n");
    tienet_sem_wait(&tienet_master_sem_shutdown);
    tienet_master_halt_networking = 1;

    /* Close Sockets */
    for (socket = tienet_master_socket_list; socket; socket = socket->next)
    {
	if (socket->next)
	{
	    /* Only if slave socket do we send data to it. */
	    op = TN_OP_COMPLETE;
	    tienet_send(socket->num, &op, sizeof(short));

	    /*
	     * Wait on Recv.  When slave socket closes, select will be triggered.
	     * At this point we know for sure the slave has disconnected.  This prevents
	     * the master socket from being closed before the slave socket, thus pushing
	     * the socket into an evil wait state
	     */

	    tienet_recv(socket->num, &op, sizeof(short));
	    close(socket->num);
	}
    }

    printf("Total data transfered: %.1f MiB\n", (tfloat)tienet_master_transfer/(tfloat)(1024*1024));
}


/* This function does not support message queuing right now, so don't try it. */
void tienet_master_broadcast(const void *mesg, size_t mesg_len)
{
    tienet_master_socket_t *socket;

    /* Prevent a Read and Write of the broadcast from occuring at the same time */
    pthread_mutex_lock(&tienet_master_broadcast_mut);

    /* Send a message to each available socket */
    for (socket = tienet_master_socket_list; socket; socket = socket->next)
    {
	/* Only if not master socket */
	if (socket->next)
	{
	    socket->mesg.size = mesg_len;
	    socket->mesg.data = bu_malloc(mesg_len, "message data");
	    memcpy(socket->mesg.data, mesg, mesg_len);
	}
    }
    pthread_mutex_unlock(&tienet_master_broadcast_mut);

    /*
     * Tell any idle slaves to get back to work.
     * This is the case where slaves have exhausted the work buffer,
     * then new work becomes available.
     */
    for (socket = tienet_master_socket_list; socket; socket = socket->next)
    {
	/* Only if not master socket do we send data to slave */
	if (socket->next && socket->idle)
	    tienet_master_send_work(socket);
    }
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 6092
/*                  T I E N E T _ S L A V E . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2002-2008 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file tienet_slave.c
 *
 *  Comments -
 *      TIE Networking Slave
 *
 */

#include "tienet_slave.h"
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>
#include <string.h>

#include "bio.h"
#include "tie.h"
#include "tienet_define.h"
#include "tienet_util.h"
#if TN_COMPRESSION
# include <zlib.h>
#endif


void	tienet_slave_worker(int port, char *host);

int	tienet_slave_ver_key;


/* work function callback */
typedef void tienet_slave_fcb_work_t(tienet_buffer_t *work, tienet_buffer_t *result);
tienet_slave_fcb_work_t	*tienet_slave_fcb_work;

/* free function callback */
typedef void tienet_slave_fcb_free_t();
tienet_slave_fcb_free_t	*tienet_slave_fcb_free;

void tienet_slave_init(int port, char *host,
                       void fcb_work(tienet_buffer_t *work, tienet_buffer_t *result),
                       void fcb_free(void),
                       int ver_key)
{
    tienet_slave_fcb_work = fcb_work;
    tienet_slave_fcb_free = fcb_free;


    /* Store version key for comparisson with version key on master */
    tienet_slave_ver_key = ver_key;

    /*
     * If host is specified, connect to master, do work, shutdown.
     */

    if (host[0]) {
	tienet_slave_worker(port, host);
    } else {
	fprintf(stdout, "missing hostname, exiting.\n");
	exit(1);
    }
}


void tienet_slave_free() {
}


void tienet_slave_worker(int port, char *host) {
    tienet_buffer_t result, buffer;
    struct sockaddr_in master, slave;
    struct hostent h;
    short op;
    uint32_t size;
    int slave_socket;
#if TN_COMPRESSION
    tienet_buffer_t buffer_comp;
    unsigned long dest_len;
#endif


    /* Initialize res_buf to NULL for realloc'ing */
    TIENET_BUFFER_INIT(result);
    TIENET_BUFFER_INIT(buffer);
#if TN_COMPRESSION
    TIENET_BUFFER_INIT(buffer_comp);
#endif

    if (gethostbyname(host)) {
	h = gethostbyname(host)[0];
    } else {
	fprintf(stderr, "unknown host: %s\n", host);
	exit(1);
    }

    master.sin_family = h.h_addrtype;
    memcpy((char *)&master.sin_addr.s_addr, h.h_addr_list[0], h.h_length);
    master.sin_port = htons(port);

    /* Create a socket */
    if ((slave_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
	fprintf(stderr, "unable to create socket, exiting.\n");
	exit(1);
    }

    /* Bind any available port number */
    slave.sin_family = AF_INET;
    slave.sin_addr.s_addr = htonl(INADDR_ANY);
    slave.sin_port = htons(0);

    if (bind(slave_socket, (struct sockaddr *)&slave, sizeof(slave)) < 0) {
	fprintf(stderr, "unable to bind socket, exiting\n");
	exit(1);
    }

    /* connect to master and request work */
    if (connect(slave_socket, (struct sockaddr *)&master, sizeof(master)) < 0) {
	fprintf(stderr, "cannot connect to master, exiting.\n");
	exit(1);
    }

    /* receive endian of master (going away) */
    {
	short tienet_endian;
	tienet_recv(slave_socket, &tienet_endian, sizeof(short));
    }

    /* send version key, master will respond whether to continue or not */
    tienet_send(slave_socket, &tienet_slave_ver_key, sizeof(int));

    /* If version mismatch then exit */
    tienet_recv(slave_socket, &op, sizeof(short));
    if (op == TN_OP_COMPLETE)
	return;

    /* Request Work Unit */
//  op = TN_OP_REQWORK;
//  tienet_send(slave_socket, &op, sizeof(short));

    while (1) {
	tienet_recv(slave_socket, &op, sizeof(short));
	if (op == TN_OP_SHUTDOWN || op == TN_OP_COMPLETE) {
	    close(slave_socket);
	    exit(0);
	} else {
	    tienet_recv(slave_socket, &size, sizeof(uint32_t));
	    TIENET_BUFFER_SIZE(buffer, size);
	    tienet_recv(slave_socket, buffer.data, size);
	    buffer.ind = size;

	    /* Process work and Generate Results */
	    tienet_slave_fcb_work(&buffer, &result);

	    if (!result.ind)
		continue;

	    /* Send Result Back, length of: result + op_code + result_length + compression_length */
	    TIENET_BUFFER_SIZE(buffer, result.ind+sizeof(short)+sizeof(int)+sizeof(uint32_t));

	    buffer.ind = 0;

	    /* Pack Operation Code */
	    op = TN_OP_RESULT;
	    TCOPY(short, &op, 0, buffer.data, buffer.ind);
	    buffer.ind += sizeof(short);

	    /* Pack Result Length */
	    TCOPY(uint32_t, &result.ind, 0, buffer.data, buffer.ind);
	    buffer.ind += sizeof(uint32_t);

#if TN_COMPRESSION
	    /* Compress the result buffer */
	    TIENET_BUFFER_SIZE(buffer_comp, result.ind+32);

	    dest_len = buffer_comp.size+32;
	    compress(buffer_comp.data, &dest_len, result.data, result.ind);
	    size = (uint32_t)dest_len;
    
	    /* Pack Compressed Result Length */
	    TCOPY(uint32_t, &size, 0, buffer.data, buffer.ind);
	    buffer.ind += sizeof(uint32_t);

	    /* Pack Compressed Result Data */
	    memcpy(&((char *)buffer.data)[buffer.ind], buffer_comp.data, size);
	    buffer.ind += size;
#else
	    /* Pack Result Data */
	    memcpy(&((char *)buffer.data)[buffer.ind], result.data, result.ind);
	    buffer.ind += result.ind;
#endif
	    tienet_send(slave_socket, buffer.data, buffer.ind);
	}
    }

    TIENET_BUFFER_FREE(result);
    TIENET_BUFFER_FREE(buffer);
#if TN_COMPRESSION
    TIENET_BUFFER_FREE(buffer_comp);
#endif
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 1304
/*                  T I E N E T _ S L A V E . H
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2002-2008 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file tienet_slave.h
 *
 *  Comments -
 *      TIE Networking Slave Header
 *
 */
#ifndef _TIENET_SLAVE_H
#define _TIENET_SLAVE_H

#include "tienet_util.h"

extern	void	tienet_slave_init(int port, char *host, void fcb_work(tienet_buffer_t *buffer, tienet_buffer_t *result),
				  void fcb_free(void),
				  int ver_key);
extern	void	tienet_slave_free();

#endif

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 2430
/*                   T I E N E T _ U T I L . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2002-2008 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file tienet_util.c
 *
 *  Comments -
 *      TIE Networking Utilities
 *
 */

#include "tienet_util.h"

#include <sys/select.h>

#include "bio.h"

int tienet_send(int socket, void* data, size_t size) {
    fd_set	set;
    int		ind = 0, r;

    FD_ZERO(&set);
    FD_SET(socket, &set);

    do {
	select(socket+1, NULL, &set, NULL, NULL);
	ind += r = write(socket, &((char*)data)[ind], size-ind);
	if (r <= 0) return(1);	/* Error, socket is probably dead */
    } while (ind < size);

    return(0);
}

int tienet_recv(int socket, void *data, int size) {
    fd_set	set;
    int		ind = 0, r;

    FD_ZERO(&set);
    FD_SET(socket, &set);

    do {
	select(socket+1, &set, NULL, NULL, NULL);
	ind += r = read(socket, &((char*)data)[ind], size-ind);
	if (r <= 0) return(1);	/* Error, socket is probably dead */
    } while (ind < size);

    return(0);
}

void tienet_sem_init(tienet_sem_t *sem, int val) {
    pthread_mutex_init(&sem->mut, 0);
    pthread_cond_init(&sem->cond, 0);
    sem->val = val;
}

void tienet_sem_free(tienet_sem_t *sem) {
    pthread_mutex_destroy(&sem->mut);
    pthread_cond_destroy(&sem->cond);
}

void tienet_sem_post(tienet_sem_t *sem) {
    pthread_mutex_lock(&sem->mut);
    sem->val++;
    pthread_cond_signal(&sem->cond);
    pthread_mutex_unlock(&sem->mut);
}

void tienet_sem_wait(tienet_sem_t *sem) {
    pthread_mutex_lock(&sem->mut);
    if (!sem->val)
	pthread_cond_wait(&sem->cond, &sem->mut);
    sem->val--;
    pthread_mutex_unlock(&sem->mut);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 2151
/*                   T I E N E T _ U T I L . H
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2002-2008 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file tienet_util.h
 *
 *  Comments -
 *      TIE Networking Utilities Header
 *
 */

#ifndef _TIENET_UTIL_H
#define _TIENET_UTIL_H

#include "common.h"

#include <pthread.h>
#include <sys/types.h>
#include <sys/socket.h>
#ifdef HAVE_STDINT_H
#  include <stdint.h>
#endif

#include "bu.h"

#define TIENET_BUFFER_INIT(_b) { \
	_b.data = NULL; \
	_b.size = 0; \
	_b.ind = 0; }

#define TIENET_BUFFER_FREE(_b) bu_free(_b.data, "tienet buffer");

#define TIENET_BUFFER_SIZE(_b, _s) { \
	if (_s > _b.size) { \
	  _b.data = bu_realloc(_b.data, _s, "tienet buffer size"); \
	  _b.size = _s; \
        } }

typedef struct tienet_buffer_s {
    uint8_t *data;
    uint32_t size;
    uint32_t ind;
} tienet_buffer_t;


typedef struct tienet_sem_s {
    int val;
    pthread_mutex_t mut;
    pthread_cond_t cond;
} tienet_sem_t;


extern	void	tienet_flip(void* src, void* dest, size_t size);
extern	int	tienet_send(int socket, void* data, size_t size);
extern	int	tienet_recv(int socket, void *data, int size);

extern	void	tienet_sem_init(tienet_sem_t *sem, int val);
extern	void	tienet_sem_free(tienet_sem_t *sem);
extern	void	tienet_sem_wait(tienet_sem_t *sem);
extern	void	tienet_sem_post(tienet_sem_t *sem);

#endif

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 557
# $Id$

lib_LTLIBRARIES = libtieutil.la
libtieutil_la_SOURCES = rand.c umath.c

AM_CFLAGS = \
	-I${top_srcdir}/src/adrt \
	-I${top_srcdir}/src/adrt/libtie \
	-I${top_srcdir}/src/adrt/libtienet \
	-I${top_srcdir}/src/adrt/libcommon \
	-I${top_srcdir}/src/adrt/librender \
	-I${top_srcdir}/src/adrt/libtexture \
	${TCL_CPPFLAGS}

libtieutil_la_LIBADD= \
	$(top_builddir)/src/libbu/libbu.la

noinst_HEADERS = font.h

tieincludedir = $(includedir)/tie
tieinclude_HEADERS = umath.h rand.h 

EXTRA_DIST=camera.c camera.h

include $(top_srcdir)/misc/Makefile.defs
blob
data 3618
/*                       C O M P N E T . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2007-2008 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file compnet.c
 *
 */

/*
 * $Id$
 */

/* compnet is first as it includes $(top_srcdir)/include/common.h */
#include "compnet.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>

#include "adrt.h"
#include "tienet.h"

int master_compserv_socket;
int master_compserv_active;


#define LIST_BASE_ATTS		0
#define LIST_DEP_ATTS		1
#define LIST_ALL_ATTS		2
#define LIST_METRICS		3
#define GET_BASE_ATTS_STATE	4
#define GET_ATTS_STATE		5
#define GET_ATT_STATE		6
#define SET_BASE_ATTS_01	7
#define SET_BASE_ATTS_STATE	8
#define RESET_BASE_ATTS		9
#define	TERM			128


/*
 * Establish a connection to the component server.
 */
void compnet_connect(char *host, int port) {
    struct hostent hostent;
    struct sockaddr_in compserv, master;

    master_compserv_active = 0;

    /* If no host name is supplied then do nothing */
    if (!strlen(host))
	return;

    /* server address */
    if (gethostbyname(host)) {
	hostent = gethostbyname(host)[0];
    } else {
	fprintf(stderr, "hostname %s unknown, exiting.\n", host);
	exit(1);
    }

    /* create a socket */
    if ((master_compserv_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
	fprintf(stderr, "cannot create socket for component server connection, exiting.");
	exit(1);
    }

    /* client address */
    master.sin_family = AF_INET;
    master.sin_addr.s_addr = INADDR_ANY;
    master.sin_port = htons(0);

    compserv.sin_family = hostent.h_addrtype;
    memcpy((char*)&compserv.sin_addr.s_addr, hostent.h_addr_list[0], hostent.h_length);
    compserv.sin_port = htons(port);

    if (bind(master_compserv_socket, (struct sockaddr *)&master, sizeof(master)) < 0) {
	fprintf(stderr, "unable to bind component server connection socket, exiting.\n");
	exit(1);
    }

    /* connect to master */
    if (connect(master_compserv_socket, (struct sockaddr *)&compserv, sizeof(compserv)) < 0) {
	fprintf(stderr, "cannot connect to component server, exiting.\n");
	exit(1);
    }

    /* data may now be transmitted to the server */
    master_compserv_active = 1;
}

/*
 * Update the status of a component
 */
void compnet_update(char *string, char status) {
    char message[ADRT_NAME_SIZE];

    if (!master_compserv_active)
	return;

    /* format message */
    snprintf(message, ADRT_NAME_SIZE, "%c%s,%d%c", SET_BASE_ATTS_STATE, string, status, TERM);

    /* Send string */
    tienet_send(master_compserv_socket, message, strlen(message));
}


void compnet_reset() {
    char message;

    if (!master_compserv_active)
	return;

    message = RESET_BASE_ATTS;
    tienet_send(master_compserv_socket, &message, 1);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 15014
/*                        M A S T E R . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2007-2008 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file master.c
 *
 */

#include "master.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include "camera.h"
#include "dispatcher.h"		/* Dispatcher that creates work units */
#include "compnet.h"		/* Component Networking, Sends Component Names via Network */
#include "adrt.h"		/* adrt Defines */
#include "adrt_struct.h"	/* adrt common structs */
#include "tienet.h"		/* Networking stuff */
/* Networking Includes */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#if ADRT_USE_COMPRESSION
#  include <zlib.h>
#endif

#include "bio.h"


/* socket structure */
typedef struct master_socket_s
{
    int32_t num;
    int32_t controller;
    int32_t active;
    tienet_sem_t frame_sem;
    struct master_socket_s *prev;
    struct master_socket_s *next;
} master_socket_t;


typedef struct master_s
{
    uint8_t wid_list[ADRT_MAX_WORKSPACE_NUM];

    uint16_t image_w;
    uint16_t image_h;
    uint16_t image_format;

    uint32_t tile_num;

    master_socket_t *socklist;
    tienet_sem_t wait_sem;

    tienet_buffer_t buf;
#if ADRT_USE_COMPRESSION
    tienet_buffer_t buf_comp;
#endif

    uint32_t frame_ind;
    uint8_t slave_data[64];
    uint32_t slave_data_len;
    pthread_t networking_thread;
    uint32_t active_connections;
    uint32_t alive;
} master_t;


void* master_networking (void *ptr);
void master_result (tienet_buffer_t *result);

master_t master;


static void
master_setup ()
{
    uint16_t i;

    master.active_connections = 0;

    master.alive = 1;

    master.frame_ind = 0;

    TIENET_BUFFER_INIT(master.buf);
#if ADRT_USE_COMPRESSION
    TIENET_BUFFER_INIT(master.buf_comp);
#endif

    /* -1 indicates this slot is not used and thus does not contain an open project. */
    for (i = 0; i < ADRT_MAX_WORKSPACE_NUM; i++)
	master.wid_list[i] = 0;
}


void
master_init (int port, int obs_port, char *list, char *exec, char *comp_host, int verbose)
{
    /* Setup defaults */
    master_setup();

    /* Initialize tienet master */
    master.tile_num = DISPATCHER_TILE_NUM * DISPATCHER_TILE_NUM;
    tienet_master_init(port, master_result, list, exec, 5, ADRT_VER_KEY, verbose);

    /* Launch a thread to handle networking */
    pthread_create(&master.networking_thread, NULL, master_networking, &obs_port);

    /* Connect to the component Server */
    compnet_connect(comp_host, ISST_COMPNET_PORT);

    /* Initialize the work dispatcher */
    master_dispatcher_init();

    tienet_sem_init(&master.wait_sem, 0);

    /* Process work units */
    tienet_sem_wait(&master.wait_sem);

    /* Wait for the tienet master work buffer to empty and for all the results to come back */
    tienet_master_wait();

    /* Shutdown */
    tienet_master_shutdown();

    /* Free network data */
    tienet_master_free();

    /* Free the dispatcher data */
    master_dispatcher_free();

    TIENET_BUFFER_FREE(master.buf);
#if ADRT_USE_COMPRESSION
    TIENET_BUFFER_FREE(master.buf_comp);
#endif

    /* Wait for networking thread to end */
    pthread_join(master.networking_thread, NULL);
}


void
master_result (tienet_buffer_t *result)
{
    master_socket_t *sock;
    camera_tile_t tile;
    uint8_t *rgb_data, op;
    uint16_t wid;
    uint32_t i, ind, ind2, update;


    update = 0;
    ind = 0;

    op = result->data[ind];
    ind += 1;

    TCOPY (uint16_t, result->data, ind, &wid, 0);
    ind += 2;

    switch (op)
    {
	case ADRT_WORK_FRAME:
	    /* Work unit data */
	    TCOPY(camera_tile_t, result->data, ind, &tile, 0);
	    ind += sizeof (camera_tile_t);

	    /* Pointer to RGB Data */
	    rgb_data = &result->data[ind];

	    /* Copy the tile into the image */
	    ind = 0;
	    ind2 = tile.orig_x + tile.orig_y * master.image_w;

	    /* Only does 24-bit right now */
	    for (i = 0; i < tile.size_y; i++)
	    {
		bcopy(&rgb_data[3*ind], &master.buf.data[3*ind2], 3*tile.size_x);
		ind += tile.size_x;
		ind2 += master.image_w;
	    }

	    master.frame_ind++;

	    /* Image is complete, draw the frame. */
	    if (master.frame_ind == master.tile_num)
	    {
		update = 1;
		master.frame_ind = 0;
		master.buf.ind = 3 * master.image_w * master.image_h;
	    }
	    break;

	case ADRT_WORK_SHOTLINE:
	{
	    tienet_buffer_t selection_buf;
	    uint32_t i, num, tind;
	    uint8_t c;
	    char name[256];

	    TIENET_BUFFER_INIT(selection_buf);
	    TIENET_BUFFER_SIZE(selection_buf, result->ind);

	    /* Send this data to the slaves as ADRT_WORK_SELECT for highlighting hit components */
	    selection_buf.ind = 0;

	    op = ADRT_WORK_SELECT;
	    TCOPY(uint8_t, &op, 0, selection_buf.data, selection_buf.ind);
	    selection_buf.ind += 1;

	    TCOPY(uint16_t, &wid, 0, selection_buf.data, selection_buf.ind);
	    selection_buf.ind += 2;

	    tind = ind;

	    /* Skip over in-hit */
	    tind += sizeof(TIE_3);

	    /* Number of meshes */
	    TCOPY(uint32_t, result->data, tind, &num, 0);
	    tind += 4;

	    /* Reset Flag */
	    op = 1;
	    TCOPY(uint8_t, &op, 0, selection_buf.data, selection_buf.ind);
	    selection_buf.ind += 1;

	    /* Number of meshes */
	    TCOPY(uint32_t, &num, 0, selection_buf.data, selection_buf.ind);
	    selection_buf.ind += 4;

	    /* For each intersected mesh extract the name and pack it, skipping the thickness */
	    for (i = 0; i < num; i++)
	    {
		/* length of string */
		TCOPY(uint8_t, result->data, tind, &c, 0);
		tind += 1;

		/* the name */
		bcopy(&result->data[tind], name, c);
		tind += c;

		/* skip over the thickness */
		tind += sizeof(tfloat);

		/* pack the mesh name length and name */
		TCOPY(uint8_t, &c, 0, selection_buf.data, selection_buf.ind);
		selection_buf.ind += 1;

		bcopy(name, &selection_buf.data[selection_buf.ind], c);
		selection_buf.ind += c;
	    }

	    /* Shotline Selection data being sent to slaves */
	    tienet_master_broadcast(selection_buf.data, selection_buf.ind);
	    update = 1;

	    TIENET_BUFFER_FREE(selection_buf);

	    /* The data that will be sent to the observer */
	    TIENET_BUFFER_SIZE(master.buf, result->ind - ind + 1);
	    master.buf.ind = 0;
	    bcopy(&result->data[ind], &master.buf.data[master.buf.ind], result->ind - ind);
	    master.buf.ind += result->ind - ind;
	}
	break;

	case ADRT_WORK_MINMAX:
	    /* The data that will be sent to the observer */
	    TIENET_BUFFER_SIZE(master.buf, result->ind - ind);
	    master.buf.ind = 0;
	    bcopy(&result->data[ind], &master.buf.data[master.buf.ind], result->ind - ind);
	    master.buf.ind += result->ind - ind;
	    update = 1;
	    break;

	default:
	    break;
    }

    /* Alert the observers that a new frame is available for viewing */
    if (update)
	for (sock = master.socklist; sock; sock = sock->next)
	    if (sock->next)
		if (!sock->frame_sem.val)
		    tienet_sem_post (&(sock->frame_sem));
}


void*
master_networking (void *ptr)
{
    master_socket_t *sock, *tmp;
    struct sockaddr_in master_addr, observer_addr;
    fd_set readfds;
    int port, master_socket, highest_fd, new_socket, error;
    unsigned int addrlen;
    uint8_t op;
    uint16_t endian;


    port = *(int *) ptr;


    /* create a socket */
    if ((master_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
	fprintf (stderr, "unable to create socket, exiting.\n");
	exit(1);
    }

    /* initialize socket list */
    master.socklist = (master_socket_t *)bu_malloc(sizeof(master_socket_t), "master socket list");
    master.socklist->next = NULL;
    master.socklist->prev = NULL;
    master.socklist->num = master_socket;

    highest_fd = master_socket;


    /* server address */
    master_addr.sin_family = AF_INET;
    master_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    master_addr.sin_port = htons(port);

    /* bind socket */
    if (bind (master_socket, (struct sockaddr *)&master_addr, sizeof(master_addr)) < 0)
    {
	fprintf(stderr, "observer socket already bound, exiting.\n");
	exit(1);
    }

    FD_ZERO(&readfds);
    FD_SET(master_socket, &readfds);

    /* listen for connections */
    listen (master.socklist->num, 3);

    addrlen = sizeof(observer_addr);
    master.active_connections = 0;

    while (master.alive || master.active_connections)
    {
	/* wait for some network activity */
	select(highest_fd+1, &readfds, NULL, NULL, NULL);

	/* cycle through each socket and address the activity */
	for (sock = master.socklist; sock; sock = sock->next)
	{
	    /* if no longer alive then mark each of the active connections as no longer active */
	    if (!master.alive)
		sock->active = 0;

	    /* check if activity was on this socket */
	    if (!FD_ISSET(sock->num, &readfds))
		continue;

	    /* new connection */
	    if (sock->num == master_socket)
	    {
		new_socket = accept (master_socket, (struct sockaddr *)&observer_addr, &addrlen);
		if (new_socket >= 0)
		{
		    tmp = master.socklist;
		    master.socklist = (master_socket_t *)bu_malloc(sizeof(master_socket_t), "master socket connection");
		    master.socklist->num = new_socket;
		    master.socklist->controller = master.active_connections ? 0 : 1;
		    master.socklist->active = 1;
		    master.socklist->next = tmp;
		    master.socklist->prev = NULL;
		    tienet_sem_init(&(master.socklist->frame_sem), 0);
		    tmp->prev = master.socklist;
		    if (new_socket > highest_fd)
			highest_fd = new_socket;
		    master.active_connections++;
		}
		continue;
	    }

	    /* remove socket from pool if there's an error, i.e slave disconnected */
	    op = 255;
	    error = tienet_recv (sock->num, &op, 1);
	    if (error || op == ADRT_NETOP_QUIT || !sock->active)
	    {
		op = ADRT_NETOP_QUIT;
		tienet_send (sock->num, &op, 1);

		tmp = sock;
		if (sock->prev)
		    sock->prev->next = sock->next;
		/* master is always last, no need to check for sock->next next */
		sock->next->prev = sock->prev;
		if (sock == master.socklist)
		    master.socklist = master.socklist->next;
		close(sock->num);
		sock = sock->next;
		bu_free(tmp, "tmp socket");
		master.active_connections--;
		continue;
	    }

	    /* standard communication */
	    switch (op)
	    {
		case ADRT_NETOP_SHUTDOWN:
		    tienet_sem_post (&master.wait_sem);
		    return (NULL);
		    break;

		case ADRT_NETOP_INIT:
		    /* send endian */
		    endian = 1;
		    tienet_send (sock->num, &endian, 2);
		    break;

		case ADRT_NETOP_REQWID:
		{
		    uint16_t i;

		    /*
		     * Allocate a Workspace ID that the client application can
		     * use to pass along to the slaves to associate a project id with.
		     */
		    i = 0;
		    while (master.wid_list[i] && i < ADRT_MAX_WORKSPACE_NUM)
			i++;

		    /* Mark this ID as being in use. */
		    master.wid_list[i] = 1;

		    /* Send this WID to the client application. */
		    tienet_send (sock->num, &i, 2);
		}
		break;

		case ADRT_NETOP_LOAD:
		{
		    uint32_t size;
		    void *mesg;

		    tienet_recv (sock->num, &size, 4);
		    mesg = bu_malloc (size, "message buffer");
		    tienet_recv (sock->num, mesg, size);
		    tienet_master_broadcast(mesg, size);
		    bu_free(mesg, "message");
		}
		break;

		case ADRT_NETOP_WORK:
		{
		    uint16_t wid;

		    /* Size */
		    tienet_recv (sock->num, &master.slave_data_len, 4);
		    tienet_recv (sock->num, master.slave_data, master.slave_data_len);

		    op = master.slave_data[0];
		    bcopy (&master.slave_data[1], &wid, 2);

		    switch (op)
		    {
			case ADRT_WORK_FRAME_ATTR:
			    TCOPY(uint16_t, master.slave_data, 3, &master.image_w, 0);
			    TCOPY(uint16_t, master.slave_data, 5, &master.image_h, 0);
			    TCOPY(uint16_t, master.slave_data, 7, &master.image_format, 0);
			    TIENET_BUFFER_SIZE(master.buf, 3 * master.image_w * master.image_h);
			    tienet_master_broadcast(master.slave_data, master.slave_data_len);
			    tienet_sem_post(&(sock->frame_sem));
			    break;

			case ADRT_WORK_FRAME:
			{
			    /* Fill the work buffer */
			    master_dispatcher_generate(master.slave_data, master.slave_data_len, master.image_w, master.image_h, master.image_format);
			}
			break;

			case ADRT_WORK_SHOTLINE:
			    tienet_master_push(master.slave_data, master.slave_data_len);
			    break;

			case ADRT_WORK_SELECT:
			    tienet_master_broadcast(master.slave_data, master.slave_data_len);
			    tienet_sem_post(&(sock->frame_sem));
			    break;

			case ADRT_WORK_STATUS:
			    tienet_master_broadcast(master.slave_data, master.slave_data_len);
			    break;

			case ADRT_WORK_MINMAX:
			    tienet_master_push(master.slave_data, master.slave_data_len);
			    break;

			default:
			    break;
		    }

		    /* Wait for the result to come back */
		    tienet_sem_wait(&(sock->frame_sem));

		    /* Stamp the result with the work type */
		    tienet_send (sock->num, &op, 1);

		    /* Workspace ID */
		    tienet_send (sock->num, &wid, 2);

		    /* Size of result data */
		    tienet_send (sock->num, &master.buf.ind, 4);

#if ADRT_USE_COMPRESSION
		    {
			unsigned long dest_len;
			unsigned int comp_size;

			dest_len = master.buf.ind + 32;
			TIENET_BUFFER_SIZE(master.buf_comp, dest_len);

			/* result data */
			compress(&master.buf_comp.data[sizeof(unsigned int)], &dest_len, master.buf.data, master.buf.ind);
			comp_size = dest_len;

			TCOPY(uint32_t, &comp_size, 0, master.buf_comp.data, 0);

			/* int compressed data size in bytes followed by actual rgb frame data */
			tienet_send (sock->num, master.buf_comp.data, comp_size + sizeof(unsigned int));
		    }
#else
		    /* result data */
		    tienet_send (sock->num, master.buf.data, master.buf.ind);
#endif
		}
		break;

		case ADRT_NETOP_QUIT:
		    master.active_connections = 0;
		    break;

		default:
		    break;
	    }
	}

	/* Rebuild select list for next select call */
	highest_fd = 0;
	for (sock = master.socklist; sock; sock = sock->next)
	{
	    if (sock->num > highest_fd)
		highest_fd = sock->num;
	    FD_SET(sock->num, &readfds);
	}
    }

    /* free master.socklist */
    for (sock = master.socklist->next; sock; sock = sock->next)
	bu_free(sock->prev, "master socket list");

    return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 837

lib_LTLIBRARIES = libged.la
noinst_LTLIBRARIES = libged_nil.la

libged_nil_la_SOURCES = \
	arced.c \
	bigE.c \
	comb_color.c \
	dg_obj.c \
	editit.c \
	edcomb.c \
	edmater.c \
	globals.c \
	importFg4Section.c \
	item.c \
	log.c \
	make.c \
	make_name.c \
	mater.c \
	mirror.c \
	nirt.c \
	qray.c \
	rmater.c \
	shader.c \
	tcl.c \
	track.c \
	vdraw.c \
	view_obj.c \
	wdb_comb_std.c \
	wdb_obj.c \
	wmater.c

# cannot set per-target CPPFLAGS until automake 1.7+
AM_CPPFLAGS = \
	${TCL_CPPFLAGS}

noinst_HEADERS = \
	ged_private.h \
	qray.h

libged_la_SOURCES =
libged_la_LDFLAGS = -version-info 19:1 -no-undefined
libged_la_LIBADD = \
	libged_nil.la \
	${GED_LIBS}

EXTRA_DIST = \
        CMakeLists.txt

include $(top_srcdir)/misc/Makefile.defs

FAST_OBJECTS = \
	$(libged_nil_la_OBJECTS) \
	$(libged_la_OBJECTS) \
	$(lib_LTLIBRARIES)
blob
data 4835
# $Id$


lib_LTLIBRARIES = librt.la
noinst_LTLIBRARIES = \
	librt_nil.la \
	librt_xxx.la

BREP_TEST = brep_test
BREP_CPPFLAGS = @SSE@ -DOBJ_BREP=1 ${TNT_CPPFLAGS} ${OPENNURBS_CPPFLAGS}
BREP_LIBADD = ${OPENNURBS}

brep_test_SOURCES = brep_test.cpp
# cannot set per-target CPPFLAGS until automake 1.7+
brep_test_CXXFLAGS = ${SSE}
brep_test_LDADD = \
	librt.la \
	${RT_LIBS}

# cannot set per-target CPPFLAGS until automake 1.7+
AM_CPPFLAGS = \
	${REGEX_CPPFLAGS} \
	${TCL_CPPFLAGS} \
	${BREP_CPPFLAGS}

noinst_PROGRAMS = \
	comb \
	nurb_example \
	${BREP_TEST}

# make sure the example compiles, but don't include it in librt
librt_xxx_la_SOURCES = primitives/xxx/xxx.c

librt_nil_la_SOURCES = \
	bezier_2d_isect.c \
	binary_obj.c \
	bomb.c \
	bool.c \
	bundle.c \
	cmd.c \
	cut.c \
	db5_alloc.c \
	db5_bin.c \
	db5_comb.c \
	db5_io.c \
	db5_scan.c \
	db5_types.c \
	db_alloc.c \
	db_anim.c \
	db_comb.c \
	db_flags.c \
	db_inmem.c \
	db_io.c \
	db_lookup.c \
	db_match.c \
	db_open.c \
	db_path.c \
	db_scan.c \
	db_tree.c \
	db_walk.c \
	dir.c \
	dspline.c \
	fortray.c \
	globals.c \
	htbl.c \
	many.c \
	mater.c \
	memalloc.c \
	mirror.c \
	mkbundle.c \
	opennurbs_ext.cpp \
	oslo_calc.c \
	oslo_map.c \
	pr.c \
	prep.c \
	primitives/arb8/arb8.c \
	primitives/arbn/arbn.c \
	primitives/ars/ars.c \
	primitives/bot/bot.c \
	primitives/brep/brep.cpp \
	primitives/bspline/bspline.c \
	primitives/bspline/nurb_basis.c \
	primitives/bspline/nurb_bezier.c \
	primitives/bspline/nurb_bound.c \
	primitives/bspline/nurb_c2.c \
	primitives/bspline/nurb_copy.c \
	primitives/bspline/nurb_diff.c \
	primitives/bspline/nurb_eval.c \
	primitives/bspline/nurb_flat.c \
	primitives/bspline/nurb_interp.c \
	primitives/bspline/nurb_knot.c \
	primitives/bspline/nurb_norm.c \
	primitives/bspline/nurb_plot.c \
	primitives/bspline/nurb_poly.c \
	primitives/bspline/nurb_ray.c \
	primitives/bspline/nurb_refine.c \
	primitives/bspline/nurb_reverse.c \
	primitives/bspline/nurb_solve.c \
	primitives/bspline/nurb_split.c \
	primitives/bspline/nurb_tess.c \
	primitives/bspline/nurb_trim.c \
	primitives/bspline/nurb_trim_util.c \
	primitives/bspline/nurb_util.c \
	primitives/bspline/nurb_xsplit.c \
	primitives/cline/cline.c \
	primitives/dsp/dsp.c \
	primitives/ebm/ebm.c \
	primitives/ehy/ehy.c \
	primitives/ell/ell.c \
	primitives/epa/epa.c \
	primitives/eto/eto.c \
	primitives/extrude/extrude.c \
	primitives/grip/grip.c \
	primitives/half/half.c \
	primitives/hf/hf.c \
	primitives/hyp/hyp.c \
	primitives/metaball/metaball.c \
	primitives/nmg/nmg.c \
	primitives/nmg/nmg_bool.c \
	primitives/nmg/nmg_ck.c \
	primitives/nmg/nmg_class.c \
	primitives/nmg/nmg_eval.c \
	primitives/nmg/nmg_extrude.c \
	primitives/nmg/nmg_fcut.c \
	primitives/nmg/nmg_fuse.c \
	primitives/nmg/nmg_index.c \
	primitives/nmg/nmg_info.c \
	primitives/nmg/nmg_inter.c \
	primitives/nmg/nmg_manif.c \
	primitives/nmg/nmg_mesh.c \
	primitives/nmg/nmg_misc.c \
	primitives/nmg/nmg_mk.c \
	primitives/nmg/nmg_mod.c \
	primitives/nmg/nmg_plot.c \
	primitives/nmg/nmg_pr.c \
	primitives/nmg/nmg_pt_fu.c \
	primitives/nmg/nmg_rt_isect.c \
	primitives/nmg/nmg_rt_segs.c \
	primitives/nmg/nmg_tri.c \
	primitives/nmg/nmg_visit.c \
	primitives/part/part.c \
	primitives/pipe/pipe.c \
	primitives/poly/poly.c \
	primitives/rec/rec.c \
	primitives/rhc/rhc.c \
	primitives/rpc/rpc.c \
	primitives/sketch/sketch.c \
	primitives/sph/sph.c \
	primitives/submodel/submodel.c \
	primitives/superell/superell.c \
	primitives/tor/tor.c \
	primitives/tgc/tgc.c \
	primitives/vol/vol.c \
	regionfix.c \
	roots.c \
	shoot.c \
	spectrum.c \
	storage.c \
	table.c \
	tcl.c \
	timer42.c \
	transform.c \
	tree.c \
	vers.c \
	vlist.c \
	wdb.c

librt_nil_la_LIBADD = ${BREP_LIBADD}

librt_la_SOURCES =
librt_la_LDFLAGS = -version-info 19:1 -no-undefined -Wc,${FEXCEPTIONS}
librt_la_LIBADD = \
	librt_nil.la \
	${RT_LIBS}

comb_SOURCES = comb.c
comb_LDADD = \
	librt.la \
	${RT_LIBS}

nurb_example_SOURCES = nurb_example.c
nurb_example_LDADD = \
	librt.la \
	${RT_LIBS}

noinst_HEADERS = \
	primitives/fixpt.h \
	primitives/xxx/xxx.h

dist_man_MANS = librt.3

sample_applicationsdir = $(SAMPLE_APPLICATIONS_DIR)

sample_applications_DATA = \
	nurb_example.c \
	raydebug.tcl

# XXX need to fix these so the timers are selected by configure.ac
EXTRA_DIST = \
	$(sample_applications_DATA) \
        CMakeLists.txt \
	brep_test.cpp \
	parse.c \
	pmalloc.c \
	primitives/bot/g_bot_include.c \
	primitives/nmg/nmg_junk.c \
	timer-nt.c \
	timer52brl.c \
	timerhep.c \
	timerunix.c \
	vshoot.c

if BUILD_REGEX
DEPADD = src/other/libregex
endif

DEPENDS = src/libbn src/libsysv src/other/openNURBS ${DEPADD}

include $(top_srcdir)/misc/Makefile.defs

FAST_OBJECTS = \
	$(librt_nil_la_OBJECTS) \
	$(librt_la_OBJECTS) \
	$(lib_LTLIBRARIES) \
	$(comb_OBJECTS) \
	$(nurb_example_OBJECTS) \
	$(noinst_PROGRAMS)
blob
data 29742
/*                            D O . C
 * BRL-CAD
 *
 * Copyright (c) 1987-2008 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file do.c
 *
 *  Routines that process the various commands, and manage
 *  the overall process of running the raytracing process.
 *
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_STAT_H
#  include <sys/stat.h>
#endif

#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "rtprivate.h"
#include "bu.h"

/***** Variables shared with viewing model *** */
extern FILE	*outfp;			/* optional pixel output file */
extern double	azimuth, elevation;
extern mat_t	view2model;
extern mat_t	model2view;
/***** end of sharing with viewing model *****/

extern void	grid_setup(void);
extern void	worker(int cpu, genptr_t arg);

/***** variables shared with worker() ******/
extern struct application ap;
extern int	hypersample;		/* number of extra rays to fire */
extern fastf_t	aspect;			/* view aspect ratio X/Y */
extern fastf_t	cell_width;		/* model space grid cell width */
extern fastf_t	cell_height;		/* model space grid cell height */
extern point_t	eye_model;		/* model-space location of eye */
extern fastf_t  eye_backoff;		/* dist of eye from center */
extern fastf_t	rt_perspective;		/* persp (degrees X) 0 => ortho */
extern int	width;			/* # of pixels in X */
extern int	height;			/* # of lines in Y */
extern mat_t	Viewrotscale;		/* view orientation quaternion */
extern fastf_t	viewsize;
extern int	incr_mode;		/* !0 for incremental resolution */
extern int	incr_level;		/* current incremental level */
extern int	incr_nlevel;		/* number of levels */
extern int	npsw;
extern struct resource resource[];
/***** end variables shared with worker() */

/***** variables shared with rt.c *****/
extern char	*string_pix_start;	/* string spec of starting pixel */
extern char	*string_pix_end;	/* string spec of ending pixel */
extern int	pix_start;		/* pixel to start at */
extern int	pix_end;		/* pixel to end at */
extern int	nobjs;			/* Number of cmd-line treetops */
extern char	**objtab;		/* array of treetop strings */
extern int	matflag;		/* read matrix from stdin */
extern int	desiredframe;		/* frame to start at */
extern int	finalframe;		/* frame to halt at */
extern int	curframe;		/* current frame number */
extern char	*outputfile;		/* name of base of output file */
extern int	interactive;		/* human is watching results */
extern int	save_overlaps;		/* flag for setting rti_save_overlaps */
/***** end variables shared with rt.c *****/

/***** variables shared with viewg3.c *****/
struct bu_vls   ray_data_file;  /* file name for ray data output */
/***** end variables shared with viewg3.c *****/

/***** variables for frame buffer black pixel rendering *****/
unsigned char *pixmap = NULL; /* Pixel Map for rerendering of black pixels */


void		def_tree(register struct rt_i *rtip);
void		do_ae(double azim, double elev);
void		res_pr(void);
void		memory_summary(void);

/*
 *			O L D _ F R A M E
 *
 *  Acquire particulars about a frame, in the old format.
 *  Returns -1 if unable to acquire info, 0 if successful.
 */
int
old_frame(FILE *fp)
{
    register int i;
    char number[128];

    /* Visible part is from -1 to +1 in view space */
    if ( fscanf( fp, "%128s", number ) != 1 )  return(-1);
    viewsize = atof(number);
    if ( fscanf( fp, "%128s", number ) != 1 )  return(-1);
    eye_model[X] = atof(number);
    if ( fscanf( fp, "%128s", number ) != 1 )  return(-1);
    eye_model[Y] = atof(number);
    if ( fscanf( fp, "%128s", number ) != 1 )  return(-1);
    eye_model[Z] = atof(number);
    for ( i=0; i < 16; i++ )  {
	if ( fscanf( fp, "%128s", number ) != 1 )
	    return(-1);
	Viewrotscale[i] = atof(number);
    }
    return(0);		/* OK */
}


/*
 *			O L D _ W A Y
 *
 *  Determine if input file is old or new format, and if
 *  old format, handle process *  Returns 0 if new way, 1 if old way (and all done).
 *  Note that the rewind() will fail on ttys, pipes, and sockets (sigh).
 */
int
old_way(FILE *fp)
{
    int	c;

    viewsize = -42.0;

    /* Sneek a peek at the first character, and then put it back */
    if ( (c = fgetc( fp )) == EOF )  {
	/* Claim old way, all (ie, nothing) done */
	return(1);
    }
    if ( ungetc( c, fp ) != c )
	bu_exit(EXIT_FAILURE, "do.c:old_way() ungetc failure\n");

    /*
     * Old format files start immediately with a %.9e format,
     * so the very first character should be a digit or '-'.
     */
    if ( (c < '0' || c > '9') && c != '-' )  {
	return( 0 );		/* Not old way */
    }

    if ( old_frame( fp ) < 0 || viewsize <= 0.0 )  {
	rewind( fp );
	return(0);		/* Not old way */
    }
    bu_log("Interpreting command stream in old format\n");

    def_tree( ap.a_rt_i );		/* Load the default trees */

    curframe = 0;
    do {
	if ( finalframe >= 0 && curframe > finalframe )
	    return(1);
	if ( curframe >= desiredframe )
	    do_frame( curframe );
	curframe++;
    }  while ( old_frame( fp ) >= 0 && viewsize > 0.0 );
    return(1);			/* old way, all done */
}


/*
 *			C M _ S T A R T
 *
 *  Process "start" command in new format input stream
 */
int cm_start( int argc, char **argv)
{
    char	*buf = (char *)NULL;
    int	frame;

    frame = atoi(argv[1]);
    if ( finalframe >= 0 && frame > finalframe )
	return(-1);	/* Indicate EOF -- user declared a halt */
    if ( frame >= desiredframe )  {
	curframe = frame;
	return(0);
    }

    /* Skip over unwanted frames -- find next frame start */
    while ( (buf = rt_read_cmd( stdin )) != (char *)0 )  {
	register char *cp;

	cp = buf;
	while ( *cp && isspace(*cp) )  cp++;	/* skip spaces */
	if ( strncmp( cp, "start", 5 ) != 0 )  continue;
	while ( *cp && !isspace(*cp) )  cp++;	/* skip keyword */
	while ( *cp && isspace(*cp) )  cp++;	/* skip spaces */
	frame = atoi(cp);
	bu_free( buf, "rt_read_cmd command buffer (skipping frames)" );
	buf = (char *)0;
	if ( finalframe >= 0 && frame > finalframe )
	    return(-1);			/* "EOF" */
	if ( frame >= desiredframe )  {
	    curframe = frame;
	    return(0);
	}
    }
    return(-1);		/* EOF */
}

int cm_vsize( int argc, char **argv)
{
    viewsize = atof( argv[1] );
    return(0);
}

int cm_eyept(int argc, char **argv)
{
    register int i;

    for ( i=0; i<3; i++ )
	eye_model[i] = atof( argv[i+1] );
    return(0);
}

int cm_lookat_pt(int argc, char **argv)
{
    point_t	pt;
    vect_t	dir;
    int	yflip = 0;
    quat_t quat;

    if ( argc < 4 )
	return(-1);
    pt[X] = atof(argv[1]);
    pt[Y] = atof(argv[2]);
    pt[Z] = atof(argv[3]);
    if ( argc > 4 )
	yflip = atoi(argv[4]);

    /*
     *  eye_pt should have been specified before here and
     *  different from the lookat point or the lookat point will
     *  be from the "front"
     */
    if (VAPPROXEQUAL(pt, eye_model, VDIVIDE_TOL)) {
	VSETALLN(quat, 0.5, 4);
	quat_quat2mat(Viewrotscale, quat); /* front */
    } else {
	VSUB2( dir, pt, eye_model );
	VUNITIZE( dir );
	bn_mat_lookat( Viewrotscale, dir, yflip );
    }

    return(0);
}

int cm_vrot( int argc, char **argv)
{
    register int i;

    for ( i=0; i<16; i++ )
	Viewrotscale[i] = atof( argv[i+1] );
    return(0);
}

int cm_orientation(int argc, char **argv)
{
    register int	i;
    quat_t		quat;

    for ( i=0; i<4; i++ )
	quat[i] = atof( argv[i+1] );
    quat_quat2mat( Viewrotscale, quat );
    return(0);
}

int cm_end(int argc, char **argv)
{
    struct rt_i *rtip = ap.a_rt_i;

    if ( rtip && BU_LIST_IS_EMPTY( &rtip->HeadRegion ) )  {
	def_tree( rtip );		/* Load the default trees */
    }

    /* If no matrix or az/el specified yet, use params from cmd line */
    if ( Viewrotscale[15] <= 0.0 )
	do_ae( azimuth, elevation );

    if ( do_frame( curframe ) < 0 )  return(-1);
    return(0);
}

int cm_tree( int argc, const char **argv)
{
    register struct rt_i *rtip = ap.a_rt_i;
    struct bu_vls	times;

    if ( argc <= 1 )  {
	def_tree( rtip );		/* Load the default trees */
	return(0);
    }
    bu_vls_init( &times );

    rt_prep_timer();
    if ( rt_gettrees(rtip, argc-1, &argv[1], npsw) < 0 )
	bu_log("rt_gettrees(%s) FAILED\n", argv[0]);
    (void)rt_get_timer( &times, NULL );

    if (rt_verbosity & VERBOSE_STATS)
	bu_log("GETTREE: %s\n", bu_vls_addr(&times) );
    bu_vls_free( &times );
    return(0);
}

int cm_multiview( int argc, char **argv)
{
    register struct rt_i *rtip = ap.a_rt_i;
    int i;
    static int a[] = {
	35,   0,
	0,  90, 135, 180, 225, 270, 315,
	0,  90, 135, 180, 225, 270, 315
    };
    static int e[] = {
	25, 90,
	30, 30, 30, 30, 30, 30, 30,
	60, 60, 60, 60, 60, 60, 60
    };

    if ( rtip && BU_LIST_IS_EMPTY( &rtip->HeadRegion ) )  {
	def_tree( rtip );		/* Load the default trees */
    }
    for ( i=0; i<(sizeof(a)/sizeof(a[0])); i++ )  {
	do_ae( (double)a[i], (double)e[i] );
	(void)do_frame( curframe++ );
    }
    return(-1);	/* end RT by returning an error */
}

/*
 *			C M _ A N I M
 *
 *  Experimental animation code
 *
 *  Usage:  anim <path> <type> args
 */
int cm_anim(int argc, const char **argv)
{

    if ( db_parse_anim( ap.a_rt_i->rti_dbip, argc, argv ) < 0 )  {
	bu_log("cm_anim:  %s %s failed\n", argv[1], argv[2]);
	return(-1);		/* BAD */
    }
    return(0);
}

/*
 *			C M _ C L E A N
 *
 *  Clean out results of last rt_prep(), and start anew.
 */
int cm_clean(int argc, char **argv)
{
    /* Allow lighting model to clean up (e.g. lights, materials, etc) */
    view_cleanup( ap.a_rt_i );

    rt_clean( ap.a_rt_i );

    if (R_DEBUG&RDEBUG_RTMEM_END)
	bu_prmem( "After cm_clean" );
    return(0);
}

/*
 *			C M _ C L O S E D B
 *
 *  To be invoked after a "clean" command, to close out the ".g" database.
 *  Intended for memory debugging, to help chase down memory "leaks".
 *  This terminates the program, as there is no longer a database.
 */
int cm_closedb(int argc, char **argv)
{
    db_close( ap.a_rt_i->rti_dbip );
    ap.a_rt_i->rti_dbip = DBI_NULL;

    bu_free( (genptr_t)ap.a_rt_i, "struct rt_i" );
    ap.a_rt_i = RTI_NULL;

    bu_prmem( "After _closedb" );
    bu_exit(0, NULL);

    return( 1 );	/* for compiler */
}

/* viewing module specific variables */
extern struct bu_structparse view_parse[];

struct bu_structparse set_parse[] = {
#if !defined(__alpha) /* XXX Alpha does not support this initialization! */
    {"%d",	1, "width",	bu_byteoffset(width),		BU_STRUCTPARSE_FUNC_NULL },
    {"%d",	1, "height",	bu_byteoffset(height),		BU_STRUCTPARSE_FUNC_NULL },
    {"%d",	1, "save_overlaps", bu_byteoffset(save_overlaps),	BU_STRUCTPARSE_FUNC_NULL },
    {"%f",	1, "perspective", bu_byteoffset(rt_perspective),	BU_STRUCTPARSE_FUNC_NULL },
    {"%f",	1, "angle",	bu_byteoffset(rt_perspective),	BU_STRUCTPARSE_FUNC_NULL },
#if !defined(_WIN32) || defined(__CYGWIN__)
    {"%d",  1, "rt_bot_minpieces", bu_byteoffset(rt_bot_minpieces), BU_STRUCTPARSE_FUNC_NULL },
    {"%d",  1, "rt_bot_tri_per_piece", bu_byteoffset(rt_bot_tri_per_piece), BU_STRUCTPARSE_FUNC_NULL },
    {"%f",  1, "rt_cline_radius", bu_byteoffset(rt_cline_radius), BU_STRUCTPARSE_FUNC_NULL },
#endif
    {"%S",  1, "ray_data_file", bu_byteoffset(ray_data_file), BU_STRUCTPARSE_FUNC_NULL },
    {"i", bu_byteoffset(view_parse[0]), "View_Module-Specific Parameters", 0, BU_STRUCTPARSE_FUNC_NULL },
#endif
    {"",	0, (char *)0,	0,				BU_STRUCTPARSE_FUNC_NULL }
};

/*
 *			C M _ S E T
 *
 *  Allow variable values to be set or examined.
 */
int cm_set(int argc, char **argv)
{
    struct bu_vls	str;

    if ( argc <= 1 ) {
	bu_struct_print( "Generic and Application-Specific Parameter Values",
			 set_parse, (char *)0 );
	return(0);
    }
    bu_vls_init( &str );
    bu_vls_from_argv( &str, argc-1, (const char **)argv+1 );
    if ( bu_struct_parse( &str, set_parse, (char *)0 ) < 0 )  {
	bu_vls_free( &str );
	return(-1);
    }
    bu_vls_free( &str );
    return(0);
}

/*
 *			C M _ A E
 */
int cm_ae( int argc, char **argv)
{
    azimuth = atof(argv[1]);	/* set elevation and azimuth */
    elevation = atof(argv[2]);
    do_ae(azimuth, elevation);

    return(0);
}

/*
 *			C M _ O P T
 */
int cm_opt(int argc, char **argv)
{
    int old_bu_optind=bu_optind;	/* need to restore this value after calling get_args() */

    if ( get_args( argc, argv ) <= 0 ) {
	bu_optind = old_bu_optind;
	return(-1);
    }
    bu_optind = old_bu_optind;
    return(0);
}


/*
 *			D E F _ T R E E
 *
 *  Load default tree list, from command line.
 */
void
def_tree(register struct rt_i *rtip)
{
    struct bu_vls	times;

    RT_CK_RTI(rtip);

    bu_vls_init( &times );
    rt_prep_timer();
    if ( rt_gettrees(rtip, nobjs, (const char **)objtab, npsw) < 0 )
	bu_log("rt_gettrees(%s) FAILED\n", objtab[0]);
    (void)rt_get_timer( &times, NULL );

    if (rt_verbosity & VERBOSE_STATS)
	bu_log("GETTREE: %s\n", bu_vls_addr(&times));
    bu_vls_free( &times );
    memory_summary();
}

/*
 *			D O _ P R E P
 *
 *  This is a separate function primarily as a service to REMRT.
 */
void
do_prep(struct rt_i *rtip)
{
    struct bu_vls	times;

    RT_CHECK_RTI(rtip);
    if ( rtip->needprep )  {
	/* Allow lighting model to set up (e.g. lights, materials, etc) */
	view_setup(rtip);

	/* Allow RT library to prepare itself */
	bu_vls_init( &times );
	rt_prep_timer();
	rt_prep_parallel(rtip, npsw);

	(void)rt_get_timer( &times, NULL );
	if (rt_verbosity & VERBOSE_STATS)
	    bu_log( "PREP: %s\n", bu_vls_addr(&times) );
	bu_vls_free( &times );
    }
    memory_summary();
    if (rt_verbosity & VERBOSE_STATS)  {
	bu_log("%s: %d nu, %d cut, %d box (%d empty)\n",
	       rtip->rti_space_partition == RT_PART_NUGRID ?
	       "NUGrid" : "NUBSP",
	       rtip->rti_ncut_by_type[CUT_NUGRIDNODE],
	       rtip->rti_ncut_by_type[CUT_CUTNODE],
	       rtip->rti_ncut_by_type[CUT_BOXNODE],
	       rtip->nempty_cells );
#if 0
	rt_pr_cut_info( rtip, "main" );
#endif
    }
}

/*
 *			D O _ F R A M E
 *
 *  Do all the actual work to run a frame.
 *
 *  Returns -1 on error, 0 if OK.
 */
int
do_frame(int framenumber)
{
    struct bu_vls	times;
    char framename[128] = {0};		/* File name to hold current frame */
    struct rt_i *rtip = ap.a_rt_i;
    double	utime = 0.0;			/* CPU time used */
    double	nutime = 0.0;			/* CPU time used, normalized by ncpu */
    double	wallclock;		/* # seconds of wall clock time */
    int	npix, i;			/* # of pixel values to be done */
    int	lim;
    vect_t	work, temp;
    quat_t	quat;

    if (rt_verbosity & VERBOSE_FRAMENUMBER)
	bu_log( "\n...................Frame %5d...................\n",
		framenumber);

    /* Compute model RPP, etc */
    do_prep( rtip );

    if (rt_verbosity & VERBOSE_VIEWDETAIL)
	bu_log("Tree: %d solids in %d regions\n",
	       rtip->nsolids, rtip->nregions );

    if (Query_one_pixel) {
	query_rdebug = R_DEBUG;
	query_debug = RT_G_DEBUG;
	rt_g.debug = rdebug = 0;
    }

    if ( rtip->nsolids <= 0 )
	bu_exit(3, "rt ERROR: No solids\n");

    if (rt_verbosity & VERBOSE_VIEWDETAIL)
	bu_log("Model: X(%g,%g), Y(%g,%g), Z(%g,%g)\n",
	       rtip->mdl_min[X], rtip->mdl_max[X],
	       rtip->mdl_min[Y], rtip->mdl_max[Y],
	       rtip->mdl_min[Z], rtip->mdl_max[Z] );

    /*
     *  Perform Grid setup.
     *  This may alter cell size or width/height.
     */
    grid_setup();
    /* az/el 0, 0 is when screen +Z is model +X */
    VSET( work, 0, 0, 1 );
    MAT3X3VEC( temp, view2model, work );
    bn_ae_vec( &azimuth, &elevation, temp );

    if (rt_verbosity & VERBOSE_VIEWDETAIL)
	bu_log(
	    "View: %g azimuth, %g elevation off of front view\n",
	    azimuth, elevation);
    quat_mat2quat( quat, model2view );
    if (rt_verbosity & VERBOSE_VIEWDETAIL) {
	bu_log("Orientation: %g, %g, %g, %g\n", V4ARGS(quat) );
	bu_log("Eye_pos: %g, %g, %g\n", V3ARGS(eye_model) );
	bu_log("Size: %gmm\n", viewsize);
#if 0
	/*
	 *  This code shows how the model2view matrix can be reconstructed
	 *  using the information from the Orientation, Eye_pos, and Size
	 *  messages.
	 */
	{
	    mat_t	rotscale, xlate;
	    mat_t	new;
	    quat_t	newquat;

	    bn_mat_print("model2view", model2view);
	    quat_quat2mat( rotscale, quat );
	    rotscale[15] = 0.5 * viewsize;
	    MAT_IDN( xlate );
	    MAT_DELTAS_VEC_NEG( xlate, eye_model);
	    bn_mat_mul( new, rotscale, xlate );
	    bn_mat_print("reconstructed m2v", new);
	    quat_mat2quat( newquat, new );
	    HPRINT( "reconstructed orientation:", newquat );
	}
#endif
	bu_log("Grid: (%g, %g) mm, (%d, %d) pixels\n",
	       cell_width, cell_height,
	       width, height );
	bu_log("Beam: radius=%g mm, divergence=%g mm/1mm\n",
	       ap.a_rbeam, ap.a_diverge );
    }

    /* Process -b and ??? options now, for this frame */
    if ( pix_start == -1 )  {
	pix_start = 0;
	pix_end = height * width - 1;
    }
    if ( string_pix_start )  {
	int xx, yy;
	register char *cp = string_pix_start;

	xx = atoi(cp);
	while ( *cp >= '0' && *cp <= '9' )  cp++;
	while ( *cp && (*cp < '0' || *cp > '9') ) cp++;
	yy = atoi(cp);
	bu_log("only pixel %d %d\n", xx, yy);
	if ( xx * yy >= 0 )  {
	    pix_start = yy * width + xx;
	    pix_end = pix_start;
	}
    }
    if ( string_pix_end )  {
	int xx, yy;
	register char *cp = string_pix_end;

	xx = atoi(cp);
	while ( *cp >= '0' && *cp <= '9' )  cp++;
	while ( *cp && (*cp < '0' || *cp > '9') ) cp++;
	yy = atoi(cp);
	bu_log("ending pixel %d %d\n", xx, yy);
	if ( xx * yy >= 0 )  {
	    pix_end = yy * width + xx;
	}
    }

    /*
     *  After the parameters for this calculation have been established,
     *  deal with CPU limits and priorities, where appropriate.
     *  Because limits exist, they better be adequate.
     *  We assume that the Cray can produce MINRATE pixels/sec
     *  on images with extreme amounts of glass & mirrors.
     */
#define MINRATE	65
    npix = width*height*(hypersample+1);
    if ( (lim = bu_cpulimit_get()) > 0 )  {
	bu_cpulimit_set( lim + npix / MINRATE + 100 );
    }

    /* Allocate data for pixel map for rerendering of black pixels */
    if (pixmap == NULL) {
	pixmap = (unsigned char*)bu_calloc(sizeof(RGBpixel), width*height, "pixmap allocate");
    }

    /*
     *  If this image is unlikely to be for debugging,
     *  be gentle to the machine.
     */
    if ( !interactive )  {
	if ( npix > 256*256 )
	    bu_nice_set(10);
	else if ( npix > 512*512 )
	    bu_nice_set(14);
    }

    /*
     *  Determine output file name
     *  On UNIX only, check to see if this is a "restart".
     */
    if ( outputfile != (char *)0 )  {
	if ( framenumber <= 0 )  {
	    snprintf( framename, 128, "%s", outputfile );
	}  else  {
	    snprintf( framename, 128, "%s.%d", outputfile, framenumber );
	}

#ifdef HAVE_SYS_STAT_H
	/*
	 *  This code allows the computation of a particular frame
	 *  to a disk file to be resumed automatically.
	 *  This is worthwhile crash protection.
	 *  This use of stat() and fseek() is UNIX-specific.
	 *
	 *  It is not appropriate for the RT "top part" to assume
	 *  anything about the data that the view module will be
	 *  storing.  Therefore, it is the responsibility of
	 *  view_2init() to also detect that some existing data
	 *  is in the file, and take appropriate measures
	 *  (like reading it in).
	 *  view_2init() can depend on the file being open for both
	 *  reading and writing, but must do it's own positioning.
	 */
	{
	    struct		stat	sb;
	    if ( stat( framename, &sb ) >= 0 &&
		 sb.st_size > 0 &&
		 sb.st_size < width*height*sizeof(RGBpixel))  {
		/* File exists, with partial results */
		register int	fd;
		if ( (fd = open( framename, 2 )) < 0 ||
		     (outfp = fdopen( fd, "r+" )) == NULL )  {
		    perror( framename );
		    if ( matflag )  return(0);	/* OK */
		    return(-1);			/* Bad */
		}
		/* Read existing pix data into the frame buffer */
		if (sb.st_size > 0) {
		    (void)fread(pixmap, 1, (size_t)sb.st_size, outfp);
		}
	    }
	}
#endif

	/* Ordinary case for creating output file */
	if ( outfp == NULL && (outfp = fopen( framename, "w+b" )) == NULL )
	{
	    perror( framename );
	    if ( matflag )  return(0);	/* OK */
	    return(-1);			/* Bad */
	}

	if (rt_verbosity & VERBOSE_OUTPUTFILE)
	    bu_log("Output file is '%s' %dx%d pixels\n",
		   framename, width, height);
    }

    /* initialize lighting, may update pix_start */
    view_2init( &ap, framename );

    /* Just while doing the ray-tracing */
    if (R_DEBUG&RDEBUG_RTMEM)
	bu_debug |= (BU_DEBUG_MEM_CHECK|BU_DEBUG_MEM_LOG);

    rtip->nshots = 0;
    rtip->nmiss_model = 0;
    rtip->nmiss_tree = 0;
    rtip->nmiss_solid = 0;
    rtip->nmiss = 0;
    rtip->nhits = 0;
    rtip->rti_nrays = 0;

    if (rt_verbosity & (VERBOSE_LIGHTINFO|VERBOSE_STATS))
	bu_log("\n");
    fflush(stdout);
    fflush(stderr);

    /*
     *  Compute the image
     *  It may prove desirable to do this in chunks
     */
    rt_prep_timer();

    if ( incr_mode )  {
	for ( incr_level = 1; incr_level <= incr_nlevel; incr_level++ )  {
	    if ( incr_level > 1 )
		view_2init( &ap, framename );

	    do_run( 0, (1<<incr_level)*(1<<incr_level)-1 );
	}
    } else {
	do_run( pix_start, pix_end );

	/* Reset values to full size, for next frame (if any) */
	pix_start = 0;
	pix_end = height*width - 1;
    }
    bu_vls_init( &times );
    utime = rt_get_timer( &times, &wallclock );

    /*
     *  End of application.  Done outside of timing section.
     *  Typically, writes any remaining results out.
     */
    view_end( &ap );

    /* Stop memory debug printing until next frame, leave full checking on */
    if (R_DEBUG&RDEBUG_RTMEM)
	bu_debug &= ~BU_DEBUG_MEM_LOG;

    /*
     *  Certain parallel systems (eg, Alliant) count the entire
     *  multi-processor complex as one computer, and charge only once.
     *  This matches the desired behavior here.
     *  Other vendors (eg, SGI) count each processor separately,
     *  and charge for all of them.  These results need to be normalized.
     *  Otherwise, all we would know is that a given workload takes about
     *  the same amount of CPU time, regardless of the number of CPUs.
     */
#if !defined(alliant)
    if ( npsw > 1 )  {
	int avail_cpus;
	int ncpus;

	avail_cpus = bu_avail_cpus();
	if ( npsw > avail_cpus ) {
	    ncpus = avail_cpus;
	} else {
	    ncpus = npsw;
	}
	nutime = utime / ncpus;			/* compensate */
    } else
#endif
	nutime = utime;

    /* prevent a bogus near-zero time to prevent infinate and near-infinate
     * results without relying on IEEE floating point zero comparison.
     */
    if (NEAR_ZERO(nutime, VDIVIDE_TOL)) {
	bu_log("WARNING:  Raytrace timings are likely to be meaningless\n");
	nutime = VDIVIDE_TOL;
    }

    /*
     *  All done.  Display run statistics.
     */
    if (rt_verbosity & VERBOSE_STATS)
	bu_log("SHOT: %s\n", bu_vls_addr( &times ) );
    bu_vls_free( &times );
    memory_summary();
    if (rt_verbosity & VERBOSE_STATS) {
	bu_log("%ld solid/ray intersections: %ld hits + %ld miss\n",
	       rtip->nshots, rtip->nhits, rtip->nmiss );
	bu_log("pruned %.1f%%:  %ld model RPP, %ld dups skipped, %ld solid RPP\n",
	       rtip->nshots>0?((double)rtip->nhits*100.0)/rtip->nshots:100.0,
	       rtip->nmiss_model, rtip->ndup, rtip->nmiss_solid );
	bu_log("Frame %2d: %10d pixels in %9.2f sec = %12.2f pixels/sec\n",
	       framenumber,
	       width*height, nutime, ((double)(width*height))/nutime );
	bu_log("Frame %2d: %10d rays   in %9.2f sec = %12.2f rays/sec (RTFM)\n",
	       framenumber,
	       rtip->rti_nrays, nutime, ((double)(rtip->rti_nrays))/nutime );
	bu_log("Frame %2d: %10d rays   in %9.2f sec = %12.2f rays/CPU_sec\n",
	       framenumber,
	       rtip->rti_nrays, utime, ((double)(rtip->rti_nrays))/utime );
	bu_log("Frame %2d: %10d rays   in %9.2f sec = %12.2f rays/sec (wallclock)\n",
	       framenumber,
	       rtip->rti_nrays,
	       wallclock, ((double)(rtip->rti_nrays))/wallclock );
    }
    if ( outfp != NULL )  {
	/* Protect finished product */
	if ( outputfile != (char *)0 )
	    (void)bu_fchmod(outfp, 0444);

	(void)fclose(outfp);
	outfp = NULL;
    }

    if (R_DEBUG&RDEBUG_STATS)  {
	/* Print additional statistics */
	res_pr();
    }

    bu_log("\n");
    bu_free(pixmap, "pixmap allocate");
    pixmap = (unsigned char *)NULL;
    return(0);		/* OK */
}

/*
 *			D O _ A E
 *
 *  Compute the rotation specified by the azimuth and elevation
 *  parameters.  First, note that these are specified relative
 *  to the GIFT "front view", ie, model (X, Y, Z) is view (Z, X, Y):
 *  looking down X axis, Y right, Z up.
 *  A positive azimuth represents rotating the *eye* around the
 *  Y axis, or, rotating the *model* in -Y.
 *  A positive elevation represents rotating the *eye* around the
 *  X axis, or, rotating the *model* in -X.
 */
void
do_ae(double azim, double elev)
{
    vect_t	temp;
    vect_t	diag;
    mat_t	toEye;
    struct rt_i *rtip = ap.a_rt_i;

    if ( rtip->nsolids <= 0 )
	bu_exit(EXIT_FAILURE, "do_ae: no solids active\n");
    if ( rtip->nregions <= 0 )
	bu_exit(EXIT_FAILURE, "do_ae: no regions active\n");

    if ( rtip->mdl_max[X] >= INFINITY ) {
	bu_log("do_ae: infinite model bounds? setting a unit minimum\n");
	VSETALL( rtip->mdl_min, -1 );
    }
    if ( rtip->mdl_max[X] <= -INFINITY ) {
	bu_log("do_ae: infinite model bounds? setting a unit maximum\n");
	VSETALL( rtip->mdl_max, 1 );
    }

    /*
     *  Enlarge the model RPP just slightly, to avoid nasty
     *  effects with a solid's face being exactly on the edge
     *  NOTE:  This code is duplicated out of librt/tree.c/rt_prep(),
     *  and has to appear here to enable the viewsize calculation to
     *  match the final RPP.
     */
    rtip->mdl_min[X] = floor( rtip->mdl_min[X] );
    rtip->mdl_min[Y] = floor( rtip->mdl_min[Y] );
    rtip->mdl_min[Z] = floor( rtip->mdl_min[Z] );
    rtip->mdl_max[X] = ceil( rtip->mdl_max[X] );
    rtip->mdl_max[Y] = ceil( rtip->mdl_max[Y] );
    rtip->mdl_max[Z] = ceil( rtip->mdl_max[Z] );

    MAT_IDN( Viewrotscale );
    bn_mat_angles( Viewrotscale, 270.0+elev, 0.0, 270.0-azim );

    /* Look at the center of the model */
    MAT_IDN( toEye );
    toEye[MDX] = -((rtip->mdl_max[X]+rtip->mdl_min[X])/2.0);
    toEye[MDY] = -((rtip->mdl_max[Y]+rtip->mdl_min[Y])/2.0);
    toEye[MDZ] = -((rtip->mdl_max[Z]+rtip->mdl_min[Z])/2.0);

    /* Fit a sphere to the model RPP, diameter is viewsize,
     * unless viewsize command used to override.
     */
    if ( viewsize <= 0 ) {
	VSUB2( diag, rtip->mdl_max, rtip->mdl_min );
	viewsize = MAGNITUDE( diag );
	if ( aspect > 1 ) {
	    /* don't clip any of the image when autoscaling */
	    viewsize *= aspect;
	}
    }
    Viewrotscale[15] = 0.5*viewsize;	/* Viewscale */
    bn_mat_mul( model2view, Viewrotscale, toEye );
    bn_mat_inv( view2model, model2view );
    VSET( temp, 0, 0, eye_backoff );
    MAT4X3PNT( eye_model, view2model, temp );
}

/*
 *			R E S _ P R
 */
void
res_pr(void)
{
    register struct resource *res;
    register int i;

    fprintf(stderr, "\nResource use summary, by processor:\n");
    res = &resource[0];
    for ( i=0; i<npsw; i++, res++ )  {
	fprintf(stderr, "---CPU %d:\n", i);
	if ( res->re_magic != RESOURCE_MAGIC )  {
	    fprintf(stderr, "Bad magic number!!\n");
	    continue;
	}
	fprintf(stderr, "seg       len=%10ld get=%10ld free=%10ld\n",
		res->re_seglen, res->re_segget, res->re_segfree );
	fprintf(stderr, "partition len=%10ld get=%10ld free=%10ld\n",
		res->re_partlen, res->re_partget, res->re_partfree );
#if 0
	fprintf(stderr, "bitv_elem len=%10ld get=%10ld free=%10ld\n",
		res->re_bitvlen, res->re_bitvget, res->re_bitvfree );
#endif
	fprintf(stderr, "boolstack len=%10ld\n",
		res->re_boolslen);
    }
}

/*
 *  Command table for RT control script language
 */

struct command_tab rt_cmdtab[] = {
    {"start", "frame number", "start a new frame",
     cm_start,	2, 2},
    {"viewsize", "size in mm", "set view size",
     cm_vsize,	2, 2},
    {"eye_pt", "xyz of eye", "set eye point",
     cm_eyept,	4, 4},
    {"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
     cm_lookat_pt,	4, 5},
    {"viewrot", "4x4 matrix", "set view direction from matrix",
     cm_vrot,	17, 17},
    {"orientation", "quaturnion", "set view direction from quaturnion",
     cm_orientation,	5, 5},
    {"end", 	"", "end of frame setup, begin raytrace",
     cm_end,		1, 1},
    {"multiview", "", "produce stock set of views",
     cm_multiview,	1, 1},
    {"anim", 	"path type args", "specify articulation animation",
     cm_anim,	4, 999},
    {"tree", 	"treetop(s)", "specify alternate list of tree tops",
     cm_tree,	1, 999},
    {"clean", "", "clean articulation from previous frame",
     cm_clean,	1, 1},
    {"_closedb", "", "Close .g database, (for memory debugging)",
     cm_closedb,	1, 1},
    {"set", 	"", "show or set parameters",
     cm_set,		1, 999},
    {"ae", "azim elev", "specify view as azim and elev, in degrees",
     cm_ae,		3, 3},
    {"opt", "-flags", "set flags, like on command line",
     cm_opt,		2, 999},
    {(char *)0, (char *)0, (char *)0,
     0,		0, 0	/* END */}
};

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
commit refs/heads/pre-7-12-6
mark :32048
committer Clifford Yapp <starseeker@brlcad.org> 1217337271 +0000
data 48
Merge trunk r 31311-31319 - tweaks, adrt updates
from 4e81bdc1ccdce924b45d779735a587e3f89b41b5
M 100644 48e758f267bda92aa0222747059beb08c1e4e449 "TODO"
M 100644 d2fdfc251ab94dc2f68de1df886b2650465fc024 "configure.ac"
M 100644 e40501e3248f516850ff742cef19a66fe775d9d9 "doc/deprecation.txt"
M 100644 c929051dea14a760ca3cfe38a0af60be9aac5c0d "include/raytrace.h"
M 100644 7dee0e09a5f875db5cc5d4cd40ddc95238b1e374 "misc/nsis/brlcad.nsi"
M 100644 701f942fb9c63360dee5a943e3c8bdd7fbc1280c "misc/win32-msvc8/librt/librt.vcproj"
M 100644 9eafd2ba03946adabd27a9a7d27fe617fc7c7068 "misc/win32-msvc8/tclsh/library/installTree.tcl"
M 100644 304a06d2e6f6b5e1a53dc311181e3724839feae8 "src/adrt/Makefile.am"
M 100644 0b9e20987492ac738b92acf989776ae4e79e4794 "src/adrt/bench/bench.c"
M 100644 ca75788ed02b3519d1edf604976779c0caebf156 "src/adrt/isst/observer.c"
M 100644 a3654acc1d0ad6cf836975994146f11117c6015b "src/adrt/libcommon/unpack.c"
M 100644 b1e554a9ead77b3dc6f06e45cc9c67be0acb50f8 "src/adrt/libtienet/tienet_master.c"
M 100644 d5e5ff9cb2f6c3a8c93717df5e11610b84e64401 "src/adrt/libtienet/tienet_slave.c"
M 100644 dbbd98293b473c71d619b195fd1679fefdf4b2c3 "src/adrt/libtienet/tienet_slave.h"
M 100644 c4959de41345eb1637d8eba2a61d59325e423fa6 "src/adrt/libtienet/tienet_util.c"
M 100644 c940b9d5c5e091ba0269c9d60aad575b4825d611 "src/adrt/libtienet/tienet_util.h"
M 100644 c55ec3b268353470fe1a9ceaad31f0674e65e0c6 "src/adrt/libutil/Makefile.am"
M 100644 b23cde8aacea6b839a263f9ad40a1dd0dc03488b "src/adrt/master/compnet.c"
M 100644 fd44df1e2c6d637aa5649c446e5e66899be1f692 "src/adrt/master/master.c"
D "src/adrt/COPYING"
D "src/adrt/Doxyfile"
D "src/adrt/NEWS"
M 100644 da9aafd7cbf22f769b5221d7f34878fe4366f899 "src/libged/Makefile.am"
M 100644 cf18c6afe594c1b9f425589af745aa5830e829e6 "src/librt/Makefile.am"
M 100644 65223bcef50d527a95f4d8f9d032ed1bb522c03f "src/rt/do.c"

/*
 * C code from the article
 * "An Implicit Surface Polygonizer"
 * http::www.unchainedgeometry.com/jbloom/papers/polygonizer.pdf
 * by Jules Bloomenthal, jules@bloomenthal.com
 * in "Graphics Gems IV", Academic Press, 1994

 * Authored by Jules Bloomenthal, Xerox PARC.
 * Copyright (c) Xerox Corporation, 1991.  All rights reserved.
 * Permission is granted to reproduce, use and distribute this code for
 * any and all purposes, provided that this notice appears in all copies.  */

#include "common.h"

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <sys/types.h>

#include "vmath.h"

/**
 * Callback function signature for the function used to decide if the query
 * point q is inside or outside the surface.  The value in d is intended to
 * hold any information needed when evaluating the function.
 */
typedef int (*polygonize_func_t)(point_t *q, void *d);


/* Containers for polygonizer output */

struct polygonizer_vertex {            /* surface vertex */
    point_t position;
    point_t normal;                    /* surface normal */
};

/* list of vertices in polygonization */
struct polygonizer_vertices {
    int count;
    int max;
    struct polygonizer_vertex *ptr;
};

struct polygonizer_triangle {
    int i1;
    int i2;
    int i3;
};

struct polygonizer_triangles {
    int count;
    int max;
    struct polygonizer_triangle *ptr;
};

struct polygonizer_mesh {
    struct polygonizer_vertices vertices;
    struct polygonizer_triangles triangles;
};

void polygonizer_mesh_free(struct polygonizer_mesh *m);

/**
 * Callback function signature for the function called when a triangle is
 * generated - this allows an application (for example) to incrementally
 * display progress as the algorithm is running.
 *
 * i1, i2, i3 (indices into the vertex array defining the triangle)
 * vertices (the vertex array, indexed from 0)
 *
 * vertices are ccw when viewed from the out (positive) side in a left-handed
 * coordinate system
 *
 * vertex normals point outwards
 *
 * Function should return 1 to continue the polygonalization, 0 to abort
 */
typedef int (*polygonize_triproc_t)(int i1, int i2, int i3, struct polygonizer_vertices *vertices, void *d);

/**
 * @brief
 * An Implicit Surface Polygonizer
 *
 * Given a function to determine inside/outside for a surface, construct a
 * triangle approximation of that surface.
 *
 * @param[in]	pf	The implicit surface function - must return negative for inside, positive for outside
 * @param[in]	pf_d	Caller supplied data for pf evaluation - may be NULL
 * @param[in]   size	Width of the partitioning cube
 * @param[in]   bounds	Maximum range of cubes (+/- on the three axes) from first cube
 * @param[in]	p_s	Coordinates of a starting point on or near the surface
 * @param[in]	triproc Callback called for each triangle generated by the polygonalizer
 * @param[in]	pf_d	Caller supplied data for triproc callback - may be NULL
 *
 * @return	mesh	The faces and vertices generated by the polygonization, or NULL if failure
 */
struct polygonizer_mesh *
polygonize(
	polygonize_func_t pf,
	void *pf_d,
	fastf_t size,
	int bounds,
	point_t p_s,
	polygonize_triproc_t triproc,
	void *triproc_d);


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
